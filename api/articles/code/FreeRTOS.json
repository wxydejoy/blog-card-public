{"title":"FreeRTOS","slug":"code/FreeRTOS","date":"2023-01-18T12:50:28.000Z","updated":"2023-05-28T10:25:53.607Z","comments":true,"path":"api/articles/code/FreeRTOS.json","excerpt":null,"covers":["https://image.wxydejoy.top/utools/1673868627091_5gu53zc58zp8f24k.png","https://image.wxydejoy.top/utools/1673876690909_b8vj0bypy78dmygf.png","https://image.wxydejoy.top/utools/1673877102733_in4bdyrchoqtnblc.png","https://image.wxydejoy.top/utools/1673877501635_dwoab2ksj0cey9be.png","https://image.wxydejoy.top/utools/1673877706072_dh293c8je2izndds.png","https://image.wxydejoy.top/utools/1673877932075_6txse7co5pok1ngf.png","/!%5B%5D(https:/image.wxydejoy.top/utools/1673878043754_v3w2rdr4b3udx805.png)","https://image.wxydejoy.top/utools/1673878068181_kq43blmv75dwe00z.png","/pic/chap10/05_demon_task_priority_higher.png","https://image.wxydejoy.top/utools/1673878093734_wd0b1lpwo1bkxt5n.png","https://image.wxydejoy.top/utools/1673878165302_vn9b11k5d1g8o3jb.png","https://image.wxydejoy.top/utools/1673878428670_9qjlufv5a7dozv2z.png"],"content":"<blockquote>\n<p>大部分内容都为摘抄<br>其实已经看过很多遍，但一直没用过。</p>\n</blockquote>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p>\n<h3 id=\"FreeRTOS的5种内存管理方法\"><a href=\"#FreeRTOS的5种内存管理方法\" class=\"headerlink\" title=\"FreeRTOS的5种内存管理方法\"></a>FreeRTOS的5种内存管理方法</h3><table>\n<thead>\n<tr>\n<th>文件</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>heap_1.c</td>\n<td>分配简单，时间确定</td>\n<td>只分配、不回收</td>\n</tr>\n<tr>\n<td>heap_2.c</td>\n<td>动态分配、最佳匹配</td>\n<td>碎片、时间不定</td>\n</tr>\n<tr>\n<td>heap_3.c</td>\n<td>调用标准库函数</td>\n<td>速度慢、时间不定</td>\n</tr>\n<tr>\n<td>heap_4.c</td>\n<td>相邻空闲内存可合并</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n<tr>\n<td>heap_5.c</td>\n<td>在heap_4基础上支持分隔的内存块</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n</tbody></table>\n<h4 id=\"heap-1-c\"><a href=\"#heap-1-c\" class=\"headerlink\" title=\"heap_1.c\"></a>heap_1.c</h4><ul>\n<li><p>实现最简单</p>\n</li>\n<li><p>没有碎片问题</p>\n</li>\n<li><p>一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1</p>\n</li>\n</ul>\n<h4 id=\"heap-2-c-弃用\"><a href=\"#heap-2-c-弃用\" class=\"headerlink\" title=\"heap_2.c 弃用\"></a>heap_2.c 弃用</h4><p>Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。</p>\n<h4 id=\"heap-3-c\"><a href=\"#heap-3-c\" class=\"headerlink\" title=\"heap_3.c\"></a>heap_3.c</h4><p>Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。</p>\n<p>C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。</p>\n<h4 id=\"heap-4-c\"><a href=\"#heap-4-c\" class=\"headerlink\" title=\"heap_4.c\"></a>heap_4.c</h4><p>跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。</p>\n<p>Heap_4使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p>\n<h4 id=\"heap-5-c\"><a href=\"#heap-5-c\" class=\"headerlink\" title=\"heap_5.c\"></a>heap_5.c</h4><p>Heap_5分配内存、释放内存的算法跟Heap_4是一样的。</p>\n<p>相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</p>\n<p>在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。</p>\n<p>既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：</p>\n<p>在使用pvPortMalloc之前，必须先指定内存块的信息</p>\n<p>使用vPortDefineHeapRegions来指定这些信息</p>\n<h3 id=\"Heap相关的函数\"><a href=\"#Heap相关的函数\" class=\"headerlink\" title=\"Heap相关的函数\"></a>Heap相关的函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n</table>\n<p>void *pvPortMalloc( size_t xWantedSize ) | 分配内存<br>void vPortFree( void *pv ) | 释放内存<br>size_t xPortGetFreeHeapSize( void ) | 获取剩余内存<br>size_t xPortGetMinimumEverFreeHeapSize( void ) | 获取最小剩余内存</p>\n<p>malloc失败的钩子函数</p>\n<p>在pvPortMalloc函数内部</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xWantedSize )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( pvReturn == <span class=\"literal\">NULL</span> )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">vApplicationMallocFailedHook</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\">                vApplicationMallocFailedHook();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pvReturn;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，如果想使用这个钩子函数：</p>\n<p>在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1</p>\n<p>提供vApplicationMallocFailedHook函数</p>\n<p>pvPortMalloc失败时，才会调用此函数</p>\n<h2 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h2><p>在FreeRTOS中，任务就是一个函数，原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是：</p>\n<ul>\n<li>这个函数不能返回</li>\n<li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li>\n<li>函数内部，尽量使用局部变量：<ul>\n<li>每个任务都有自己的栈</li>\n<li>每个任务运行这个函数时<ul>\n<li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li>\n<li>不同任务的局部变量，有自己的副本</li>\n</ul>\n</li>\n<li>函数使用全局变量、静态变量的话<ul>\n<li>只有一个副本：多个任务使用的是同一个副本</li>\n<li>要防止冲突(后续会讲)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><p>创建任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>函数指针，可以简单地认为任务就是一个C函数。<br />它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td>\n</tr>\n<tr>\n<td>pcName</td>\n<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。<br />长度为：configMAX_TASK_NAME_LEN</td>\n</tr>\n<tr>\n<td>usStackDepth</td>\n<td>每个任务都有自己的栈，这里指定栈大小。<br />单位是word，比如传入100，表示栈大小为100 word，也就是400字节。<br />最大值为uint16_t的最大值。<br />怎么确定栈的大小，并不容易，很多时候是估计。<br />精确的办法是看反汇编码。</td>\n</tr>\n<tr>\n<td>pvParameters</td>\n<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>\n</tr>\n<tr>\n<td>uxPriority</td>\n<td>优先级范围：0~(configMAX_PRIORITIES – 1)<br />数值越小优先级越低，<br />如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td>\n</tr>\n<tr>\n<td>pxCreatedTask</td>\n<td>用来保存xTaskCreate的输出结果：task handle。<br />以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。<br />如果不想使用该handle，可以传入NULL。</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>成功：pdPASS；<br />失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)<br />注意：文档里都说失败时返回值是pdFAIL，这不对。<br />pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。</td>\n</tr>\n</tbody></table>\n<h3 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h3><p>删除任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。<br />也可传入NULL，这表示删除自己。</td>\n</tr>\n</tbody></table>\n<p>怎么删除任务？举个不好的例子：</p>\n<ul>\n<li>自杀：<code>vTaskDelete(NULL)</code></li>\n<li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是自己的句柄</li>\n<li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是别的任务的句柄</li>\n</ul>\n<h3 id=\"任务优先级和Tick\"><a href=\"#任务优先级和Tick\" class=\"headerlink\" title=\"任务优先级和Tick\"></a>任务优先级和Tick</h3><h4 id=\"任务优先级\"><a href=\"#任务优先级\" class=\"headerlink\" title=\"任务优先级\"></a>任务优先级</h4><p>在上个示例中我们体验过优先级的使用：高优先级的任务先运行。</p>\n<p>优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。</p>\n<p>FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。</p>\n<ul>\n<li>通用方法<br>使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。<br>configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。</li>\n<li>架构相关的优化的方法<br>架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。<br>使用这种方法时，configMAX_PRIORITIES的取值不能超过32。<br>configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。</li>\n</ul>\n<p>在学习调度方法之前，你只要初略地知道：</p>\n<ul>\n<li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li>\n<li>对于相同优先级的、可运行的任务，轮流执行</li>\n</ul>\n<p>这无需记忆，就像我们举的例子：</p>\n<ul>\n<li>厨房着火了，当然优先灭火</li>\n<li>喂饭、回复信息同样重要，轮流做</li>\n</ul>\n<h4 id=\"Tick\"><a href=\"#Tick\" class=\"headerlink\" title=\"Tick\"></a>Tick</h4><p>对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。</p>\n<h3 id=\"任务状态\"><a href=\"#任务状态\" class=\"headerlink\" title=\"任务状态\"></a>任务状态</h3><p>以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。</p>\n<p>对于非运行的状态，还可以继续细分，比如前面的<code>FreeRTOS_04_task_priority</code>中：</p>\n<ul>\n<li>Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行</li>\n<li>Task3运行期间，Task1、Task2也处于非运行状态，但是它们<strong>随时可以运行</strong></li>\n<li>这两种”非运行”状态就不一样，可以细分为：<ul>\n<li>阻塞状态(Blocked)</li>\n<li>暂停状态(Suspended)</li>\n<li>就绪状态(Ready)</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673868627091_5gu53zc58zp8f24k.png\"></p>\n<h3 id=\"Delay函数\"><a href=\"#Delay函数\" class=\"headerlink\" title=\"Delay函数\"></a>Delay函数</h3><p>有两个Delay函数：</p>\n<ul>\n<li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li>\n<li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。</li>\n</ul>\n<h3 id=\"空闲任务及其钩子函数\"><a href=\"#空闲任务及其钩子函数\" class=\"headerlink\" title=\"空闲任务及其钩子函数\"></a>空闲任务及其钩子函数</h3><p>为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用vTaskStartScheduler() 函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p>\n<p>空闲任务优先级为0：它不能阻碍用户任务运行</p>\n<p>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</p>\n<p>空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。</p>\n<p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p>\n<p>执行一些低优先级的、后台的、需要连续执行的函数</p>\n<p>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</p>\n<p>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</p>\n<p>空闲任务的钩子函数的限制：</p>\n<p>不能导致空闲任务进入阻塞状态、暂停状态</p>\n<p>如果你会使用vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</p>\n<h3 id=\"调度算法\"><a href=\"#调度算法\" class=\"headerlink\" title=\"调度算法\"></a>调度算法</h3><table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n<th>D</th>\n<th>E</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>configUSE_PREEMPTION</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>configUSE_TIME_SLICING</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>x</td>\n</tr>\n<tr>\n<td>configIDLE_SHOULD_YIELD</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>x</td>\n</tr>\n<tr>\n<td>说明</td>\n<td>常用</td>\n<td>很少用</td>\n<td>很少用</td>\n<td>很少用</td>\n<td>几乎不用</td>\n</tr>\n</tbody></table>\n<p>注：</p>\n<ul>\n<li><p>A：可抢占+时间片轮转+空闲任务让步</p>\n</li>\n<li><p>B：可抢占+时间片轮转+空闲任务不让步</p>\n</li>\n<li><p>C：可抢占+非时间片轮转+空闲任务让步</p>\n</li>\n<li><p>D：可抢占+非时间片轮转+空闲任务不让步</p>\n</li>\n<li><p>E：合作调度</p>\n</li>\n</ul>\n<h2 id=\"同步互斥与通信\"><a href=\"#同步互斥与通信\" class=\"headerlink\" title=\"同步互斥与通信\"></a>同步互斥与通信</h2><p>队列：</p>\n<p>里面可以放任意数据，可以放多个数据</p>\n<p>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</p>\n<p>事件组：</p>\n<p>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</p>\n<p>可以用来表示事件、事件的组合发生了，不能传递数据</p>\n<p>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</p>\n<p>信号量：</p>\n<p>核心是”计数值”</p>\n<p>任务、ISR释放信号量时让计数值加1</p>\n<p>任务、ISR获得信号量时，让计数值减1</p>\n<p>任务通知：</p>\n<p>核心是任务的TCB里的数值</p>\n<p>会被覆盖</p>\n<p>发通知给谁？必须指定接收任务</p>\n<p>只能由接收任务本身获取该通知</p>\n<p>互斥量：</p>\n<p>数值只有0或1</p>\n<p>谁获得互斥量，就必须由谁释放同一个互斥量</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列(queue)可以用于”任务到任务”、”任务到中断”、”中断到任务”直接传输信息。</p>\n<ul>\n<li><p>队列可以包含若干个数据：队列中有若干项，这被称为”长度”(length)</p>\n</li>\n<li><p>每个数据大小固定</p>\n</li>\n<li><p>创建队列时就要指定长度、数据大小</p>\n</li>\n<li><p>数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读</p>\n</li>\n<li><p>也可以强制写队列头部：覆盖头部数据</p>\n</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673876690909_b8vj0bypy78dmygf.png\"></p>\n<h3 id=\"队列的特性\"><a href=\"#队列的特性\" class=\"headerlink\" title=\"队列的特性\"></a>队列的特性</h3><h4 id=\"传输数据的两种方法\"><a href=\"#传输数据的两种方法\" class=\"headerlink\" title=\"传输数据的两种方法\"></a>传输数据的两种方法</h4><p>FreeRTOS使用拷贝值的方法，这更简单：</p>\n<ul>\n<li><p>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</p>\n</li>\n<li><p>无需分配buffer来保存数据，队列中有buffer</p>\n</li>\n<li><p>局部变量可以马上再次使用</p>\n</li>\n<li><p>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</p>\n</li>\n<li><p>如果数据实在太大，你还是可以使用队列传输它的地址</p>\n</li>\n<li><p>队列的空间有FreeRTOS内核分配，无需任务操心</p>\n</li>\n<li><p>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</p>\n</li>\n</ul>\n<h4 id=\"队列阻塞访问\"><a href=\"#队列阻塞访问\" class=\"headerlink\" title=\"队列阻塞访问\"></a>队列阻塞访问</h4><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p>\n<p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p>\n<p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p>\n<p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p>\n<p>优先级最高的任务</p>\n<p>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</p>\n<p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p>\n<p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p>\n<p>优先级最高的任务</p>\n<p>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</p>\n<h3 id=\"队列函数\"><a href=\"#队列函数\" class=\"headerlink\" title=\"队列函数\"></a>队列函数</h3><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p>\n<ul>\n<li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreate</span><span class=\"params\">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>uxQueueLength</td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td>uxItemSize</td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列<br />NULL：失败，因为内存不足</td>\n</tr>\n</tbody></table>\n<ul>\n<li>静态分配内存：xQueueCreateStatic，队列的内存要事先分配好</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreateStatic</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           UBaseType_t uxQueueLength,</span></span><br><span class=\"line\"><span class=\"params\">                           UBaseType_t uxItemSize,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">uint8_t</span> *pucQueueStorageBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                           StaticQueue_t *pxQueueBuffer</span></span><br><span class=\"line\"><span class=\"params\">                       )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>uxQueueLength</td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td>uxItemSize</td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr>\n<td>pucQueueStorageBuffer</td>\n<td>如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组，<br />此数组大小至少为”uxQueueLength * uxItemSize”</td>\n</tr>\n<tr>\n<td>pxQueueBuffer</td>\n<td>必须执行一个StaticQueue_t结构体，用来保存队列的数据结构</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列<br />NULL：失败，因为pxQueueBuffer为NULL</td>\n</tr>\n</tbody></table>\n<p>示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> QUEUE_LENGTH 10</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// xQueueBuffer用来保存队列结构体</span></span><br><span class=\"line\"> StaticQueue_t xQueueBuffer;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// ucQueueStorage 用来保存队列的数据</span></span><br><span class=\"line\"> <span class=\"comment\">// 大小为：队列长度 * 数据大小</span></span><br><span class=\"line\"> <span class=\"type\">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">vATask</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\tQueueHandle_t xQueue1;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span></span><br><span class=\"line\">\txQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class=\"line\">\t\t\t\t\t\t  ITEM_SIZE,</span><br><span class=\"line\">\t\t\t\t\t\t  ucQueueStorage,</span><br><span class=\"line\">\t\t\t\t\t\t  &amp;xQueueBuffer ); </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"复位\"><a href=\"#复位\" class=\"headerlink\" title=\"复位\"></a>复位</h4><p>队列刚被创建时，里面没有数据；使用过程中可以调用<code>xQueueReset()</code>把队列恢复为初始状态，此函数原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pxQueue : 复位哪个队列;</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS(必定成功)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReset</span><span class=\"params\">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>删除队列的函数为<code>vQueueDelete()</code>，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vQueueDelete</span><span class=\"params\">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"写队列\"><a href=\"#写队列\" class=\"headerlink\" title=\"写队列\"></a>写队列</h4><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 等同于xQueueSendToBack</span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBack</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBackFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToFront</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToFrontFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这些函数用到的参数是类似的，统一说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueue</td>\n<td>队列句柄，要写哪个队列</td>\n</tr>\n<tr>\n<td>pvItemToQueue</td>\n<td>数据指针，这个数据的值会被复制进队列，<br />复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态，<br />xTicksToWait表示阻塞的最大时间(Tick Count)。<br />如果被设为0，无法写入数据时函数会立刻返回；<br />如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：数据成功写入了队列<br />errQUEUE_FULL：写入失败，因为队列满了。</td>\n</tr>\n</tbody></table>\n<h4 id=\"读队列\"><a href=\"#读队列\" class=\"headerlink\" title=\"读队列\"></a>读队列</h4><p>使用<code>xQueueReceive()</code>函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceive</span><span class=\"params\">( QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                    QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">void</span>             *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                                    BaseType_t       *pxTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueue</td>\n<td>队列句柄，要读哪个队列</td>\n</tr>\n<tr>\n<td>pvBuffer</td>\n<td>bufer指针，队列的数据会被复制到这个buffer<br />复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>果队列空则无法读出数据，可以让任务进入阻塞状态，<br />xTicksToWait表示阻塞的最大时间(Tick Count)。<br />如果被设为0，无法读出数据时函数会立刻返回；<br />如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：从队列读出数据入<br />errQUEUE_EMPTY：读取失败，因为队列空了。</td>\n</tr>\n</tbody></table>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用数据的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueMessagesWaiting</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用空间的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueSpacesAvailable</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"覆盖-x2F-偷看\"><a href=\"#覆盖-x2F-偷看\" class=\"headerlink\" title=\"覆盖&#x2F;偷看\"></a>覆盖&#x2F;偷看</h4><p>当队列长度为1时，可以使用<code>xQueueOverwrite()</code>或<code>xQueueOverwriteFromISR()</code>来覆盖数据。<br>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。<br>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 覆盖队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 写哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwrite</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwriteFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是<code>xQueuePeek()</code>或<code>xQueuePeekFromISR()</code>。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。<br>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 偷看队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 偷看哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeek</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                          QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeekFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                 QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">void</span> *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                             )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。</p>\n<p>有时候我们只需要传递状态，并不需要传递具体的信息，比如：</p>\n<p>我的事做完了，通知一下你</p>\n<p>卖包子了、卖包子了，做好了1个包子！做好了2个包子！做好了3个包子！</p>\n<p>这个停车位我占了，你们只能等着</p>\n<p>在这种情况下我们可以使用信号量(semaphore)，它更节省内存。</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877102733_in4bdyrchoqtnblc.png\"></p>\n<h3 id=\"信号量的常规操作\"><a href=\"#信号量的常规操作\" class=\"headerlink\" title=\"信号量的常规操作\"></a>信号量的常规操作</h3><h4 id=\"两种信号量的对比\"><a href=\"#两种信号量的对比\" class=\"headerlink\" title=\"两种信号量的对比\"></a>两种信号量的对比</h4><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p>\n<p>差别列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>二进制信号量</th>\n<th>技术型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>被创建时初始值为0</td>\n<td>被创建时初始值可以设定</td>\n</tr>\n<tr>\n<td>其他操作是一样的</td>\n<td>其他操作是一样的</td>\n</tr>\n</tbody></table>\n<h3 id=\"信号量函数\"><a href=\"#信号量函数\" class=\"headerlink\" title=\"信号量函数\"></a>信号量函数</h3><h4 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。</p>\n<p>对于二进制信号量、计数型信号量，它们的创建函数不一样：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>二进制信号量</th>\n<th>计数型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>动态创建</td>\n<td>xSemaphoreCreateBinary<br />计数值初始值为0</td>\n<td>xSemaphoreCreateCounting</td>\n</tr>\n<tr>\n<td></td>\n<td>vSemaphoreCreateBinary(过时了)<br />计数值初始值为1</td>\n<td></td>\n</tr>\n<tr>\n<td>静态创建</td>\n<td>xSemaphoreCreateBinaryStatic</td>\n<td>xSemaphoreCreateCountingStatic</td>\n</tr>\n</tbody></table>\n<p>创建二进制信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinary</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinaryStatic</span><span class=\"params\">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>创建计数型信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCounting</span><span class=\"params\">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCountingStatic</span><span class=\"params\">( UBaseType_t uxMaxCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 UBaseType_t uxInitialCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p>\n<p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"give-x2F-take\"><a href=\"#give-x2F-take\" class=\"headerlink\" title=\"give&#x2F;take\"></a>give&#x2F;take</h4><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>在任务中使用</th>\n<th>在ISR中使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>give</td>\n<td>xSemaphoreGive</td>\n<td>xSemaphoreGiveFromISR</td>\n</tr>\n<tr>\n<td>take</td>\n<td>xSemaphoreTake</td>\n<td>xSemaphoreTakeFromISR</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreGive的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGive函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功,<br />如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；<br />如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>pxHigherPriorityTaskWoken的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>如果释放信号量导致更高优先级的任务变为了就绪态，<br />则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功,<br />如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；<br />如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTake的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                   TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">               )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTake函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果无法马上获得信号量，阻塞一会：<br />0：不阻塞，马上返回<br />portMAX_DELAY: 一直阻塞直到成功<br />其他值: 阻塞的Tick个数，可以使用<code>pdMS_TO_TICKS()</code>来指定阻塞时间为若干ms</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTakeFromISR的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTakeFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>如果获取信号量导致更高优先级的任务变为了就绪态，<br />则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<h2 id=\"互斥量\"><a href=\"#互斥量\" class=\"headerlink\" title=\"互斥量\"></a>互斥量</h2><p>在多任务系统中，任务A正在使用某个资源，还没用完的情况下任务B也来使用的话，就可能导致问题。</p>\n<p>比如对于串口，任务A正使用它来打印，在打印过程中任务B也来打印，客户看到的结果就是A、B的信息混杂在一起。</p>\n<p>上述问题的解决方法是：任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。</p>\n<p>互斥量也被称为互斥锁，使用过程如下：</p>\n<p>互斥量初始值为1</p>\n<p>任务A想访问临界资源，先获得并占有互斥量，然后开始访问</p>\n<p>任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞</p>\n<p>任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源</p>\n<p>任务B使用完毕，释放互斥量</p>\n<p>正常来说：在任务A占有互斥量的过程中，任务B、任务C等等，都无法释放互斥量。</p>\n<p>但是FreeRTOS未实现这点：任务A占有互斥量的情况下，任务B也可释放互斥量。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>互斥量是一种特殊的二进制信号量。</p>\n<p>使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。</p>\n<p>创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配互斥量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateMutex</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateMutexStatic</span><span class=\"params\">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> configUSE_MUTEXES 1</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h4><p>要注意的是，互斥量不能在ISR中使用。</p>\n<p>各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 释放 */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 释放(ISR版本) */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                       SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                       BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 获得 */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                   TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">               )</span>;</span><br><span class=\"line\"><span class=\"comment\">/* 获得(ISR版本) */</span></span><br><span class=\"line\">xSemaphoreGiveFromISR(</span><br><span class=\"line\">                       SemaphoreHandle_t xSemaphore,</span><br><span class=\"line\">                       BaseType_t *pxHigherPriorityTaskWoken</span><br><span class=\"line\">                   );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h2><p>事件组可以简单地认为就是一个整数：</p>\n<ul>\n<li>每一位表示一个事件</li>\n<li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li>\n<li>这些位，值为1表示事件发生了，值为0表示事件没发生</li>\n<li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li>\n<li>可以等待某一位、某些位中的任意一个，也可以等待多位</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877501635_dwoab2ksj0cey9be.png\"></p>\n<p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p>\n<ul>\n<li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li>\n<li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li>\n<li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul>\n<li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li>\n<li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件组的操作\"><a href=\"#事件组的操作\" class=\"headerlink\" title=\"事件组的操作\"></a>事件组的操作</h3><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p>\n<ul>\n<li>唤醒谁？<ul>\n<li>队列、信号量：事件发生时，只会唤醒一个任务</li>\n<li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li>\n</ul>\n</li>\n<li>是否清除事件？<ul>\n<li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li>\n<li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li>\n</ul>\n</li>\n</ul>\n<p>以上图为列，事件组的常规操作如下：</p>\n<ul>\n<li><p>先创建事件组</p>\n</li>\n<li><p>任务C、D等待事件：</p>\n<ul>\n<li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li>\n<li>得到事件时，要不要清除？可选择清除、不清除。</li>\n</ul>\n</li>\n<li><p>任务A、B产生事件：设置事件组里的某一位、某些位</p>\n</li>\n</ul>\n<h3 id=\"事件组函数\"><a href=\"#事件组函数\" class=\"headerlink\" title=\"事件组函数\"></a>事件组函数</h3><h4 id=\"创建-3\"><a href=\"#创建-3\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p>\n<p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配事件组结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreate</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreateStatic</span><span class=\"params\">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除-2\"><a href=\"#删除-2\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p>\n<p>vEventGroupDelete可以用来删除事件组，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vEventGroupDelete</span><span class=\"params\">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"设置事件\"><a href=\"#设置事件\" class=\"headerlink\" title=\"设置事件\"></a>设置事件</h4><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p>\n<ul>\n<li>在任务中使用<code>xEventGroupSetBits()</code></li>\n<li>在ISR中使用<code>xEventGroupSetBitsFromISR()</code></li>\n</ul>\n<p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSetBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xEventGroupSetBitsFromISR</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  <span class=\"type\">const</span> EventBits_t uxBitsToSet,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>值得注意的是，ISR中的函数，比如队列函数<code>xQueueSendToBackFromISR</code>、信号量函数<code>xSemaphoreGiveFromISR</code>，它们会唤醒某个任务，最多只会唤醒1个任务。</p>\n<p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<code>xEventGroupSetBitsFromISR</code>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>\n<p>如果后台任务的优先级比当前被中断的任务优先级高，<code>xEventGroupSetBitsFromISR</code>会设置<code>*pxHigherPriorityTaskWoken</code>为pdTRUE。</p>\n<p>如果daemon task成功地把队列数据发送给了后台任务，那么<code>xEventGroupSetBitsFromISR</code>的返回值就是pdPASS。</p>\n<h4 id=\"等待事件\"><a href=\"#等待事件\" class=\"headerlink\" title=\"等待事件\"></a>等待事件</h4><p>使用<code>xEventGroupWaitBits</code>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupWaitBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p>\n<p>函数参数说明列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xEventGroup</td>\n<td>等待哪个事件组？</td>\n</tr>\n<tr>\n<td>uxBitsToWaitFor</td>\n<td>等待哪些位？哪些位要被测试？</td>\n</tr>\n<tr>\n<td>xWaitForAllBits</td>\n<td>怎么测试？是”AND”还是”OR”？<br />pdTRUE: 等待的位，全部为1;<br />pdFALSE: 等待的位，某一个为1即可</td>\n</tr>\n<tr>\n<td>xClearOnExit</td>\n<td>函数提出前是否要清除事件？<br />pdTRUE: 清除uxBitsToWaitFor指定的位<br />pdFALSE: 不清除</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果期待的事件未发生，阻塞多久。<br />可以设置为0：判断后即刻返回；<br />可设置为portMAX_DELAY：一定等到成功才返回；<br />可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>返回的是事件值，<br />如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br />如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<p>举例如下：</p>\n<table>\n<thead>\n<tr>\n<th>事件组的值</th>\n<th>uxBitsToWaitFor</th>\n<th>xWaitForAllBits</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0100</td>\n<td>0101</td>\n<td>pdTRUE</td>\n<td>任务期望bit0,bit2都为1，<br />当前值只有bit2满足，任务进入阻塞态；<br />当事件组中bit0,bit2都为1时退出阻塞态</td>\n</tr>\n<tr>\n<td>0100</td>\n<td>0110</td>\n<td>pdFALSE</td>\n<td>任务期望bit0,bit2某一个为1，<br />当前值满足，所以任务成功退出</td>\n</tr>\n<tr>\n<td>0100</td>\n<td>0110</td>\n<td>pdTRUE</td>\n<td>任务期望bit1,bit2都为1，<br />当前值不满足，任务进入阻塞态；<br />当事件组中bit1,bit2都为1时退出阻塞态</td>\n</tr>\n</tbody></table>\n<p>你可以使用<code>xEventGroupWaitBits()</code>等待期望的事件，它发生之后再使用<code>xEventGroupClearBits()</code>来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p>\n<p>可以使用设置<code>xClearOnExit</code>为pdTRUE，使得对事件组的测试、清零都在<code>xEventGroupWaitBits()</code>函数内部完成，这是一个原子操作。</p>\n<h4 id=\"同步点\"><a href=\"#同步点\" class=\"headerlink\" title=\"同步点\"></a>同步点</h4><p>有一个事情需要多个任务协同，比如：</p>\n<ul>\n<li>任务A：炒菜</li>\n<li>任务B：买酒</li>\n<li>任务C：摆台</li>\n<li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li>\n</ul>\n<p>使用<code>xEventGroupSync()</code>函数可以同步多个任务：</p>\n<ul>\n<li>可以设置某位、某些位，表示自己做了什么事</li>\n<li>可以等待某位、某些位，表示要等等其他任务</li>\n<li>期望的时间发生后，<code>xEventGroupSync()</code>才会成功返回。</li>\n<li><code>xEventGroupSync</code>成功返回后，会清除事件</li>\n</ul>\n<p><code>xEventGroupSync</code>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSync</span><span class=\"params\">(    EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> EventBits_t uxBitsToSet,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xEventGroup</td>\n<td>哪个事件组？</td>\n</tr>\n<tr>\n<td>uxBitsToSet</td>\n<td>要设置哪些事件？我完成了哪些事件？<br />比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>\n</tr>\n<tr>\n<td>uxBitsToWaitFor</td>\n<td>等待那个位、哪些位？<br />比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果期待的事件未发生，阻塞多久。<br />可以设置为0：判断后即刻返回；<br />可设置为portMAX_DELAY：一定等到成功才返回；<br />可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>返回的是事件值，<br />如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br />如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<h2 id=\"任务通知\"><a href=\"#任务通知\" class=\"headerlink\" title=\"任务通知\"></a>任务通知</h2><p>所谓”任务通知”，你可以反过来读”通知任务”。</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877706072_dh293c8je2izndds.png\"></p>\n<p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p>\n<h3 id=\"优势及限制\"><a href=\"#优势及限制\" class=\"headerlink\" title=\"优势及限制\"></a>优势及限制</h3><p>任务通知的优势：</p>\n<ul>\n<li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li>\n<li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>\n</ul>\n<p>任务通知的限制：</p>\n<ul>\n<li>不能发送数据给ISR：<br>ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li>\n<li>数据只能给该任务独享<br>使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。<br>在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li>\n<li>无法缓冲数据<br>使用队列时，假设队列深度为N，那么它可以保持N个数据。<br>使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li>\n<li>无法广播给多个任务<br>使用事件组可以同时给多个任务发送事件。<br>使用任务通知，只能发个一个任务。</li>\n<li>如果发送受阻，发送方无法进入阻塞状态等待<br>假设队列已经满了，使用<code>xQueueSendToBack()</code>给队列发送数据时，任务可以进入阻塞状态等待发送完成。<br>使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li>\n</ul>\n<h3 id=\"通知状态和通知值\"><a href=\"#通知状态和通知值\" class=\"headerlink\" title=\"通知状态和通知值\"></a>通知状态和通知值</h3><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：</p>\n<ul>\n<li>一个是uint8_t类型，用来表示通知状态</li>\n<li>一个是uint32_t类型，用来表示通知值</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tskTaskControlBlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125; tskTCB;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通知状态有3种取值：</p>\n<ul>\n<li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li>\n<li>taskWAITING_NOTIFICATION：任务在等待通知</li>\n<li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class=\"comment\">/* 也是初始状态 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通知值可以有很多种类型：</p>\n<ul>\n<li>计数值</li>\n<li>位(类似事件组)</li>\n<li>任意数值</li>\n</ul>\n<h3 id=\"任务通知的使用\"><a href=\"#任务通知的使用\" class=\"headerlink\" title=\"任务通知的使用\"></a>任务通知的使用</h3><p>使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p>\n<h4 id=\"两类函数\"><a href=\"#两类函数\" class=\"headerlink\" title=\"两类函数\"></a>两类函数</h4><p>任务通知有2套函数，简化版、专业版，列表如下：</p>\n<ul>\n<li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li>\n<li>专业版函数支持很多参数，可以实现很多功能</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>简化版</th>\n<th>专业版</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>发出通知</td>\n<td>xTaskNotifyGive<br />vTaskNotifyGiveFromISR</td>\n<td>xTaskNotify<br />xTaskNotifyFromISR</td>\n</tr>\n<tr>\n<td>取出通知</td>\n<td>ulTaskNotifyTake</td>\n<td>xTaskNotifyWait</td>\n</tr>\n</tbody></table>\n<h4 id=\"xTaskNotifyGive-x2F-ulTaskNotifyTake\"><a href=\"#xTaskNotifyGive-x2F-ulTaskNotifyTake\" class=\"headerlink\" title=\"xTaskNotifyGive&#x2F;ulTaskNotifyTake\"></a>xTaskNotifyGive&#x2F;ulTaskNotifyTake</h4><p>在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知：</p>\n<ul>\n<li>使得通知值加一</li>\n<li>并使得通知状态变为”pending”，也就是<code>taskNOTIFICATION_RECEIVED</code>，表示有数据了、待处理</li>\n</ul>\n<p>可以使用ulTaskNotifyTake函数来取出通知值：</p>\n<ul>\n<li>如果通知值等于0，则阻塞(可以指定超时时间)</li>\n<li>当通知值大于0时，任务从阻塞态进入就绪态</li>\n<li>在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li>\n</ul>\n<p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyGive</span><span class=\"params\">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskNotifyGiveFromISR</span><span class=\"params\">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">ulTaskNotifyTake</span><span class=\"params\">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>xTaskNotifyGive函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xTaskToNotify</td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>必定返回pdPASS</td>\n</tr>\n</tbody></table>\n<p>vTaskNotifyGiveFromISR函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xTaskHandle</td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>被通知的任务，可能正处于阻塞状态。<br />此函数发出通知后，会把它从阻塞状态切换为就绪态。<br />如果被唤醒的任务的优先级，高于当前任务的优先级，<br />则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，<br />这表示在中断返回之前要进行任务切换。</td>\n</tr>\n</tbody></table>\n<p>ulTaskNotifyTake函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xClearCountOnExit</td>\n<td>函数返回前是否清零：<br />pdTRUE：把通知值清零<br />pdFALSE：如果通知值大于0，则把通知值减一</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>任务进入阻塞态的超时时间，它在等待通知值大于0。<br />0：不等待，即刻返回；<br />portMAX_DELAY：一直等待，直到通知值大于0；<br />其他值：Tick Count，可以用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>函数返回之前，在清零或减一之前的通知值。<br />如果xTicksToWait非0，则返回值有2种情况：<br />1. 大于0：在超时前，通知值被增加了<br />2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td>\n</tr>\n</tbody></table>\n<h4 id=\"xTaskNotify-x2F-xTaskNotifyWait\"><a href=\"#xTaskNotify-x2F-xTaskNotifyWait\" class=\"headerlink\" title=\"xTaskNotify&#x2F;xTaskNotifyWait\"></a>xTaskNotify&#x2F;xTaskNotifyWait</h4><p><code>xTaskNotify</code> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p>\n<ul>\n<li>让接收任务的通知值加一：这时<code>xTaskNotify()</code>等同于<code>xTaskNotifyGive()</code></li>\n<li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li>\n<li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li>\n<li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似<code>xQueueOverwrite()</code>函数，这就是轻量级的邮箱。</li>\n</ul>\n<p><code>xTaskNotify()</code>比<code>xTaskNotifyGive()</code>更灵活、强大，使用上也就更复杂。<code>xTaskNotifyFromISR()</code>是它对应的ISR版本。</p>\n<p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p>\n<p>使用<code>xTaskNotifyWait()</code>函数！它比<code>ulTaskNotifyTake()</code>更复杂：</p>\n<ul>\n<li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li>\n<li>还可以在函数进入、退出时，清除通知值的指定位</li>\n</ul>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotify</span><span class=\"params\">( TaskHandle_t xTaskToNotify, <span class=\"type\">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyFromISR</span><span class=\"params\">( TaskHandle_t xTaskToNotify,</span></span><br><span class=\"line\"><span class=\"params\">                               <span class=\"type\">uint32_t</span> ulValue, </span></span><br><span class=\"line\"><span class=\"params\">                               eNotifyAction eAction, </span></span><br><span class=\"line\"><span class=\"params\">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyWait</span><span class=\"params\">( <span class=\"type\">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> *pulNotificationValue, </span></span><br><span class=\"line\"><span class=\"params\">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>xTaskNotify函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xTaskToNotify</td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td>ulValue</td>\n<td>怎么使用ulValue，由eAction参数决定</td>\n</tr>\n<tr>\n<td>eAction</td>\n<td>见下表</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：成功，大部分调用都会成功<br />pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite，<br />                并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td>\n</tr>\n</tbody></table>\n<p>eNotifyAction参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>eNotifyAction取值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>eNoAction</td>\n<td>仅仅是更新通知状态为”pending”，未使用ulValue。<br />这个选项相当于轻量级的、更高效的二进制信号量。</td>\n</tr>\n<tr>\n<td>eSetBits</td>\n<td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。<br />相当于轻量级的、更高效的事件组。</td>\n</tr>\n<tr>\n<td>eIncrement</td>\n<td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。<br />相当于轻量级的、更高效的二进制信号量、计数型信号量。<br />相当于<code>xTaskNotifyGive()</code>函数。</td>\n</tr>\n<tr>\n<td>eSetValueWithoutOverwrite</td>\n<td>不覆盖。<br />如果通知状态为”pending”(表示有数据未读)，<br />则此次调用xTaskNotify不做任何事，返回pdFAIL。<br />如果通知状态不是”pending”(表示没有新数据)，<br />则：通知值 &#x3D; ulValue。</td>\n</tr>\n<tr>\n<td>eSetValueWithOverwrite</td>\n<td>覆盖。<br />无论如何，不管通知状态是否为”pendng”，<br />通知值 &#x3D; ulValue。</td>\n</tr>\n</tbody></table>\n<p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<code>pxHigherPriorityTaskWoken</code>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p>\n<ul>\n<li>被通知的任务，可能正处于阻塞状态</li>\n<li><code>xTaskNotifyFromISR</code>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li>\n<li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li>\n</ul>\n<p>xTaskNotifyWait函数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ulBitsToClearOnEntry</td>\n<td>在xTaskNotifyWait入口处，要清除通知值的哪些位？<br />通知状态不是”pending”的情况下，才会清除。<br />它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。<br />能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。<br />比如传入0x01，表示清除通知值的bit0；<br />传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td>ulBitsToClearOnExit</td>\n<td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时：<br />通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。<br />在清除某些位之前，通知值先被赋给”*pulNotificationValue”。<br />比如入0x03，表示清除通知值的bit0、bit1；<br />传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td>pulNotificationValue</td>\n<td>用来取出通知值。<br />在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。<br />如果不需要取出通知值，可以设为NULL。</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。<br />0：不等待，即刻返回；<br />portMAX_DELAY：一直等待，直到通知状态变为”pending”；<br />其他值：Tick Count，可以用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>1. pdPASS：成功<br />这表示xTaskNotifyWait成功获得了通知：<br />可能是调用函数之前，通知状态就是”pending”；<br />也可能是在阻塞期间，通知状态变为了”pending”。<br />2. pdFAIL：没有得到通知。</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件定时器\"><a href=\"#软件定时器\" class=\"headerlink\" title=\"软件定时器\"></a>软件定时器</h2><h3 id=\"软件定时器的特性\"><a href=\"#软件定时器的特性\" class=\"headerlink\" title=\"软件定时器的特性\"></a>软件定时器的特性</h3><p>我们在手机上添加闹钟时，需要指定时间、指定类型(一次性的，还是周期性的)、指定做什么事；还有一些过时的、不再使用的闹钟。</p>\n<p>使用定时器跟使用手机闹钟是类似的：</p>\n<ul>\n<li>指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。</li>\n<li>指定类型，定时器有两种类型：<ul>\n<li>一次性(One-shot timers)：<br>这类定时器启动后，它的回调函数只会被调用一次；<br>可以手工再次启动它，但是不会自动启动它。</li>\n<li>自动加载定时器(Auto-reload timers )：<br>这类定时器启动后，时间到之后它会自动启动它；<br>这使得回调函数被周期性地调用。</li>\n</ul>\n</li>\n<li>指定要做什么事，就是指定回调函数</li>\n</ul>\n<p>实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：</p>\n<ul>\n<li>运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li>\n<li>冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li>\n</ul>\n<p>定时器运行情况示例如下：</p>\n<ul>\n<li>Timer1：它是一次性的定时器，在t1启动，周期是6个Tick。经过6个tick后，在t7执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。</li>\n<li>Timer2：它是自动加载的定时器，在t1启动，周期是5个Tick。每经过5个tick它的回调函数都被执行，比如在t6、t11、t16都会执行。</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877932075_6txse7co5pok1ngf.png\"></p>\n<h3 id=\"软件定时器的上下文\"><a href=\"#软件定时器的上下文\" class=\"headerlink\" title=\"软件定时器的上下文\"></a>软件定时器的上下文</h3><h4 id=\"守护任务\"><a href=\"#守护任务\" class=\"headerlink\" title=\"守护任务\"></a>守护任务</h4><p>要理解软件定时器API函数的参数，特别是里面的<code>xTicksToWait</code>，需要知道定时器执行的过程。</p>\n<p>FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行。在哪里执行定时器函数？第一印象就是在Tick中断里执行：</p>\n<ul>\n<li>在Tick中断中判断定时器是否超时</li>\n<li>如果超时了，调用它的回调函数</li>\n</ul>\n<p>FreeRTOS是RTOS，它不允许在内核、在中断中执行不确定的代码：如果定时器函数很耗时，会影响整个系统。</p>\n<p>所以，FreeRTOS中，不在Tick中断中执行定时器函数。</p>\n<p>在哪里执行？在某个任务里执行，这个任务就是：RTOS Damemon Task，RTOS守护任务。以前被称为”Timer server”，但是这个任务要做并不仅仅是定时器相关，所以改名为：RTOS Damemon Task。</p>\n<p>当FreeRTOS的配置项<code>configUSE_TIMERS</code>被设置为1时，在启动调度器时，会自动创建RTOS Damemon Task。</p>\n<p>我们自己编写的任务函数要使用定时器时，是通过”定时器命令队列”(timer command queue)和守护任务交互，如下图所示：</p>\n<p><img src=\"/!%5B%5D(https:/image.wxydejoy.top/utools/1673878043754_v3w2rdr4b3udx805.png)\" alt=\"image-20210809193524596\"></p>\n<p>守护任务的优先级为：configTIMER_TASK_PRIORITY；定时器命令队列的长度为configTIMER_QUEUE_LENGTH。</p>\n<h4 id=\"守护任务的调度\"><a href=\"#守护任务的调度\" class=\"headerlink\" title=\"守护任务的调度\"></a>守护任务的调度</h4><p>守护任务的调度，跟普通的任务并无差别。当守护任务是当前优先级最高的就绪态任务时，它就可以运行。它的工作有两类：</p>\n<ul>\n<li>处理命令：从命令队列里取出命令、处理</li>\n<li>执行定时器的回调函数</li>\n</ul>\n<p>能否及时处理定时器的命令、能否及时执行定时器的回调函数，严重依赖于守护任务的优先级。下面使用2个例子来演示。</p>\n<p>例子1：守护任务的优先性级较低</p>\n<ul>\n<li><p>t1：Task1处于运行态，守护任务处于阻塞态。<br>守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。<br>至于守护任务能否马上执行，取决于它的优先级。</p>\n</li>\n<li><p>t2：Task1调用<code>xTimerStart()</code><br>要注意的是，<code>xTimerStart()</code>只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。<br>在本例中，Task1的优先级高于守护任务，所以守护任务无法抢占Task1。</p>\n</li>\n<li><p>t3：Task1执行完<code>xTimerStart()</code><br>但是定时器的启动工作由守护任务来实现，所以<code>xTimerStart()</code>返回并不表示定时器已经被启动了。</p>\n</li>\n<li><p>t4：Task1由于某些原因进入阻塞态，现在轮到守护任务运行。<br>守护任务从队列中取出”start timer”命令，启动定时器。</p>\n</li>\n<li><p>t5：守护任务处理完队列中所有的命令，再次进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。</p>\n</li>\n<li><p>注意：假设定时器在后续某个时刻tX超时了，超时时间是”tX-t2”，而非”tX-t4”，从<code>xTimerStart()</code>函数被调用时算起。</p>\n</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878068181_kq43blmv75dwe00z.png\"></p>\n<p>例子2：守护任务的优先性级较高</p>\n<ul>\n<li><p>t1：Task1处于运行态，守护任务处于阻塞态。<br>守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。<br>至于守护任务能否马上执行，取决于它的优先级。</p>\n</li>\n<li><p>t2：Task1调用<code>xTimerStart()</code><br>要注意的是，<code>xTimerStart()</code>只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。<br>在本例中，守护任务的优先级高于Task1，所以守护任务抢占Task1，守护任务开始处理命令队列。<br>Task1在执行<code>xTimerStart()</code>的过程中被抢占，这时它无法完成此函数。</p>\n</li>\n<li><p>t3：守护任务处理完命令队列中所有的命令，再次进入阻塞态。<br>此时Task1是优先级最高的就绪态任务，它开始执行。</p>\n</li>\n<li><p>t4：Task1之前被守护任务抢占，对<code>xTimerStart()</code>的调用尚未返回。现在开始继续运行次函数、返回。</p>\n</li>\n<li><p>t5：Task1由于某些原因进入阻塞态，进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。</p>\n</li>\n</ul>\n<p><img src=\"/pic/chap10/05_demon_task_priority_higher.png\" alt=\"image-20210809161518141\"></p>\n<p>注意，定时器的超时时间是基于调用<code>xTimerStart()</code>的时刻tX，而不是基于守护任务处理命令的时刻tY。假设超时时间是10个Tick，超时时间是”tX+10”，而非”tY+10”。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>定时器的回调函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATimerCallback</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。</p>\n<p>所以，定时器的回调函数不要影响其他人：</p>\n<ul>\n<li><p>回调函数要尽快实行，不能进入阻塞状态</p>\n</li>\n<li><p>不要调用会导致阻塞的API函数，比如<code>vTaskDelay()</code></p>\n</li>\n<li><p>可以调用<code>xQueueReceive()</code>之类的函数，但是超时时间要设为0：即刻返回，不可阻塞</p>\n</li>\n</ul>\n<h3 id=\"软件定时器的函数\"><a href=\"#软件定时器的函数\" class=\"headerlink\" title=\"软件定时器的函数\"></a>软件定时器的函数</h3><p>根据定时器的状态转换图，就可以知道所涉及的函数：</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878093734_wd0b1lpwo1bkxt5n.png\"></p>\n<h4 id=\"创建-4\"><a href=\"#创建-4\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>要使用定时器，需要先创建它，得到它的句柄。</p>\n<p>有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 使用动态分配内存的方法创建定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class=\"line\"><span class=\"comment\"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class=\"line\"><span class=\"comment\"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxCallbackFunction: 回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TimerHandle_t <span class=\"title function_\">xTimerCreate</span><span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcTimerName, </span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t<span class=\"type\">const</span> TickType_t xTimerPeriodInTicks,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t<span class=\"type\">const</span> UBaseType_t uxAutoReload,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t<span class=\"type\">void</span> * <span class=\"type\">const</span> pvTimerID,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\tTimerCallbackFunction_t pxCallbackFunction )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用静态分配内存的方法创建定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class=\"line\"><span class=\"comment\"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class=\"line\"><span class=\"comment\"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxCallbackFunction: 回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TimerHandle_t <span class=\"title function_\">xTimerCreateStatic</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcTimerName,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTimerPeriodInTicks,</span></span><br><span class=\"line\"><span class=\"params\">                                 UBaseType_t uxAutoReload,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">void</span> * pvTimerID,</span></span><br><span class=\"line\"><span class=\"params\">                                 TimerCallbackFunction_t pxCallbackFunction,</span></span><br><span class=\"line\"><span class=\"params\">                                 StaticTimer_t *pxTimerBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>回调函数的类型是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATimerCallback</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">void</span> <span class=\"params\">(* TimerCallbackFunction_t)</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除-3\"><a href=\"#删除-3\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 删除定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 要删除哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerDelete</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>定时器的很多API函数，都是通过发送”命令”到命令队列，由守护任务来实现。</p>\n<p>如果队列满了，”命令”就无法即刻写入队列。我们可以指定一个超时时间<code>xTicksToWait</code>，等待一会。</p>\n<h4 id=\"启动-x2F-停止\"><a href=\"#启动-x2F-停止\" class=\"headerlink\" title=\"启动&#x2F;停止\"></a>启动&#x2F;停止</h4><p>启动定时器就是设置它的状态为运行态(Running、Active)。</p>\n<p>停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。</p>\n<p>涉及的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 启动定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStart</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 启动定时器(ISR版本)</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStartFromISR</span><span class=\"params\">(   TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 停止定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStop</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 停止定时器(ISR版本)</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStopFromISR</span><span class=\"params\">(    TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，这些函数的<code>xTicksToWait</code>表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。</p>\n<p><code>xTicksToWait</code>不是定时器本身的超时时间，不是定时器本身的”周期”。</p>\n<p>创建定时器时，设置了它的周期(period)。<code>xTimerStart()</code>函数是用来启动定时器。假设调用<code>xTimerStart()</code>的时刻是tX，定时器的周期是n，那么在<code>tX+n</code>时刻定时器的回调函数被调用。</p>\n<p>如果定时器已经被启动，但是它的函数尚未被执行，再次执行<code>xTimerStart()</code>函数相当于执行<code>xTimerReset()</code>，重新设定它的启动时间。</p>\n<h4 id=\"复位-1\"><a href=\"#复位-1\" class=\"headerlink\" title=\"复位\"></a>复位</h4><p>从定时器的状态转换图可以知道，使用<code>xTimerReset()</code>函数可以让定时器的状态从冬眠态转换为运行态，相当于使用<code>xTimerStart()</code>函数。</p>\n<p>如果定时器已经处于运行态，使用<code>xTimerReset()</code>函数就相当于重新确定超时时间。假设调用<code>xTimerReset()</code>的时刻是tX，定时器的周期是n，那么<code>tX+n</code>就是重新确定的超时时间。</p>\n<p>复位函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 复位定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerReset</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 复位定时器(ISR版本)</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerResetFromISR</span><span class=\"params\">(   TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"修改周期\"><a href=\"#修改周期\" class=\"headerlink\" title=\"修改周期\"></a>修改周期</h4><p>从定时器的状态转换图可以知道，使用<code>xTimerChangePeriod()</code>函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</p>\n<p>修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用<code>xTimerChangePeriod()</code>函数的时间tX，新的周期是n，则<code>tX+n</code>就是新的超时时间。</p>\n<p>相关函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 修改定时器的周期</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xNewPeriod: 新周期</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间, 命令写入队列的超时时间 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerChangePeriod</span><span class=\"params\">(   TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xNewPeriod,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 修改定时器的周期</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xNewPeriod: 新周期</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerChangePeriodFromISR</span><span class=\"params\">( TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                      TickType_t xNewPeriod,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"定时器ID\"><a href=\"#定时器ID\" class=\"headerlink\" title=\"定时器ID\"></a>定时器ID</h4><p>定时器的结构体如下，里面有一项<code>pvTimerID</code>，它就是定时器ID：</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878165302_vn9b11k5d1g8o3jb.png\"></p>\n<p>怎么使用定时器ID，完全由程序来决定：</p>\n<ul>\n<li>可以用来标记定时器，表示自己是什么定时器</li>\n<li>可以用来保存参数，给回调函数使用</li>\n</ul>\n<p>它的初始值在创建定时器时由<code>xTimerCreate()</code>这类函数传入，后续可以使用这些函数来操作：</p>\n<ul>\n<li>更新ID：使用<code>vTimerSetTimerID()</code>函数</li>\n<li>查询ID：查询<code>pvTimerGetTimerID()</code>函数</li>\n</ul>\n<p>这两个函数不涉及命令队列，它们是直接操作定时器结构体。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 获得定时器的ID</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 定时器的ID</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">pvTimerGetTimerID</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 设置定时器的ID</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pvNewID: 新ID</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 无</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTimerSetTimerID</span><span class=\"params\">( TimerHandle_t xTimer, <span class=\"type\">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"中断管理\"><a href=\"#中断管理\" class=\"headerlink\" title=\"中断管理\"></a>中断管理</h2><h3 id=\"两套API函数\"><a href=\"#两套API函数\" class=\"headerlink\" title=\"两套API函数\"></a>两套API函数</h3><h4 id=\"为什么需要两套API\"><a href=\"#为什么需要两套API\" class=\"headerlink\" title=\"为什么需要两套API\"></a>为什么需要两套API</h4><p>在任务函数中，我们可以调用各类API函数，比如队列操作函数：xQueueSendToBack。但是在ISR中使用这个函数会导致问题，应该使用另一个函数：xQueueSendToBackFromISR，它的函数名含有后缀”FromISR”，表示”从ISR中给队列发送数据”。</p>\n<p>FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名含有”FromISR”后缀。</p>\n<p>为什么要引入两套API函数？</p>\n<ul>\n<li>很多API函数会导致任务计入阻塞状态：<ul>\n<li>运行这个函数的<strong>任务</strong>进入阻塞状态</li>\n<li>比如写队列时，如果队列已满，可以进入阻塞状态等待一会</li>\n</ul>\n</li>\n<li>ISR调用API函数时，ISR不是”任务”，ISR不能进入阻塞状态</li>\n<li>所以，在任务中、在ISR中，这些函数的功能是有差别的</li>\n</ul>\n<p>为什么不使用同一套函数，比如在函数里面分辨当前调用者是任务还是ISR呢？示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(...)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_in_isr())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/* 把数据放入队列 */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/* 不管是否成功都直接返回 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">/* 在任务中 */</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/* 把数据放入队列 */</span></span><br><span class=\"line\">        <span class=\"comment\">/* 不成功就等待一会再重试 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FreeRTOS使用两套函数，而不是使用一套函数，是因为有如下好处：</p>\n<ul>\n<li><p>使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，是的函数更长、更复杂、难以测试</p>\n</li>\n<li><p>在任务、ISR中调用时，需要的参数不一样，比如：</p>\n<ul>\n<li>在任务中调用：需要指定超时时间，表示如果不成功就阻塞一会</li>\n<li>在ISR中调用：不需要指定超时时间，无论是否成功都要即刻返回</li>\n<li>如果强行把两套函数揉在一起，会导致参数臃肿、无效</li>\n</ul>\n</li>\n<li><p>移植FreeRTOS时，还需要提供监测上下文的函数，比如<code>is_in_isr()</code></p>\n</li>\n<li><p>有些处理器架构没有办法轻易分辨当前是处于任务中，还是处于ISR中，就需要额外添加更多、更复杂的代码</p>\n</li>\n</ul>\n<p>使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR总调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。这个问题可以解决：</p>\n<ul>\n<li>把中断的处理推迟到任务中进行(Defer interrupt  processing)，在任务中调用库函数</li>\n<li>尝试在库函数中使用”FromISR”函数：<ul>\n<li>在任务中、在ISR中都可以调用”FromISR”函数</li>\n<li>反过来就不行，非FromISR函数无法在ISR中使用</li>\n</ul>\n</li>\n<li>第三方库函数也许会提供OS抽象层，自行判断当前环境是在任务还是在ISR中，分别调用不同的函数</li>\n</ul>\n<h4 id=\"两套API函数列表\"><a href=\"#两套API函数列表\" class=\"headerlink\" title=\"两套API函数列表\"></a>两套API函数列表</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>在任务中</th>\n<th>在ISR中</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>队列(queue)</td>\n<td>xQueueSendToBack</td>\n<td>xQueueSendToBackFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueueSendToFront</td>\n<td>xQueueSendToFrontFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueueReceive</td>\n<td>xQueueReceiveFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueueOverwrite</td>\n<td>xQueueOverwriteFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueuePeek</td>\n<td>xQueuePeekFromISR</td>\n</tr>\n<tr>\n<td>信号量(semaphore)</td>\n<td>xSemaphoreGive</td>\n<td>xSemaphoreGiveFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xSemaphoreTake</td>\n<td>xSemaphoreTakeFromISR</td>\n</tr>\n<tr>\n<td>事件组(event group)</td>\n<td>xEventGroupSetBits</td>\n<td>xEventGroupSetBitsFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xEventGroupGetBits</td>\n<td>xEventGroupGetBitsFromISR</td>\n</tr>\n<tr>\n<td>任务通知(task notification)</td>\n<td>xTaskNotifyGive</td>\n<td>vTaskNotifyGiveFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTaskNotify</td>\n<td>xTaskNotifyFromISR</td>\n</tr>\n<tr>\n<td>软件定时器(software timer)</td>\n<td>xTimerStart</td>\n<td>xTimerStartFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTimerStop</td>\n<td>xTimerStopFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTimerReset</td>\n<td>xTimerResetFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTimerChangePeriod</td>\n<td>xTimerChangePeriodFromISR</td>\n</tr>\n</tbody></table>\n<h4 id=\"xHigherPriorityTaskWoken参数\"><a href=\"#xHigherPriorityTaskWoken参数\" class=\"headerlink\" title=\"xHigherPriorityTaskWoken参数\"></a>xHigherPriorityTaskWoken参数</h4><p>xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。</p>\n<p>还是以写队列为例。</p>\n<p>任务A调用<code>xQueueSendToBack()</code>写队列，有几种情况发生：</p>\n<ul>\n<li>队列满了，任务A阻塞等待，另一个任务B运行</li>\n<li>队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行</li>\n<li>队列没满，任务A成功写入队列，即刻返回</li>\n</ul>\n<p>可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做”context switch”，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。</p>\n<p><code>xQueueSendToBackFromISR()</code>函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBackFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 用法示例 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class=\"line\">xQueueSendToBackFromISR(xQueue, pvItemToQueue, &amp;xHigherPriorityTaskWoken);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 任务切换 */</span>    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换</p>\n<ul>\n<li>*pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换</li>\n<li>*pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要</li>\n</ul>\n<p>为什么不在”FromISR”函数内部进行任务切换，而只是标记一下而已呢？为了效率！示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XXX_ISR</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBackFromISR(...); <span class=\"comment\">/* 被多次调用 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ISR中有可能多次调用”FromISR”函数，如果在”FromISR”内部进行任务切换，会浪费时间。解决方法是：</p>\n<ul>\n<li>在”FromISR”中标记是否需要切换</li>\n<li>在ISR返回之前再进行任务切换</li>\n<li>示例代码如下</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XXX_ISR</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBackFromISR(..  &amp;xHigherPriorityTaskWoken); <span class=\"comment\">/* 被多次调用 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 最后再决定是否进行任务切换 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/* 任务切换 */</span>    </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。</p>\n<p>在ISR中调用API时不进行任务切换，而只是在”xHigherPriorityTaskWoken”中标记一下，除了效率，还有多种好处：</p>\n<ul>\n<li>效率高：避免不必要的任务切换</li>\n<li>让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂</li>\n<li>可移植性</li>\n<li>在Tick中断中，调用<code>vApplicationTickHook()</code>：它运行与ISR，只能使用”FromISR”的函数</li>\n</ul>\n<p>使用”FromISR”函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。</p>\n<h4 id=\"怎么切换任务\"><a href=\"#怎么切换任务\" class=\"headerlink\" title=\"怎么切换任务\"></a>怎么切换任务</h4><p>FreeRTOS的ISR函数中，使用两个宏进行任务切换：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );</span><br><span class=\"line\">或</span><br><span class=\"line\">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br></pre></td></tr></table></figure>\n\n<p>这两个宏做的事情是完全一样的，在老版本的FreeRTOS中，</p>\n<ul>\n<li><code>portEND_SWITCHING_ISR</code>使用汇编实现</li>\n<li><code>portYIELD_FROM_ISR</code>使用C语言实现</li>\n</ul>\n<p>新版本都统一使用<code>portYIELD_FROM_ISR</code>。</p>\n<p>使用示例如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XXX_ISR</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBackFromISR(..  &amp;xHigherPriorityTaskWoken); <span class=\"comment\">/* 被多次调用 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 最后再决定是否进行任务切换 </span></span><br><span class=\"line\"><span class=\"comment\">     * xHigherPriorityTaskWoken为pdTRUE时才切换</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"中断的延迟处理\"><a href=\"#中断的延迟处理\" class=\"headerlink\" title=\"中断的延迟处理\"></a>中断的延迟处理</h3><p>前面讲过，ISR要尽量快，否则：</p>\n<ul>\n<li>其他低优先级的中断无法被处理：实时性无法保证</li>\n<li>用户任务无法被执行：系统显得很卡顿 </li>\n<li>如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套</li>\n</ul>\n<p>如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：</p>\n<ul>\n<li>ISR：尽快做些清理、记录工作，然后触发某个任务</li>\n<li>任务：更复杂的事情放在任务中处理</li>\n</ul>\n<p>这种处理方式叫”中断的延迟处理”(Deferring interrupt processing)，处理流程如下图所示：</p>\n<ul>\n<li>t1：任务1运行，任务2阻塞</li>\n<li>t2：发生中断，<ul>\n<li>该中断的ISR函数被执行，任务1被打断</li>\n<li>ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2</li>\n</ul>\n</li>\n<li>t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为”deferred processing task”，中断的延迟处理任务。</li>\n<li>t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878428670_9qjlufv5a7dozv2z.png\"></p>\n<h3 id=\"中断与任务间的通信\"><a href=\"#中断与任务间的通信\" class=\"headerlink\" title=\"中断与任务间的通信\"></a>中断与任务间的通信</h3><p>前面讲解过的队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。</p>\n<p>要注意的是，在ISR中使用的函数要有”FromISR”后缀。</p>\n<h2 id=\"资源管理\"><a href=\"#资源管理\" class=\"headerlink\" title=\"资源管理\"></a>资源管理</h2><h3 id=\"屏蔽中断\"><a href=\"#屏蔽中断\" class=\"headerlink\" title=\"屏蔽中断\"></a>屏蔽中断</h3><p>屏蔽中断有两套宏：任务中使用、ISR中使用：</p>\n<ul>\n<li>任务中使用：<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code></li>\n<li>ISR中使用：<code>taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code></li>\n</ul>\n<h4 id=\"在任务中屏蔽中断\"><a href=\"#在任务中屏蔽中断\" class=\"headerlink\" title=\"在任务中屏蔽中断\"></a>在任务中屏蔽中断</h4><p>在任务中屏蔽中断的示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在任务中，当前时刻中断是使能的</span></span><br><span class=\"line\"><span class=\"comment\"> * 执行这句代码后，屏蔽中断</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">taskENTER_CRITICAL();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 访问临界资源 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 重新使能中断 */</span></span><br><span class=\"line\">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure>\n\n<p>在<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>之间：</p>\n<ul>\n<li>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></li>\n<li>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code><ul>\n<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>\n</ul>\n</li>\n<li>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</li>\n</ul>\n<p>这套<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用<code>taskEXIT_CRITICAL()</code>才会重新使能中断。</p>\n<p>使用<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>来访问临界资源是很粗鲁的方法：</p>\n<ul>\n<li>中断无法正常运行</li>\n<li>任务调度无法进行</li>\n<li>所以，之间的代码要尽可能快速地执行</li>\n</ul>\n<h4 id=\"在ISR中屏蔽中断\"><a href=\"#在ISR中屏蔽中断\" class=\"headerlink\" title=\"在ISR中屏蔽中断\"></a>在ISR中屏蔽中断</h4><p>要使用含有”FROM_ISR”后缀的宏，示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vAnInterruptServiceRoutine</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ## 用来记录当前中断是否使能 */</span><br><span class=\"line\">    UBaseType_t uxSavedInterruptStatus;</span><br><span class=\"line\">    </span><br><span class=\"line\">  ## 在ISR中，当前时刻中断可能是使能的，也可能是禁止的</span><br><span class=\"line\">## * 所以要记录当前状态, 后面要恢复为原先的状态</span><br><span class=\"line\">## * 执行这句代码后，屏蔽中断</span><br><span class=\"line\">## */</span><br><span class=\"line\">    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class=\"line\">    </span><br><span class=\"line\">  ## 访问临界资源 */</span><br><span class=\"line\"></span><br><span class=\"line\">  ## 恢复中断状态 */</span><br><span class=\"line\">    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br><span class=\"line\">  ## 现在，当前ISR可以被更高优先级的中断打断了 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在<code>taskENTER_CRITICA_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code>之间：</p>\n<ul>\n<li>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></li>\n<li>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code><ul>\n<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>\n</ul>\n</li>\n<li>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</li>\n</ul>\n<h1 id=\"暂停调度器\"><a href=\"#暂停调度器\" class=\"headerlink\" title=\"暂停调度器\"></a>暂停调度器</h1><p>如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。</p>\n<p>如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。</p>\n<p>使用这2个函数来暂停、恢复调度器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 暂停调度器 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskSuspendAll</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 恢复调度器</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了</span></span><br><span class=\"line\"><span class=\"comment\"> *##    可以不理会这个返回值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskResumeAll</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vTaskSuspendScheduler();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 访问临界资源 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">xTaskResumeScheduler();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这套<code>vTaskSuspendScheduler()/xTaskResumeScheduler()</code>宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用<code>taskEXIT_CRITICAL()</code>才会重新使能中断。</p>\n<p><a href=\"http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/index.html\">参考原文地址</a></p>\n","more":"<blockquote>\n<p>大部分内容都为摘抄<br>其实已经看过很多遍，但一直没用过。</p>\n</blockquote>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p>\n<h3 id=\"FreeRTOS的5种内存管理方法\"><a href=\"#FreeRTOS的5种内存管理方法\" class=\"headerlink\" title=\"FreeRTOS的5种内存管理方法\"></a>FreeRTOS的5种内存管理方法</h3><table>\n<thead>\n<tr>\n<th>文件</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>heap_1.c</td>\n<td>分配简单，时间确定</td>\n<td>只分配、不回收</td>\n</tr>\n<tr>\n<td>heap_2.c</td>\n<td>动态分配、最佳匹配</td>\n<td>碎片、时间不定</td>\n</tr>\n<tr>\n<td>heap_3.c</td>\n<td>调用标准库函数</td>\n<td>速度慢、时间不定</td>\n</tr>\n<tr>\n<td>heap_4.c</td>\n<td>相邻空闲内存可合并</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n<tr>\n<td>heap_5.c</td>\n<td>在heap_4基础上支持分隔的内存块</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n</tbody></table>\n<h4 id=\"heap-1-c\"><a href=\"#heap-1-c\" class=\"headerlink\" title=\"heap_1.c\"></a>heap_1.c</h4><ul>\n<li><p>实现最简单</p>\n</li>\n<li><p>没有碎片问题</p>\n</li>\n<li><p>一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1</p>\n</li>\n</ul>\n<h4 id=\"heap-2-c-弃用\"><a href=\"#heap-2-c-弃用\" class=\"headerlink\" title=\"heap_2.c 弃用\"></a>heap_2.c 弃用</h4><p>Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。</p>\n<h4 id=\"heap-3-c\"><a href=\"#heap-3-c\" class=\"headerlink\" title=\"heap_3.c\"></a>heap_3.c</h4><p>Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。</p>\n<p>C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。</p>\n<h4 id=\"heap-4-c\"><a href=\"#heap-4-c\" class=\"headerlink\" title=\"heap_4.c\"></a>heap_4.c</h4><p>跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。</p>\n<p>Heap_4使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p>\n<h4 id=\"heap-5-c\"><a href=\"#heap-5-c\" class=\"headerlink\" title=\"heap_5.c\"></a>heap_5.c</h4><p>Heap_5分配内存、释放内存的算法跟Heap_4是一样的。</p>\n<p>相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</p>\n<p>在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。</p>\n<p>既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：</p>\n<p>在使用pvPortMalloc之前，必须先指定内存块的信息</p>\n<p>使用vPortDefineHeapRegions来指定这些信息</p>\n<h3 id=\"Heap相关的函数\"><a href=\"#Heap相关的函数\" class=\"headerlink\" title=\"Heap相关的函数\"></a>Heap相关的函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n</table>\n<p>void *pvPortMalloc( size_t xWantedSize ) | 分配内存<br>void vPortFree( void *pv ) | 释放内存<br>size_t xPortGetFreeHeapSize( void ) | 获取剩余内存<br>size_t xPortGetMinimumEverFreeHeapSize( void ) | 获取最小剩余内存</p>\n<p>malloc失败的钩子函数</p>\n<p>在pvPortMalloc函数内部</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xWantedSize )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( pvReturn == <span class=\"literal\">NULL</span> )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">vApplicationMallocFailedHook</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\">                vApplicationMallocFailedHook();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pvReturn;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，如果想使用这个钩子函数：</p>\n<p>在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1</p>\n<p>提供vApplicationMallocFailedHook函数</p>\n<p>pvPortMalloc失败时，才会调用此函数</p>\n<h2 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h2><p>在FreeRTOS中，任务就是一个函数，原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是：</p>\n<ul>\n<li>这个函数不能返回</li>\n<li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li>\n<li>函数内部，尽量使用局部变量：<ul>\n<li>每个任务都有自己的栈</li>\n<li>每个任务运行这个函数时<ul>\n<li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li>\n<li>不同任务的局部变量，有自己的副本</li>\n</ul>\n</li>\n<li>函数使用全局变量、静态变量的话<ul>\n<li>只有一个副本：多个任务使用的是同一个副本</li>\n<li>要防止冲突(后续会讲)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><p>创建任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>函数指针，可以简单地认为任务就是一个C函数。<br />它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td>\n</tr>\n<tr>\n<td>pcName</td>\n<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。<br />长度为：configMAX_TASK_NAME_LEN</td>\n</tr>\n<tr>\n<td>usStackDepth</td>\n<td>每个任务都有自己的栈，这里指定栈大小。<br />单位是word，比如传入100，表示栈大小为100 word，也就是400字节。<br />最大值为uint16_t的最大值。<br />怎么确定栈的大小，并不容易，很多时候是估计。<br />精确的办法是看反汇编码。</td>\n</tr>\n<tr>\n<td>pvParameters</td>\n<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>\n</tr>\n<tr>\n<td>uxPriority</td>\n<td>优先级范围：0~(configMAX_PRIORITIES – 1)<br />数值越小优先级越低，<br />如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td>\n</tr>\n<tr>\n<td>pxCreatedTask</td>\n<td>用来保存xTaskCreate的输出结果：task handle。<br />以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。<br />如果不想使用该handle，可以传入NULL。</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>成功：pdPASS；<br />失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)<br />注意：文档里都说失败时返回值是pdFAIL，这不对。<br />pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。</td>\n</tr>\n</tbody></table>\n<h3 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h3><p>删除任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。<br />也可传入NULL，这表示删除自己。</td>\n</tr>\n</tbody></table>\n<p>怎么删除任务？举个不好的例子：</p>\n<ul>\n<li>自杀：<code>vTaskDelete(NULL)</code></li>\n<li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是自己的句柄</li>\n<li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是别的任务的句柄</li>\n</ul>\n<h3 id=\"任务优先级和Tick\"><a href=\"#任务优先级和Tick\" class=\"headerlink\" title=\"任务优先级和Tick\"></a>任务优先级和Tick</h3><h4 id=\"任务优先级\"><a href=\"#任务优先级\" class=\"headerlink\" title=\"任务优先级\"></a>任务优先级</h4><p>在上个示例中我们体验过优先级的使用：高优先级的任务先运行。</p>\n<p>优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。</p>\n<p>FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。</p>\n<ul>\n<li>通用方法<br>使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。<br>configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。</li>\n<li>架构相关的优化的方法<br>架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。<br>使用这种方法时，configMAX_PRIORITIES的取值不能超过32。<br>configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。</li>\n</ul>\n<p>在学习调度方法之前，你只要初略地知道：</p>\n<ul>\n<li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li>\n<li>对于相同优先级的、可运行的任务，轮流执行</li>\n</ul>\n<p>这无需记忆，就像我们举的例子：</p>\n<ul>\n<li>厨房着火了，当然优先灭火</li>\n<li>喂饭、回复信息同样重要，轮流做</li>\n</ul>\n<h4 id=\"Tick\"><a href=\"#Tick\" class=\"headerlink\" title=\"Tick\"></a>Tick</h4><p>对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。</p>\n<h3 id=\"任务状态\"><a href=\"#任务状态\" class=\"headerlink\" title=\"任务状态\"></a>任务状态</h3><p>以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。</p>\n<p>对于非运行的状态，还可以继续细分，比如前面的<code>FreeRTOS_04_task_priority</code>中：</p>\n<ul>\n<li>Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行</li>\n<li>Task3运行期间，Task1、Task2也处于非运行状态，但是它们<strong>随时可以运行</strong></li>\n<li>这两种”非运行”状态就不一样，可以细分为：<ul>\n<li>阻塞状态(Blocked)</li>\n<li>暂停状态(Suspended)</li>\n<li>就绪状态(Ready)</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673868627091_5gu53zc58zp8f24k.png\"></p>\n<h3 id=\"Delay函数\"><a href=\"#Delay函数\" class=\"headerlink\" title=\"Delay函数\"></a>Delay函数</h3><p>有两个Delay函数：</p>\n<ul>\n<li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li>\n<li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。</li>\n</ul>\n<h3 id=\"空闲任务及其钩子函数\"><a href=\"#空闲任务及其钩子函数\" class=\"headerlink\" title=\"空闲任务及其钩子函数\"></a>空闲任务及其钩子函数</h3><p>为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用vTaskStartScheduler() 函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p>\n<p>空闲任务优先级为0：它不能阻碍用户任务运行</p>\n<p>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</p>\n<p>空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。</p>\n<p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p>\n<p>执行一些低优先级的、后台的、需要连续执行的函数</p>\n<p>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</p>\n<p>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</p>\n<p>空闲任务的钩子函数的限制：</p>\n<p>不能导致空闲任务进入阻塞状态、暂停状态</p>\n<p>如果你会使用vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</p>\n<h3 id=\"调度算法\"><a href=\"#调度算法\" class=\"headerlink\" title=\"调度算法\"></a>调度算法</h3><table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n<th>D</th>\n<th>E</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>configUSE_PREEMPTION</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>configUSE_TIME_SLICING</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>x</td>\n</tr>\n<tr>\n<td>configIDLE_SHOULD_YIELD</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>x</td>\n</tr>\n<tr>\n<td>说明</td>\n<td>常用</td>\n<td>很少用</td>\n<td>很少用</td>\n<td>很少用</td>\n<td>几乎不用</td>\n</tr>\n</tbody></table>\n<p>注：</p>\n<ul>\n<li><p>A：可抢占+时间片轮转+空闲任务让步</p>\n</li>\n<li><p>B：可抢占+时间片轮转+空闲任务不让步</p>\n</li>\n<li><p>C：可抢占+非时间片轮转+空闲任务让步</p>\n</li>\n<li><p>D：可抢占+非时间片轮转+空闲任务不让步</p>\n</li>\n<li><p>E：合作调度</p>\n</li>\n</ul>\n<h2 id=\"同步互斥与通信\"><a href=\"#同步互斥与通信\" class=\"headerlink\" title=\"同步互斥与通信\"></a>同步互斥与通信</h2><p>队列：</p>\n<p>里面可以放任意数据，可以放多个数据</p>\n<p>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</p>\n<p>事件组：</p>\n<p>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</p>\n<p>可以用来表示事件、事件的组合发生了，不能传递数据</p>\n<p>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</p>\n<p>信号量：</p>\n<p>核心是”计数值”</p>\n<p>任务、ISR释放信号量时让计数值加1</p>\n<p>任务、ISR获得信号量时，让计数值减1</p>\n<p>任务通知：</p>\n<p>核心是任务的TCB里的数值</p>\n<p>会被覆盖</p>\n<p>发通知给谁？必须指定接收任务</p>\n<p>只能由接收任务本身获取该通知</p>\n<p>互斥量：</p>\n<p>数值只有0或1</p>\n<p>谁获得互斥量，就必须由谁释放同一个互斥量</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列(queue)可以用于”任务到任务”、”任务到中断”、”中断到任务”直接传输信息。</p>\n<ul>\n<li><p>队列可以包含若干个数据：队列中有若干项，这被称为”长度”(length)</p>\n</li>\n<li><p>每个数据大小固定</p>\n</li>\n<li><p>创建队列时就要指定长度、数据大小</p>\n</li>\n<li><p>数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读</p>\n</li>\n<li><p>也可以强制写队列头部：覆盖头部数据</p>\n</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673876690909_b8vj0bypy78dmygf.png\"></p>\n<h3 id=\"队列的特性\"><a href=\"#队列的特性\" class=\"headerlink\" title=\"队列的特性\"></a>队列的特性</h3><h4 id=\"传输数据的两种方法\"><a href=\"#传输数据的两种方法\" class=\"headerlink\" title=\"传输数据的两种方法\"></a>传输数据的两种方法</h4><p>FreeRTOS使用拷贝值的方法，这更简单：</p>\n<ul>\n<li><p>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</p>\n</li>\n<li><p>无需分配buffer来保存数据，队列中有buffer</p>\n</li>\n<li><p>局部变量可以马上再次使用</p>\n</li>\n<li><p>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</p>\n</li>\n<li><p>如果数据实在太大，你还是可以使用队列传输它的地址</p>\n</li>\n<li><p>队列的空间有FreeRTOS内核分配，无需任务操心</p>\n</li>\n<li><p>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</p>\n</li>\n</ul>\n<h4 id=\"队列阻塞访问\"><a href=\"#队列阻塞访问\" class=\"headerlink\" title=\"队列阻塞访问\"></a>队列阻塞访问</h4><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p>\n<p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p>\n<p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p>\n<p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p>\n<p>优先级最高的任务</p>\n<p>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</p>\n<p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p>\n<p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p>\n<p>优先级最高的任务</p>\n<p>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</p>\n<h3 id=\"队列函数\"><a href=\"#队列函数\" class=\"headerlink\" title=\"队列函数\"></a>队列函数</h3><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p>\n<ul>\n<li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreate</span><span class=\"params\">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>uxQueueLength</td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td>uxItemSize</td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列<br />NULL：失败，因为内存不足</td>\n</tr>\n</tbody></table>\n<ul>\n<li>静态分配内存：xQueueCreateStatic，队列的内存要事先分配好</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreateStatic</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           UBaseType_t uxQueueLength,</span></span><br><span class=\"line\"><span class=\"params\">                           UBaseType_t uxItemSize,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">uint8_t</span> *pucQueueStorageBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                           StaticQueue_t *pxQueueBuffer</span></span><br><span class=\"line\"><span class=\"params\">                       )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>uxQueueLength</td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td>uxItemSize</td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr>\n<td>pucQueueStorageBuffer</td>\n<td>如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组，<br />此数组大小至少为”uxQueueLength * uxItemSize”</td>\n</tr>\n<tr>\n<td>pxQueueBuffer</td>\n<td>必须执行一个StaticQueue_t结构体，用来保存队列的数据结构</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列<br />NULL：失败，因为pxQueueBuffer为NULL</td>\n</tr>\n</tbody></table>\n<p>示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> QUEUE_LENGTH 10</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// xQueueBuffer用来保存队列结构体</span></span><br><span class=\"line\"> StaticQueue_t xQueueBuffer;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// ucQueueStorage 用来保存队列的数据</span></span><br><span class=\"line\"> <span class=\"comment\">// 大小为：队列长度 * 数据大小</span></span><br><span class=\"line\"> <span class=\"type\">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">vATask</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\tQueueHandle_t xQueue1;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span></span><br><span class=\"line\">\txQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class=\"line\">\t\t\t\t\t\t  ITEM_SIZE,</span><br><span class=\"line\">\t\t\t\t\t\t  ucQueueStorage,</span><br><span class=\"line\">\t\t\t\t\t\t  &amp;xQueueBuffer ); </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"复位\"><a href=\"#复位\" class=\"headerlink\" title=\"复位\"></a>复位</h4><p>队列刚被创建时，里面没有数据；使用过程中可以调用<code>xQueueReset()</code>把队列恢复为初始状态，此函数原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pxQueue : 复位哪个队列;</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS(必定成功)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReset</span><span class=\"params\">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>删除队列的函数为<code>vQueueDelete()</code>，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vQueueDelete</span><span class=\"params\">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"写队列\"><a href=\"#写队列\" class=\"headerlink\" title=\"写队列\"></a>写队列</h4><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 等同于xQueueSendToBack</span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBack</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBackFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToFront</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToFrontFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这些函数用到的参数是类似的，统一说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueue</td>\n<td>队列句柄，要写哪个队列</td>\n</tr>\n<tr>\n<td>pvItemToQueue</td>\n<td>数据指针，这个数据的值会被复制进队列，<br />复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态，<br />xTicksToWait表示阻塞的最大时间(Tick Count)。<br />如果被设为0，无法写入数据时函数会立刻返回；<br />如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：数据成功写入了队列<br />errQUEUE_FULL：写入失败，因为队列满了。</td>\n</tr>\n</tbody></table>\n<h4 id=\"读队列\"><a href=\"#读队列\" class=\"headerlink\" title=\"读队列\"></a>读队列</h4><p>使用<code>xQueueReceive()</code>函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceive</span><span class=\"params\">( QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                    QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">void</span>             *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                                    BaseType_t       *pxTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueue</td>\n<td>队列句柄，要读哪个队列</td>\n</tr>\n<tr>\n<td>pvBuffer</td>\n<td>bufer指针，队列的数据会被复制到这个buffer<br />复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>果队列空则无法读出数据，可以让任务进入阻塞状态，<br />xTicksToWait表示阻塞的最大时间(Tick Count)。<br />如果被设为0，无法读出数据时函数会立刻返回；<br />如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：从队列读出数据入<br />errQUEUE_EMPTY：读取失败，因为队列空了。</td>\n</tr>\n</tbody></table>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用数据的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueMessagesWaiting</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用空间的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueSpacesAvailable</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"覆盖-x2F-偷看\"><a href=\"#覆盖-x2F-偷看\" class=\"headerlink\" title=\"覆盖&#x2F;偷看\"></a>覆盖&#x2F;偷看</h4><p>当队列长度为1时，可以使用<code>xQueueOverwrite()</code>或<code>xQueueOverwriteFromISR()</code>来覆盖数据。<br>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。<br>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 覆盖队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 写哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwrite</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwriteFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是<code>xQueuePeek()</code>或<code>xQueuePeekFromISR()</code>。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。<br>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 偷看队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 偷看哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeek</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                          QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeekFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                 QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">void</span> *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                             )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。</p>\n<p>有时候我们只需要传递状态，并不需要传递具体的信息，比如：</p>\n<p>我的事做完了，通知一下你</p>\n<p>卖包子了、卖包子了，做好了1个包子！做好了2个包子！做好了3个包子！</p>\n<p>这个停车位我占了，你们只能等着</p>\n<p>在这种情况下我们可以使用信号量(semaphore)，它更节省内存。</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877102733_in4bdyrchoqtnblc.png\"></p>\n<h3 id=\"信号量的常规操作\"><a href=\"#信号量的常规操作\" class=\"headerlink\" title=\"信号量的常规操作\"></a>信号量的常规操作</h3><h4 id=\"两种信号量的对比\"><a href=\"#两种信号量的对比\" class=\"headerlink\" title=\"两种信号量的对比\"></a>两种信号量的对比</h4><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p>\n<p>差别列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>二进制信号量</th>\n<th>技术型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>被创建时初始值为0</td>\n<td>被创建时初始值可以设定</td>\n</tr>\n<tr>\n<td>其他操作是一样的</td>\n<td>其他操作是一样的</td>\n</tr>\n</tbody></table>\n<h3 id=\"信号量函数\"><a href=\"#信号量函数\" class=\"headerlink\" title=\"信号量函数\"></a>信号量函数</h3><h4 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。</p>\n<p>对于二进制信号量、计数型信号量，它们的创建函数不一样：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>二进制信号量</th>\n<th>计数型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>动态创建</td>\n<td>xSemaphoreCreateBinary<br />计数值初始值为0</td>\n<td>xSemaphoreCreateCounting</td>\n</tr>\n<tr>\n<td></td>\n<td>vSemaphoreCreateBinary(过时了)<br />计数值初始值为1</td>\n<td></td>\n</tr>\n<tr>\n<td>静态创建</td>\n<td>xSemaphoreCreateBinaryStatic</td>\n<td>xSemaphoreCreateCountingStatic</td>\n</tr>\n</tbody></table>\n<p>创建二进制信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinary</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinaryStatic</span><span class=\"params\">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>创建计数型信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCounting</span><span class=\"params\">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCountingStatic</span><span class=\"params\">( UBaseType_t uxMaxCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 UBaseType_t uxInitialCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p>\n<p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"give-x2F-take\"><a href=\"#give-x2F-take\" class=\"headerlink\" title=\"give&#x2F;take\"></a>give&#x2F;take</h4><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>在任务中使用</th>\n<th>在ISR中使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>give</td>\n<td>xSemaphoreGive</td>\n<td>xSemaphoreGiveFromISR</td>\n</tr>\n<tr>\n<td>take</td>\n<td>xSemaphoreTake</td>\n<td>xSemaphoreTakeFromISR</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreGive的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGive函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功,<br />如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；<br />如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>pxHigherPriorityTaskWoken的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>如果释放信号量导致更高优先级的任务变为了就绪态，<br />则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功,<br />如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；<br />如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTake的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                   TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">               )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTake函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果无法马上获得信号量，阻塞一会：<br />0：不阻塞，马上返回<br />portMAX_DELAY: 一直阻塞直到成功<br />其他值: 阻塞的Tick个数，可以使用<code>pdMS_TO_TICKS()</code>来指定阻塞时间为若干ms</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTakeFromISR的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTakeFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>如果获取信号量导致更高优先级的任务变为了就绪态，<br />则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<h2 id=\"互斥量\"><a href=\"#互斥量\" class=\"headerlink\" title=\"互斥量\"></a>互斥量</h2><p>在多任务系统中，任务A正在使用某个资源，还没用完的情况下任务B也来使用的话，就可能导致问题。</p>\n<p>比如对于串口，任务A正使用它来打印，在打印过程中任务B也来打印，客户看到的结果就是A、B的信息混杂在一起。</p>\n<p>上述问题的解决方法是：任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。</p>\n<p>互斥量也被称为互斥锁，使用过程如下：</p>\n<p>互斥量初始值为1</p>\n<p>任务A想访问临界资源，先获得并占有互斥量，然后开始访问</p>\n<p>任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞</p>\n<p>任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源</p>\n<p>任务B使用完毕，释放互斥量</p>\n<p>正常来说：在任务A占有互斥量的过程中，任务B、任务C等等，都无法释放互斥量。</p>\n<p>但是FreeRTOS未实现这点：任务A占有互斥量的情况下，任务B也可释放互斥量。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>互斥量是一种特殊的二进制信号量。</p>\n<p>使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。</p>\n<p>创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配互斥量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateMutex</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateMutexStatic</span><span class=\"params\">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> configUSE_MUTEXES 1</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h4><p>要注意的是，互斥量不能在ISR中使用。</p>\n<p>各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 释放 */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 释放(ISR版本) */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                       SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                       BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 获得 */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                   TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">               )</span>;</span><br><span class=\"line\"><span class=\"comment\">/* 获得(ISR版本) */</span></span><br><span class=\"line\">xSemaphoreGiveFromISR(</span><br><span class=\"line\">                       SemaphoreHandle_t xSemaphore,</span><br><span class=\"line\">                       BaseType_t *pxHigherPriorityTaskWoken</span><br><span class=\"line\">                   );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h2><p>事件组可以简单地认为就是一个整数：</p>\n<ul>\n<li>每一位表示一个事件</li>\n<li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li>\n<li>这些位，值为1表示事件发生了，值为0表示事件没发生</li>\n<li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li>\n<li>可以等待某一位、某些位中的任意一个，也可以等待多位</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877501635_dwoab2ksj0cey9be.png\"></p>\n<p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p>\n<ul>\n<li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li>\n<li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li>\n<li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul>\n<li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li>\n<li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件组的操作\"><a href=\"#事件组的操作\" class=\"headerlink\" title=\"事件组的操作\"></a>事件组的操作</h3><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p>\n<ul>\n<li>唤醒谁？<ul>\n<li>队列、信号量：事件发生时，只会唤醒一个任务</li>\n<li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li>\n</ul>\n</li>\n<li>是否清除事件？<ul>\n<li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li>\n<li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li>\n</ul>\n</li>\n</ul>\n<p>以上图为列，事件组的常规操作如下：</p>\n<ul>\n<li><p>先创建事件组</p>\n</li>\n<li><p>任务C、D等待事件：</p>\n<ul>\n<li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li>\n<li>得到事件时，要不要清除？可选择清除、不清除。</li>\n</ul>\n</li>\n<li><p>任务A、B产生事件：设置事件组里的某一位、某些位</p>\n</li>\n</ul>\n<h3 id=\"事件组函数\"><a href=\"#事件组函数\" class=\"headerlink\" title=\"事件组函数\"></a>事件组函数</h3><h4 id=\"创建-3\"><a href=\"#创建-3\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p>\n<p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配事件组结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreate</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreateStatic</span><span class=\"params\">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除-2\"><a href=\"#删除-2\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p>\n<p>vEventGroupDelete可以用来删除事件组，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vEventGroupDelete</span><span class=\"params\">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"设置事件\"><a href=\"#设置事件\" class=\"headerlink\" title=\"设置事件\"></a>设置事件</h4><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p>\n<ul>\n<li>在任务中使用<code>xEventGroupSetBits()</code></li>\n<li>在ISR中使用<code>xEventGroupSetBitsFromISR()</code></li>\n</ul>\n<p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSetBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xEventGroupSetBitsFromISR</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  <span class=\"type\">const</span> EventBits_t uxBitsToSet,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>值得注意的是，ISR中的函数，比如队列函数<code>xQueueSendToBackFromISR</code>、信号量函数<code>xSemaphoreGiveFromISR</code>，它们会唤醒某个任务，最多只会唤醒1个任务。</p>\n<p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<code>xEventGroupSetBitsFromISR</code>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>\n<p>如果后台任务的优先级比当前被中断的任务优先级高，<code>xEventGroupSetBitsFromISR</code>会设置<code>*pxHigherPriorityTaskWoken</code>为pdTRUE。</p>\n<p>如果daemon task成功地把队列数据发送给了后台任务，那么<code>xEventGroupSetBitsFromISR</code>的返回值就是pdPASS。</p>\n<h4 id=\"等待事件\"><a href=\"#等待事件\" class=\"headerlink\" title=\"等待事件\"></a>等待事件</h4><p>使用<code>xEventGroupWaitBits</code>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupWaitBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p>\n<p>函数参数说明列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xEventGroup</td>\n<td>等待哪个事件组？</td>\n</tr>\n<tr>\n<td>uxBitsToWaitFor</td>\n<td>等待哪些位？哪些位要被测试？</td>\n</tr>\n<tr>\n<td>xWaitForAllBits</td>\n<td>怎么测试？是”AND”还是”OR”？<br />pdTRUE: 等待的位，全部为1;<br />pdFALSE: 等待的位，某一个为1即可</td>\n</tr>\n<tr>\n<td>xClearOnExit</td>\n<td>函数提出前是否要清除事件？<br />pdTRUE: 清除uxBitsToWaitFor指定的位<br />pdFALSE: 不清除</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果期待的事件未发生，阻塞多久。<br />可以设置为0：判断后即刻返回；<br />可设置为portMAX_DELAY：一定等到成功才返回；<br />可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>返回的是事件值，<br />如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br />如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<p>举例如下：</p>\n<table>\n<thead>\n<tr>\n<th>事件组的值</th>\n<th>uxBitsToWaitFor</th>\n<th>xWaitForAllBits</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0100</td>\n<td>0101</td>\n<td>pdTRUE</td>\n<td>任务期望bit0,bit2都为1，<br />当前值只有bit2满足，任务进入阻塞态；<br />当事件组中bit0,bit2都为1时退出阻塞态</td>\n</tr>\n<tr>\n<td>0100</td>\n<td>0110</td>\n<td>pdFALSE</td>\n<td>任务期望bit0,bit2某一个为1，<br />当前值满足，所以任务成功退出</td>\n</tr>\n<tr>\n<td>0100</td>\n<td>0110</td>\n<td>pdTRUE</td>\n<td>任务期望bit1,bit2都为1，<br />当前值不满足，任务进入阻塞态；<br />当事件组中bit1,bit2都为1时退出阻塞态</td>\n</tr>\n</tbody></table>\n<p>你可以使用<code>xEventGroupWaitBits()</code>等待期望的事件，它发生之后再使用<code>xEventGroupClearBits()</code>来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p>\n<p>可以使用设置<code>xClearOnExit</code>为pdTRUE，使得对事件组的测试、清零都在<code>xEventGroupWaitBits()</code>函数内部完成，这是一个原子操作。</p>\n<h4 id=\"同步点\"><a href=\"#同步点\" class=\"headerlink\" title=\"同步点\"></a>同步点</h4><p>有一个事情需要多个任务协同，比如：</p>\n<ul>\n<li>任务A：炒菜</li>\n<li>任务B：买酒</li>\n<li>任务C：摆台</li>\n<li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li>\n</ul>\n<p>使用<code>xEventGroupSync()</code>函数可以同步多个任务：</p>\n<ul>\n<li>可以设置某位、某些位，表示自己做了什么事</li>\n<li>可以等待某位、某些位，表示要等等其他任务</li>\n<li>期望的时间发生后，<code>xEventGroupSync()</code>才会成功返回。</li>\n<li><code>xEventGroupSync</code>成功返回后，会清除事件</li>\n</ul>\n<p><code>xEventGroupSync</code>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSync</span><span class=\"params\">(    EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> EventBits_t uxBitsToSet,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xEventGroup</td>\n<td>哪个事件组？</td>\n</tr>\n<tr>\n<td>uxBitsToSet</td>\n<td>要设置哪些事件？我完成了哪些事件？<br />比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>\n</tr>\n<tr>\n<td>uxBitsToWaitFor</td>\n<td>等待那个位、哪些位？<br />比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果期待的事件未发生，阻塞多久。<br />可以设置为0：判断后即刻返回；<br />可设置为portMAX_DELAY：一定等到成功才返回；<br />可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>返回的是事件值，<br />如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br />如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<h2 id=\"任务通知\"><a href=\"#任务通知\" class=\"headerlink\" title=\"任务通知\"></a>任务通知</h2><p>所谓”任务通知”，你可以反过来读”通知任务”。</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877706072_dh293c8je2izndds.png\"></p>\n<p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p>\n<h3 id=\"优势及限制\"><a href=\"#优势及限制\" class=\"headerlink\" title=\"优势及限制\"></a>优势及限制</h3><p>任务通知的优势：</p>\n<ul>\n<li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li>\n<li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>\n</ul>\n<p>任务通知的限制：</p>\n<ul>\n<li>不能发送数据给ISR：<br>ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li>\n<li>数据只能给该任务独享<br>使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。<br>在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li>\n<li>无法缓冲数据<br>使用队列时，假设队列深度为N，那么它可以保持N个数据。<br>使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li>\n<li>无法广播给多个任务<br>使用事件组可以同时给多个任务发送事件。<br>使用任务通知，只能发个一个任务。</li>\n<li>如果发送受阻，发送方无法进入阻塞状态等待<br>假设队列已经满了，使用<code>xQueueSendToBack()</code>给队列发送数据时，任务可以进入阻塞状态等待发送完成。<br>使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li>\n</ul>\n<h3 id=\"通知状态和通知值\"><a href=\"#通知状态和通知值\" class=\"headerlink\" title=\"通知状态和通知值\"></a>通知状态和通知值</h3><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：</p>\n<ul>\n<li>一个是uint8_t类型，用来表示通知状态</li>\n<li>一个是uint32_t类型，用来表示通知值</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tskTaskControlBlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125; tskTCB;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通知状态有3种取值：</p>\n<ul>\n<li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li>\n<li>taskWAITING_NOTIFICATION：任务在等待通知</li>\n<li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class=\"comment\">/* 也是初始状态 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通知值可以有很多种类型：</p>\n<ul>\n<li>计数值</li>\n<li>位(类似事件组)</li>\n<li>任意数值</li>\n</ul>\n<h3 id=\"任务通知的使用\"><a href=\"#任务通知的使用\" class=\"headerlink\" title=\"任务通知的使用\"></a>任务通知的使用</h3><p>使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p>\n<h4 id=\"两类函数\"><a href=\"#两类函数\" class=\"headerlink\" title=\"两类函数\"></a>两类函数</h4><p>任务通知有2套函数，简化版、专业版，列表如下：</p>\n<ul>\n<li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li>\n<li>专业版函数支持很多参数，可以实现很多功能</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>简化版</th>\n<th>专业版</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>发出通知</td>\n<td>xTaskNotifyGive<br />vTaskNotifyGiveFromISR</td>\n<td>xTaskNotify<br />xTaskNotifyFromISR</td>\n</tr>\n<tr>\n<td>取出通知</td>\n<td>ulTaskNotifyTake</td>\n<td>xTaskNotifyWait</td>\n</tr>\n</tbody></table>\n<h4 id=\"xTaskNotifyGive-x2F-ulTaskNotifyTake\"><a href=\"#xTaskNotifyGive-x2F-ulTaskNotifyTake\" class=\"headerlink\" title=\"xTaskNotifyGive&#x2F;ulTaskNotifyTake\"></a>xTaskNotifyGive&#x2F;ulTaskNotifyTake</h4><p>在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知：</p>\n<ul>\n<li>使得通知值加一</li>\n<li>并使得通知状态变为”pending”，也就是<code>taskNOTIFICATION_RECEIVED</code>，表示有数据了、待处理</li>\n</ul>\n<p>可以使用ulTaskNotifyTake函数来取出通知值：</p>\n<ul>\n<li>如果通知值等于0，则阻塞(可以指定超时时间)</li>\n<li>当通知值大于0时，任务从阻塞态进入就绪态</li>\n<li>在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li>\n</ul>\n<p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyGive</span><span class=\"params\">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskNotifyGiveFromISR</span><span class=\"params\">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">ulTaskNotifyTake</span><span class=\"params\">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>xTaskNotifyGive函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xTaskToNotify</td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>必定返回pdPASS</td>\n</tr>\n</tbody></table>\n<p>vTaskNotifyGiveFromISR函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xTaskHandle</td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>被通知的任务，可能正处于阻塞状态。<br />此函数发出通知后，会把它从阻塞状态切换为就绪态。<br />如果被唤醒的任务的优先级，高于当前任务的优先级，<br />则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，<br />这表示在中断返回之前要进行任务切换。</td>\n</tr>\n</tbody></table>\n<p>ulTaskNotifyTake函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xClearCountOnExit</td>\n<td>函数返回前是否清零：<br />pdTRUE：把通知值清零<br />pdFALSE：如果通知值大于0，则把通知值减一</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>任务进入阻塞态的超时时间，它在等待通知值大于0。<br />0：不等待，即刻返回；<br />portMAX_DELAY：一直等待，直到通知值大于0；<br />其他值：Tick Count，可以用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>函数返回之前，在清零或减一之前的通知值。<br />如果xTicksToWait非0，则返回值有2种情况：<br />1. 大于0：在超时前，通知值被增加了<br />2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td>\n</tr>\n</tbody></table>\n<h4 id=\"xTaskNotify-x2F-xTaskNotifyWait\"><a href=\"#xTaskNotify-x2F-xTaskNotifyWait\" class=\"headerlink\" title=\"xTaskNotify&#x2F;xTaskNotifyWait\"></a>xTaskNotify&#x2F;xTaskNotifyWait</h4><p><code>xTaskNotify</code> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p>\n<ul>\n<li>让接收任务的通知值加一：这时<code>xTaskNotify()</code>等同于<code>xTaskNotifyGive()</code></li>\n<li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li>\n<li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li>\n<li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似<code>xQueueOverwrite()</code>函数，这就是轻量级的邮箱。</li>\n</ul>\n<p><code>xTaskNotify()</code>比<code>xTaskNotifyGive()</code>更灵活、强大，使用上也就更复杂。<code>xTaskNotifyFromISR()</code>是它对应的ISR版本。</p>\n<p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p>\n<p>使用<code>xTaskNotifyWait()</code>函数！它比<code>ulTaskNotifyTake()</code>更复杂：</p>\n<ul>\n<li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li>\n<li>还可以在函数进入、退出时，清除通知值的指定位</li>\n</ul>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotify</span><span class=\"params\">( TaskHandle_t xTaskToNotify, <span class=\"type\">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyFromISR</span><span class=\"params\">( TaskHandle_t xTaskToNotify,</span></span><br><span class=\"line\"><span class=\"params\">                               <span class=\"type\">uint32_t</span> ulValue, </span></span><br><span class=\"line\"><span class=\"params\">                               eNotifyAction eAction, </span></span><br><span class=\"line\"><span class=\"params\">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyWait</span><span class=\"params\">( <span class=\"type\">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> *pulNotificationValue, </span></span><br><span class=\"line\"><span class=\"params\">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>xTaskNotify函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xTaskToNotify</td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td>ulValue</td>\n<td>怎么使用ulValue，由eAction参数决定</td>\n</tr>\n<tr>\n<td>eAction</td>\n<td>见下表</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：成功，大部分调用都会成功<br />pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite，<br />                并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td>\n</tr>\n</tbody></table>\n<p>eNotifyAction参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>eNotifyAction取值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>eNoAction</td>\n<td>仅仅是更新通知状态为”pending”，未使用ulValue。<br />这个选项相当于轻量级的、更高效的二进制信号量。</td>\n</tr>\n<tr>\n<td>eSetBits</td>\n<td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。<br />相当于轻量级的、更高效的事件组。</td>\n</tr>\n<tr>\n<td>eIncrement</td>\n<td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。<br />相当于轻量级的、更高效的二进制信号量、计数型信号量。<br />相当于<code>xTaskNotifyGive()</code>函数。</td>\n</tr>\n<tr>\n<td>eSetValueWithoutOverwrite</td>\n<td>不覆盖。<br />如果通知状态为”pending”(表示有数据未读)，<br />则此次调用xTaskNotify不做任何事，返回pdFAIL。<br />如果通知状态不是”pending”(表示没有新数据)，<br />则：通知值 &#x3D; ulValue。</td>\n</tr>\n<tr>\n<td>eSetValueWithOverwrite</td>\n<td>覆盖。<br />无论如何，不管通知状态是否为”pendng”，<br />通知值 &#x3D; ulValue。</td>\n</tr>\n</tbody></table>\n<p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<code>pxHigherPriorityTaskWoken</code>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p>\n<ul>\n<li>被通知的任务，可能正处于阻塞状态</li>\n<li><code>xTaskNotifyFromISR</code>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li>\n<li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li>\n</ul>\n<p>xTaskNotifyWait函数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ulBitsToClearOnEntry</td>\n<td>在xTaskNotifyWait入口处，要清除通知值的哪些位？<br />通知状态不是”pending”的情况下，才会清除。<br />它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。<br />能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。<br />比如传入0x01，表示清除通知值的bit0；<br />传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td>ulBitsToClearOnExit</td>\n<td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时：<br />通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。<br />在清除某些位之前，通知值先被赋给”*pulNotificationValue”。<br />比如入0x03，表示清除通知值的bit0、bit1；<br />传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td>pulNotificationValue</td>\n<td>用来取出通知值。<br />在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。<br />如果不需要取出通知值，可以设为NULL。</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。<br />0：不等待，即刻返回；<br />portMAX_DELAY：一直等待，直到通知状态变为”pending”；<br />其他值：Tick Count，可以用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>1. pdPASS：成功<br />这表示xTaskNotifyWait成功获得了通知：<br />可能是调用函数之前，通知状态就是”pending”；<br />也可能是在阻塞期间，通知状态变为了”pending”。<br />2. pdFAIL：没有得到通知。</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件定时器\"><a href=\"#软件定时器\" class=\"headerlink\" title=\"软件定时器\"></a>软件定时器</h2><h3 id=\"软件定时器的特性\"><a href=\"#软件定时器的特性\" class=\"headerlink\" title=\"软件定时器的特性\"></a>软件定时器的特性</h3><p>我们在手机上添加闹钟时，需要指定时间、指定类型(一次性的，还是周期性的)、指定做什么事；还有一些过时的、不再使用的闹钟。</p>\n<p>使用定时器跟使用手机闹钟是类似的：</p>\n<ul>\n<li>指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。</li>\n<li>指定类型，定时器有两种类型：<ul>\n<li>一次性(One-shot timers)：<br>这类定时器启动后，它的回调函数只会被调用一次；<br>可以手工再次启动它，但是不会自动启动它。</li>\n<li>自动加载定时器(Auto-reload timers )：<br>这类定时器启动后，时间到之后它会自动启动它；<br>这使得回调函数被周期性地调用。</li>\n</ul>\n</li>\n<li>指定要做什么事，就是指定回调函数</li>\n</ul>\n<p>实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：</p>\n<ul>\n<li>运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li>\n<li>冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li>\n</ul>\n<p>定时器运行情况示例如下：</p>\n<ul>\n<li>Timer1：它是一次性的定时器，在t1启动，周期是6个Tick。经过6个tick后，在t7执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。</li>\n<li>Timer2：它是自动加载的定时器，在t1启动，周期是5个Tick。每经过5个tick它的回调函数都被执行，比如在t6、t11、t16都会执行。</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673877932075_6txse7co5pok1ngf.png\"></p>\n<h3 id=\"软件定时器的上下文\"><a href=\"#软件定时器的上下文\" class=\"headerlink\" title=\"软件定时器的上下文\"></a>软件定时器的上下文</h3><h4 id=\"守护任务\"><a href=\"#守护任务\" class=\"headerlink\" title=\"守护任务\"></a>守护任务</h4><p>要理解软件定时器API函数的参数，特别是里面的<code>xTicksToWait</code>，需要知道定时器执行的过程。</p>\n<p>FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行。在哪里执行定时器函数？第一印象就是在Tick中断里执行：</p>\n<ul>\n<li>在Tick中断中判断定时器是否超时</li>\n<li>如果超时了，调用它的回调函数</li>\n</ul>\n<p>FreeRTOS是RTOS，它不允许在内核、在中断中执行不确定的代码：如果定时器函数很耗时，会影响整个系统。</p>\n<p>所以，FreeRTOS中，不在Tick中断中执行定时器函数。</p>\n<p>在哪里执行？在某个任务里执行，这个任务就是：RTOS Damemon Task，RTOS守护任务。以前被称为”Timer server”，但是这个任务要做并不仅仅是定时器相关，所以改名为：RTOS Damemon Task。</p>\n<p>当FreeRTOS的配置项<code>configUSE_TIMERS</code>被设置为1时，在启动调度器时，会自动创建RTOS Damemon Task。</p>\n<p>我们自己编写的任务函数要使用定时器时，是通过”定时器命令队列”(timer command queue)和守护任务交互，如下图所示：</p>\n<p><img src=\"/!%5B%5D(https:/image.wxydejoy.top/utools/1673878043754_v3w2rdr4b3udx805.png)\" alt=\"image-20210809193524596\"></p>\n<p>守护任务的优先级为：configTIMER_TASK_PRIORITY；定时器命令队列的长度为configTIMER_QUEUE_LENGTH。</p>\n<h4 id=\"守护任务的调度\"><a href=\"#守护任务的调度\" class=\"headerlink\" title=\"守护任务的调度\"></a>守护任务的调度</h4><p>守护任务的调度，跟普通的任务并无差别。当守护任务是当前优先级最高的就绪态任务时，它就可以运行。它的工作有两类：</p>\n<ul>\n<li>处理命令：从命令队列里取出命令、处理</li>\n<li>执行定时器的回调函数</li>\n</ul>\n<p>能否及时处理定时器的命令、能否及时执行定时器的回调函数，严重依赖于守护任务的优先级。下面使用2个例子来演示。</p>\n<p>例子1：守护任务的优先性级较低</p>\n<ul>\n<li><p>t1：Task1处于运行态，守护任务处于阻塞态。<br>守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。<br>至于守护任务能否马上执行，取决于它的优先级。</p>\n</li>\n<li><p>t2：Task1调用<code>xTimerStart()</code><br>要注意的是，<code>xTimerStart()</code>只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。<br>在本例中，Task1的优先级高于守护任务，所以守护任务无法抢占Task1。</p>\n</li>\n<li><p>t3：Task1执行完<code>xTimerStart()</code><br>但是定时器的启动工作由守护任务来实现，所以<code>xTimerStart()</code>返回并不表示定时器已经被启动了。</p>\n</li>\n<li><p>t4：Task1由于某些原因进入阻塞态，现在轮到守护任务运行。<br>守护任务从队列中取出”start timer”命令，启动定时器。</p>\n</li>\n<li><p>t5：守护任务处理完队列中所有的命令，再次进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。</p>\n</li>\n<li><p>注意：假设定时器在后续某个时刻tX超时了，超时时间是”tX-t2”，而非”tX-t4”，从<code>xTimerStart()</code>函数被调用时算起。</p>\n</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878068181_kq43blmv75dwe00z.png\"></p>\n<p>例子2：守护任务的优先性级较高</p>\n<ul>\n<li><p>t1：Task1处于运行态，守护任务处于阻塞态。<br>守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。<br>至于守护任务能否马上执行，取决于它的优先级。</p>\n</li>\n<li><p>t2：Task1调用<code>xTimerStart()</code><br>要注意的是，<code>xTimerStart()</code>只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。<br>在本例中，守护任务的优先级高于Task1，所以守护任务抢占Task1，守护任务开始处理命令队列。<br>Task1在执行<code>xTimerStart()</code>的过程中被抢占，这时它无法完成此函数。</p>\n</li>\n<li><p>t3：守护任务处理完命令队列中所有的命令，再次进入阻塞态。<br>此时Task1是优先级最高的就绪态任务，它开始执行。</p>\n</li>\n<li><p>t4：Task1之前被守护任务抢占，对<code>xTimerStart()</code>的调用尚未返回。现在开始继续运行次函数、返回。</p>\n</li>\n<li><p>t5：Task1由于某些原因进入阻塞态，进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。</p>\n</li>\n</ul>\n<p><img src=\"/pic/chap10/05_demon_task_priority_higher.png\" alt=\"image-20210809161518141\"></p>\n<p>注意，定时器的超时时间是基于调用<code>xTimerStart()</code>的时刻tX，而不是基于守护任务处理命令的时刻tY。假设超时时间是10个Tick，超时时间是”tX+10”，而非”tY+10”。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>定时器的回调函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATimerCallback</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。</p>\n<p>所以，定时器的回调函数不要影响其他人：</p>\n<ul>\n<li><p>回调函数要尽快实行，不能进入阻塞状态</p>\n</li>\n<li><p>不要调用会导致阻塞的API函数，比如<code>vTaskDelay()</code></p>\n</li>\n<li><p>可以调用<code>xQueueReceive()</code>之类的函数，但是超时时间要设为0：即刻返回，不可阻塞</p>\n</li>\n</ul>\n<h3 id=\"软件定时器的函数\"><a href=\"#软件定时器的函数\" class=\"headerlink\" title=\"软件定时器的函数\"></a>软件定时器的函数</h3><p>根据定时器的状态转换图，就可以知道所涉及的函数：</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878093734_wd0b1lpwo1bkxt5n.png\"></p>\n<h4 id=\"创建-4\"><a href=\"#创建-4\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>要使用定时器，需要先创建它，得到它的句柄。</p>\n<p>有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 使用动态分配内存的方法创建定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class=\"line\"><span class=\"comment\"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class=\"line\"><span class=\"comment\"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxCallbackFunction: 回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TimerHandle_t <span class=\"title function_\">xTimerCreate</span><span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcTimerName, </span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t<span class=\"type\">const</span> TickType_t xTimerPeriodInTicks,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t<span class=\"type\">const</span> UBaseType_t uxAutoReload,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t<span class=\"type\">void</span> * <span class=\"type\">const</span> pvTimerID,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\tTimerCallbackFunction_t pxCallbackFunction )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用静态分配内存的方法创建定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class=\"line\"><span class=\"comment\"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class=\"line\"><span class=\"comment\"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxCallbackFunction: 回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TimerHandle_t <span class=\"title function_\">xTimerCreateStatic</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcTimerName,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTimerPeriodInTicks,</span></span><br><span class=\"line\"><span class=\"params\">                                 UBaseType_t uxAutoReload,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">void</span> * pvTimerID,</span></span><br><span class=\"line\"><span class=\"params\">                                 TimerCallbackFunction_t pxCallbackFunction,</span></span><br><span class=\"line\"><span class=\"params\">                                 StaticTimer_t *pxTimerBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>回调函数的类型是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATimerCallback</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">void</span> <span class=\"params\">(* TimerCallbackFunction_t)</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"删除-3\"><a href=\"#删除-3\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 删除定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 要删除哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerDelete</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>定时器的很多API函数，都是通过发送”命令”到命令队列，由守护任务来实现。</p>\n<p>如果队列满了，”命令”就无法即刻写入队列。我们可以指定一个超时时间<code>xTicksToWait</code>，等待一会。</p>\n<h4 id=\"启动-x2F-停止\"><a href=\"#启动-x2F-停止\" class=\"headerlink\" title=\"启动&#x2F;停止\"></a>启动&#x2F;停止</h4><p>启动定时器就是设置它的状态为运行态(Running、Active)。</p>\n<p>停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。</p>\n<p>涉及的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 启动定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStart</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 启动定时器(ISR版本)</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStartFromISR</span><span class=\"params\">(   TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 停止定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStop</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 停止定时器(ISR版本)</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerStopFromISR</span><span class=\"params\">(    TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，这些函数的<code>xTicksToWait</code>表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。</p>\n<p><code>xTicksToWait</code>不是定时器本身的超时时间，不是定时器本身的”周期”。</p>\n<p>创建定时器时，设置了它的周期(period)。<code>xTimerStart()</code>函数是用来启动定时器。假设调用<code>xTimerStart()</code>的时刻是tX，定时器的周期是n，那么在<code>tX+n</code>时刻定时器的回调函数被调用。</p>\n<p>如果定时器已经被启动，但是它的函数尚未被执行，再次执行<code>xTimerStart()</code>函数相当于执行<code>xTimerReset()</code>，重新设定它的启动时间。</p>\n<h4 id=\"复位-1\"><a href=\"#复位-1\" class=\"headerlink\" title=\"复位\"></a>复位</h4><p>从定时器的状态转换图可以知道，使用<code>xTimerReset()</code>函数可以让定时器的状态从冬眠态转换为运行态，相当于使用<code>xTimerStart()</code>函数。</p>\n<p>如果定时器已经处于运行态，使用<code>xTimerReset()</code>函数就相当于重新确定超时时间。假设调用<code>xTimerReset()</code>的时刻是tX，定时器的周期是n，那么<code>tX+n</code>就是重新确定的超时时间。</p>\n<p>复位函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 复位定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerReset</span><span class=\"params\">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 复位定时器(ISR版本)</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerResetFromISR</span><span class=\"params\">(   TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"修改周期\"><a href=\"#修改周期\" class=\"headerlink\" title=\"修改周期\"></a>修改周期</h4><p>从定时器的状态转换图可以知道，使用<code>xTimerChangePeriod()</code>函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</p>\n<p>修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用<code>xTimerChangePeriod()</code>函数的时间tX，新的周期是n，则<code>tX+n</code>就是新的超时时间。</p>\n<p>相关函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 修改定时器的周期</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xNewPeriod: 新周期</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 超时时间, 命令写入队列的超时时间 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerChangePeriod</span><span class=\"params\">(   TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xNewPeriod,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 修改定时器的周期</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * xNewPeriod: 新周期</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"> *                            表示需要进行任务调度</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class=\"line\"><span class=\"comment\"> *        pdPASS表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTimerChangePeriodFromISR</span><span class=\"params\">( TimerHandle_t xTimer,</span></span><br><span class=\"line\"><span class=\"params\">                                      TickType_t xNewPeriod,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"定时器ID\"><a href=\"#定时器ID\" class=\"headerlink\" title=\"定时器ID\"></a>定时器ID</h4><p>定时器的结构体如下，里面有一项<code>pvTimerID</code>，它就是定时器ID：</p>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878165302_vn9b11k5d1g8o3jb.png\"></p>\n<p>怎么使用定时器ID，完全由程序来决定：</p>\n<ul>\n<li>可以用来标记定时器，表示自己是什么定时器</li>\n<li>可以用来保存参数，给回调函数使用</li>\n</ul>\n<p>它的初始值在创建定时器时由<code>xTimerCreate()</code>这类函数传入，后续可以使用这些函数来操作：</p>\n<ul>\n<li>更新ID：使用<code>vTimerSetTimerID()</code>函数</li>\n<li>查询ID：查询<code>pvTimerGetTimerID()</code>函数</li>\n</ul>\n<p>这两个函数不涉及命令队列，它们是直接操作定时器结构体。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 获得定时器的ID</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 定时器的ID</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">pvTimerGetTimerID</span><span class=\"params\">( TimerHandle_t xTimer )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 设置定时器的ID</span></span><br><span class=\"line\"><span class=\"comment\"> * xTimer: 哪个定时器</span></span><br><span class=\"line\"><span class=\"comment\"> * pvNewID: 新ID</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 无</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTimerSetTimerID</span><span class=\"params\">( TimerHandle_t xTimer, <span class=\"type\">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"中断管理\"><a href=\"#中断管理\" class=\"headerlink\" title=\"中断管理\"></a>中断管理</h2><h3 id=\"两套API函数\"><a href=\"#两套API函数\" class=\"headerlink\" title=\"两套API函数\"></a>两套API函数</h3><h4 id=\"为什么需要两套API\"><a href=\"#为什么需要两套API\" class=\"headerlink\" title=\"为什么需要两套API\"></a>为什么需要两套API</h4><p>在任务函数中，我们可以调用各类API函数，比如队列操作函数：xQueueSendToBack。但是在ISR中使用这个函数会导致问题，应该使用另一个函数：xQueueSendToBackFromISR，它的函数名含有后缀”FromISR”，表示”从ISR中给队列发送数据”。</p>\n<p>FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名含有”FromISR”后缀。</p>\n<p>为什么要引入两套API函数？</p>\n<ul>\n<li>很多API函数会导致任务计入阻塞状态：<ul>\n<li>运行这个函数的<strong>任务</strong>进入阻塞状态</li>\n<li>比如写队列时，如果队列已满，可以进入阻塞状态等待一会</li>\n</ul>\n</li>\n<li>ISR调用API函数时，ISR不是”任务”，ISR不能进入阻塞状态</li>\n<li>所以，在任务中、在ISR中，这些函数的功能是有差别的</li>\n</ul>\n<p>为什么不使用同一套函数，比如在函数里面分辨当前调用者是任务还是ISR呢？示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(...)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_in_isr())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/* 把数据放入队列 */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/* 不管是否成功都直接返回 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">/* 在任务中 */</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/* 把数据放入队列 */</span></span><br><span class=\"line\">        <span class=\"comment\">/* 不成功就等待一会再重试 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FreeRTOS使用两套函数，而不是使用一套函数，是因为有如下好处：</p>\n<ul>\n<li><p>使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，是的函数更长、更复杂、难以测试</p>\n</li>\n<li><p>在任务、ISR中调用时，需要的参数不一样，比如：</p>\n<ul>\n<li>在任务中调用：需要指定超时时间，表示如果不成功就阻塞一会</li>\n<li>在ISR中调用：不需要指定超时时间，无论是否成功都要即刻返回</li>\n<li>如果强行把两套函数揉在一起，会导致参数臃肿、无效</li>\n</ul>\n</li>\n<li><p>移植FreeRTOS时，还需要提供监测上下文的函数，比如<code>is_in_isr()</code></p>\n</li>\n<li><p>有些处理器架构没有办法轻易分辨当前是处于任务中，还是处于ISR中，就需要额外添加更多、更复杂的代码</p>\n</li>\n</ul>\n<p>使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR总调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。这个问题可以解决：</p>\n<ul>\n<li>把中断的处理推迟到任务中进行(Defer interrupt  processing)，在任务中调用库函数</li>\n<li>尝试在库函数中使用”FromISR”函数：<ul>\n<li>在任务中、在ISR中都可以调用”FromISR”函数</li>\n<li>反过来就不行，非FromISR函数无法在ISR中使用</li>\n</ul>\n</li>\n<li>第三方库函数也许会提供OS抽象层，自行判断当前环境是在任务还是在ISR中，分别调用不同的函数</li>\n</ul>\n<h4 id=\"两套API函数列表\"><a href=\"#两套API函数列表\" class=\"headerlink\" title=\"两套API函数列表\"></a>两套API函数列表</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>在任务中</th>\n<th>在ISR中</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>队列(queue)</td>\n<td>xQueueSendToBack</td>\n<td>xQueueSendToBackFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueueSendToFront</td>\n<td>xQueueSendToFrontFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueueReceive</td>\n<td>xQueueReceiveFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueueOverwrite</td>\n<td>xQueueOverwriteFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xQueuePeek</td>\n<td>xQueuePeekFromISR</td>\n</tr>\n<tr>\n<td>信号量(semaphore)</td>\n<td>xSemaphoreGive</td>\n<td>xSemaphoreGiveFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xSemaphoreTake</td>\n<td>xSemaphoreTakeFromISR</td>\n</tr>\n<tr>\n<td>事件组(event group)</td>\n<td>xEventGroupSetBits</td>\n<td>xEventGroupSetBitsFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xEventGroupGetBits</td>\n<td>xEventGroupGetBitsFromISR</td>\n</tr>\n<tr>\n<td>任务通知(task notification)</td>\n<td>xTaskNotifyGive</td>\n<td>vTaskNotifyGiveFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTaskNotify</td>\n<td>xTaskNotifyFromISR</td>\n</tr>\n<tr>\n<td>软件定时器(software timer)</td>\n<td>xTimerStart</td>\n<td>xTimerStartFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTimerStop</td>\n<td>xTimerStopFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTimerReset</td>\n<td>xTimerResetFromISR</td>\n</tr>\n<tr>\n<td></td>\n<td>xTimerChangePeriod</td>\n<td>xTimerChangePeriodFromISR</td>\n</tr>\n</tbody></table>\n<h4 id=\"xHigherPriorityTaskWoken参数\"><a href=\"#xHigherPriorityTaskWoken参数\" class=\"headerlink\" title=\"xHigherPriorityTaskWoken参数\"></a>xHigherPriorityTaskWoken参数</h4><p>xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。</p>\n<p>还是以写队列为例。</p>\n<p>任务A调用<code>xQueueSendToBack()</code>写队列，有几种情况发生：</p>\n<ul>\n<li>队列满了，任务A阻塞等待，另一个任务B运行</li>\n<li>队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行</li>\n<li>队列没满，任务A成功写入队列，即刻返回</li>\n</ul>\n<p>可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做”context switch”，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。</p>\n<p><code>xQueueSendToBackFromISR()</code>函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBackFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 用法示例 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class=\"line\">xQueueSendToBackFromISR(xQueue, pvItemToQueue, &amp;xHigherPriorityTaskWoken);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 任务切换 */</span>    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换</p>\n<ul>\n<li>*pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换</li>\n<li>*pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要</li>\n</ul>\n<p>为什么不在”FromISR”函数内部进行任务切换，而只是标记一下而已呢？为了效率！示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XXX_ISR</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBackFromISR(...); <span class=\"comment\">/* 被多次调用 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ISR中有可能多次调用”FromISR”函数，如果在”FromISR”内部进行任务切换，会浪费时间。解决方法是：</p>\n<ul>\n<li>在”FromISR”中标记是否需要切换</li>\n<li>在ISR返回之前再进行任务切换</li>\n<li>示例代码如下</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XXX_ISR</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBackFromISR(..  &amp;xHigherPriorityTaskWoken); <span class=\"comment\">/* 被多次调用 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 最后再决定是否进行任务切换 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/* 任务切换 */</span>    </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。</p>\n<p>在ISR中调用API时不进行任务切换，而只是在”xHigherPriorityTaskWoken”中标记一下，除了效率，还有多种好处：</p>\n<ul>\n<li>效率高：避免不必要的任务切换</li>\n<li>让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂</li>\n<li>可移植性</li>\n<li>在Tick中断中，调用<code>vApplicationTickHook()</code>：它运行与ISR，只能使用”FromISR”的函数</li>\n</ul>\n<p>使用”FromISR”函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。</p>\n<h4 id=\"怎么切换任务\"><a href=\"#怎么切换任务\" class=\"headerlink\" title=\"怎么切换任务\"></a>怎么切换任务</h4><p>FreeRTOS的ISR函数中，使用两个宏进行任务切换：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );</span><br><span class=\"line\">或</span><br><span class=\"line\">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br></pre></td></tr></table></figure>\n\n<p>这两个宏做的事情是完全一样的，在老版本的FreeRTOS中，</p>\n<ul>\n<li><code>portEND_SWITCHING_ISR</code>使用汇编实现</li>\n<li><code>portYIELD_FROM_ISR</code>使用C语言实现</li>\n</ul>\n<p>新版本都统一使用<code>portYIELD_FROM_ISR</code>。</p>\n<p>使用示例如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XXX_ISR</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBackFromISR(..  &amp;xHigherPriorityTaskWoken); <span class=\"comment\">/* 被多次调用 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 最后再决定是否进行任务切换 </span></span><br><span class=\"line\"><span class=\"comment\">     * xHigherPriorityTaskWoken为pdTRUE时才切换</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"中断的延迟处理\"><a href=\"#中断的延迟处理\" class=\"headerlink\" title=\"中断的延迟处理\"></a>中断的延迟处理</h3><p>前面讲过，ISR要尽量快，否则：</p>\n<ul>\n<li>其他低优先级的中断无法被处理：实时性无法保证</li>\n<li>用户任务无法被执行：系统显得很卡顿 </li>\n<li>如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套</li>\n</ul>\n<p>如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：</p>\n<ul>\n<li>ISR：尽快做些清理、记录工作，然后触发某个任务</li>\n<li>任务：更复杂的事情放在任务中处理</li>\n</ul>\n<p>这种处理方式叫”中断的延迟处理”(Deferring interrupt processing)，处理流程如下图所示：</p>\n<ul>\n<li>t1：任务1运行，任务2阻塞</li>\n<li>t2：发生中断，<ul>\n<li>该中断的ISR函数被执行，任务1被打断</li>\n<li>ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2</li>\n</ul>\n</li>\n<li>t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为”deferred processing task”，中断的延迟处理任务。</li>\n<li>t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行</li>\n</ul>\n<p><img src=\"https://image.wxydejoy.top/utools/1673878428670_9qjlufv5a7dozv2z.png\"></p>\n<h3 id=\"中断与任务间的通信\"><a href=\"#中断与任务间的通信\" class=\"headerlink\" title=\"中断与任务间的通信\"></a>中断与任务间的通信</h3><p>前面讲解过的队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。</p>\n<p>要注意的是，在ISR中使用的函数要有”FromISR”后缀。</p>\n<h2 id=\"资源管理\"><a href=\"#资源管理\" class=\"headerlink\" title=\"资源管理\"></a>资源管理</h2><h3 id=\"屏蔽中断\"><a href=\"#屏蔽中断\" class=\"headerlink\" title=\"屏蔽中断\"></a>屏蔽中断</h3><p>屏蔽中断有两套宏：任务中使用、ISR中使用：</p>\n<ul>\n<li>任务中使用：<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code></li>\n<li>ISR中使用：<code>taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code></li>\n</ul>\n<h4 id=\"在任务中屏蔽中断\"><a href=\"#在任务中屏蔽中断\" class=\"headerlink\" title=\"在任务中屏蔽中断\"></a>在任务中屏蔽中断</h4><p>在任务中屏蔽中断的示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在任务中，当前时刻中断是使能的</span></span><br><span class=\"line\"><span class=\"comment\"> * 执行这句代码后，屏蔽中断</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">taskENTER_CRITICAL();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 访问临界资源 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 重新使能中断 */</span></span><br><span class=\"line\">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure>\n\n<p>在<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>之间：</p>\n<ul>\n<li>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></li>\n<li>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code><ul>\n<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>\n</ul>\n</li>\n<li>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</li>\n</ul>\n<p>这套<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用<code>taskEXIT_CRITICAL()</code>才会重新使能中断。</p>\n<p>使用<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>来访问临界资源是很粗鲁的方法：</p>\n<ul>\n<li>中断无法正常运行</li>\n<li>任务调度无法进行</li>\n<li>所以，之间的代码要尽可能快速地执行</li>\n</ul>\n<h4 id=\"在ISR中屏蔽中断\"><a href=\"#在ISR中屏蔽中断\" class=\"headerlink\" title=\"在ISR中屏蔽中断\"></a>在ISR中屏蔽中断</h4><p>要使用含有”FROM_ISR”后缀的宏，示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vAnInterruptServiceRoutine</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ## 用来记录当前中断是否使能 */</span><br><span class=\"line\">    UBaseType_t uxSavedInterruptStatus;</span><br><span class=\"line\">    </span><br><span class=\"line\">  ## 在ISR中，当前时刻中断可能是使能的，也可能是禁止的</span><br><span class=\"line\">## * 所以要记录当前状态, 后面要恢复为原先的状态</span><br><span class=\"line\">## * 执行这句代码后，屏蔽中断</span><br><span class=\"line\">## */</span><br><span class=\"line\">    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class=\"line\">    </span><br><span class=\"line\">  ## 访问临界资源 */</span><br><span class=\"line\"></span><br><span class=\"line\">  ## 恢复中断状态 */</span><br><span class=\"line\">    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br><span class=\"line\">  ## 现在，当前ISR可以被更高优先级的中断打断了 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在<code>taskENTER_CRITICA_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code>之间：</p>\n<ul>\n<li>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></li>\n<li>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code><ul>\n<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>\n</ul>\n</li>\n<li>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</li>\n</ul>\n<h1 id=\"暂停调度器\"><a href=\"#暂停调度器\" class=\"headerlink\" title=\"暂停调度器\"></a>暂停调度器</h1><p>如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。</p>\n<p>如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。</p>\n<p>使用这2个函数来暂停、恢复调度器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 暂停调度器 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskSuspendAll</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 恢复调度器</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了</span></span><br><span class=\"line\"><span class=\"comment\"> *##    可以不理会这个返回值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskResumeAll</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vTaskSuspendScheduler();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 访问临界资源 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">xTaskResumeScheduler();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这套<code>vTaskSuspendScheduler()/xTaskResumeScheduler()</code>宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用<code>taskEXIT_CRITICAL()</code>才会重新使能中断。</p>\n<p><a href=\"http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/index.html\">参考原文地址</a></p>\n","categories":[],"tags":[]}