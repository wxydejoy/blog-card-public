[{"title":"OMPL开源轨迹规划库","path":"/posts/7f43910f/","content":"下面列出的所有实现都被视为功能齐全。在OMPL中，规划器分为三类: 几何规划器 基于控制的规划器 基于多层次的规划器 要了解如何对规划器进行基准测试，请单击 此处 。 实例图册部分没图就是当时没求解出来ABITstarFMTLBKPIECE1RRTSPARStwoAITstarinformedRRTstarLBTRRTRRTsharpSSTBFMTKPIECE1PDSTRRTstarSTRIDEBiESTlazyLBTRRTPRMRRTXstaticTRRTBITstarlazyPRMPRMstarSBLBKPIECE1lazyPRMstarProjESTSORRTstarESTlazyRRTRRTconnectSPARS 几何规划器此类别中的规划器仅考虑系统的几何和运动学约束。假设任何可行的路径都可以变成动态可行的轨迹。这些规划器中的任何一个都可用于 几何约束进行规划 。此类别中的规划器可以分为几个重叠的子类别: 多查询规划器 这些规划器构建了可用于多个查询的整个环境的路线图。 概率路线图方法PRM 这是基于采样的算法。我们的实现使用一个线程来构建路线图，而另一个线程检查路线图中是否存在开始状态和目标状态之间的路径。OMPL包含许多PRM的变体: LazyPRM 此计划器类似于常规 PRM，但“懒惰”地检查顶点或边的有效性，即仅当它是候选解决方案路径的一部分时。 PRM* 虽然常规 PRM 尝试将状态连接到固定数量的邻居，但 PRM* 会随着路线图的增长而逐渐增加连接尝试的次数，从而向最佳路径提供收敛。 LazyPRM* 具有惰性状态有效性检查的 PRM* 版本。 SPArse 路线图扳手算法 （SPARS） SPARS是一个计划器，它提供渐近 near 最优性（在最优解的常数因子内的解决方案），并包括一个有意义的停止准则。虽然（因为？）它不能保证最优性，但它的收敛率往往远高于PRM*。 SPARS2 SPARS2是SPARS算法的变体，它通过类似的机制工作，但使用不同的方法来识别接口和计算通过所述接口的最短路径。 单查询规划器 这些规划者通常会生长一棵由有效运动连接的状态树。这些规划器的不同之处在于他们用于控制 树的扩展位置 和 方式 的启发式方法。一些基于树的规划者种植 两 棵树:一棵从起点开始，一棵从目标开始。此类规划器将尝试将开始树中的一个状态与目标树中的另一个状态连接起来。 快速探索随机树 （RRT） 这是最早的单个查询规划器之一。该算法易于理解和实现。已经提出了许多很多RRT的变体。OMPL 包含几种 RRT 变体: RRT Connect （RRTConnect） 这个规划器是RRT的双向版本（即，它长了两棵树）。它通常优于原始的RRT算法。 RRT* RRT的渐近最优版本:算法收敛于作为时间函数的最优路径。这是第一个可证明的渐近规划器（与PRM一起）。自发布以来，已经出现了其他几种算法，这些算法提高了RRT*的收敛率，例如 RRT# 和 RRTX 。 下限树 RRT （LBTRRT） LBTRRT是RRT的渐近最优版本:它保证收敛到最优解的常数因子内的解。 稀疏稳定RRT SST 是 RRT 的渐近接近最优增量版本。 基于过渡的 RRT （T-RRT） T-RRT不提供任何硬性最优性保证，但试图找到短而低成本的路径。 矢量场RRT VF-RRT是一个基于树的运动规划器，试图最小化所谓的路径上游成本。上游成本由用户定义的向量场上的积分定义。 平行RRT 已经为基于抽样的计划者提出了许多不同的并行化方案，包括RRT。在此实现中，多个线程同时向同一树添加状态。找到解决方案后，所有线程都将终止。 Lazy RRT （LazyRRT） 此计划器执行惰性状态有效性检查（类似于 LazyPRM）。它不是实验性的，但根据我们的经验，它似乎在任何类别的问题上都没有明显优于其他规划者。 任务空间RRT （TSRRT） TSRRT是RRT的一种变体，其中探索由任务空间指导。它需要一个 ompl::geometric::TaskSpaceConfig 实例，该实例定义如何将配置空间状态投影到任务空间，以及一个将任务空间状态提升到配置空间的反向操作。 膨胀空间树 （EST） 该规划器与RRT大约同时出版。根据我们的经验，它对良好的距离测量并不敏感，这对于复杂的高维状态空间可能很难定义。EST实际上有三个版本: 原始 接近第一次发布的 版本，双向版本 和 基于投影的版本 。低维投影用于跟踪状态空间的探索方式。大多数情况下，OMPL可以自动确定合理的投影。我们已经实施了一些规划器，这些规划器不一定是EST的简单变体，但确实具有相同的扩展策略: 单查询双向延迟碰撞检查计划 （SBL） 此计划器本质上是具有惰性状态有效性检查的 EST 的双向版本。 并行单查询双向延迟碰撞检查计划 （pSBL） 此规划器在 SBL 中并行使用多个线程增长两棵树。 通过内部和外部细胞探索 （KPIECE） 进行运动学规划 KPIECE是一个基于树的规划器，它使用离散化（通常是多个层次）来指导（连续）状态空间的探索。OMPL的实现是简化的，使用单一级别的离散化:一个网格。网格被强加于 projection 状态空间的投影上。在探索空间时，优先考虑到目前为止已探索的网格部分的边界。边界定义为 在 n 维投影空间中具有少于 2 n 个非对角线非空相邻格网像元的格网像 _n_元集。KPIECE有两种变体: 双向 KPIECE （BKPIECE） Lazy Bi-directional KPIECE （LBKPIECE） 具有分辨率独立密度估计（STRIDE）的搜索树 这位规划器的灵感来自 EST。STRIDE 不使用投影，而是使用 几何近邻访问树 直接在状态空间中估计采样密度。STRIDE 对于高维系统非常有用，在这些系统中，自由空间无法通过低维（线性）投影轻松捕获。 路径导向细分树 （PDST） PDST 是一个规划器，它完全消除了对距离度量的依赖，这在难以定义良好距离度量的情况下很有用。PDST保持二进制空间分区，以便运动完全包含在分区的一个单元格中。每个单元格的运动密度用于指导树的扩展。 快速行进树算法 （FMT∗） FMT∗ 算法对一组概率绘制的样本执行“惰性”动态规划递归，以生长路径树，该路径树在成本空间中向外移动。与所有其他规划器不同，需要事先选择有效样本的数量。 双向快速行进树算法（BFMT∗） 执行两个 FMT* 树，一个从起点开始，另一个从目标开始，从而在探索更少的空间时使规划器更快。 多层次规划器 可以利用多个抽象级别的规划算法。如果要使用它们，则应使用 [ompl::base::SpaceInformationPtr](https://ompl.kavrakilab.org/core/classompl_1_1base_1_1SpaceInformationPtr.html &quot;ompl::base::SpaceInformation 的共享指针包装器。&quot;).然后，所有规划器都保证概率完整性，如果提供的抽象是可以接受的。有指南 guide， 教程 和 演示 形式的大量文档。 快速探索随机商空间树 （QRRT） RRT的推广，以在不同的抽象级别上进行规划。 快速交货率* QRRT 的渐近最优版本 商空间路线图规划器 （QMP） PRM的泛化，用于在不同的抽象级别上进行规划。 QMP* QMP 的渐近最优版本 优化规划器 近年来，已经提出了几种基于抽样的计划算法，这些算法仍然提供了一些最优性保证。通常，假定最优解是最短路径。在OMPL中，我们有一个更通用的框架来表示状态和路径的成本，例如，允许您最大化沿路径的最小间隙，最小化机械功或一些任意用户定义的优化标准。有关详细信息，请参阅 最佳规划 。下面的一些规划者使用这种一般成本框架，但请记住，当优化路径长度以外的其他内容时，不能保证收敛到最优。 PRM* PRM的渐近最优版本; 使用一般成本框架。 懒惰PRM* PRM*的惰性版本; 使用一般成本框架。 RRT* RRT的渐近最优版本; 使用一般成本框架。 RRT# RRT* 的一种变体，收敛率更高。 它使用一般成本框架。 RRTX RRT* 的一种变体，收敛率更高。 它使用一般成本框架。 知情的RRT* RRT* 的一种变体，它使用启发式方法来绑定对最佳解决方案的搜索。 它使用一般成本框架。 批处理通知树 （BIT*） 一种随时渐近最优算法，它使用启发式算法对最优解的搜索进行排序和绑定。 它使用一般成本框架。 高级位* （阿比特*） BIT* 的扩展，它使用高级图形搜索技术更快地找到初始解决方案。 它使用一般成本框架。 自适应通知树 （AIT*） 一种随时渐近优化的算法，可同时估计和利用特定于问题的启发式方法。 它使用一般成本框架。 下限树 RRT （LBTRRT） RRT 的渐近接近最优版本。 稀疏稳定RRT SST 是 RRT 的渐近接近最优增量版本。 基于过渡的 RRT （T-RRT） T-RRT不提供任何硬性最优性保证，但试图找到短而低成本的路径。 它使用一般成本框架。 梁 基于渐近最优路线图的规划器。 SPARS2 基于渐近最优路线图的规划器。 FMT* 渐近最优的基于树的规划器。 ST-RRT* 用于时空规划的双向时间优化规划器。 首席财务官 一个元规划器，它在不同的线程中运行多个渐近最优规划器实例。当一个线程找到更好的求解路径时，路径上的状态将传递给其他线程。 随时缩短路径 （APS） APS 是围绕一个或多个几何运动规划器的通用包装器，它反复将 快捷方式 和 混合应用于 一组解决方案路径。可以指定任何数量和计划器的组合，每个计划器都在单独的线程中运行。 AttentionOMPL 如何选择几何规划器如果使用 ompl::geometric::SimpleSetup 类（强烈推荐）来定义和解决运动规划问题，则 OMPL 将自动选择合适的规划器（除非您明确指定了一个）。如果状态空间具有默认投影（如果您使用任何内置状态空间，情况就是如此），那么 使用 LBKPIECE 如果可以则它将使用双向规划器 ，否则它将使用 KPIECE 。这些规划器已被证明在许多现实世界的运动规划问题上都能很好地工作，这就是为什么这些规划器是默认选择的原因。如果状态空间没有默认投影，则将使用 RRTConnect 或常规 RRT ，具体取决于是否可以使用双向规划器。目标的概念在 OMPL 中非常笼统:甚至可能无法对满足目标的状态进行采样，在这种情况下，OMPL 无法在目标状态生长第二棵树。可行性和最优性在实践中，可行和最佳规划者之间的界限并不是那么黑白分明。它们之间的界限可以用适当的 ompl::base::PlannerTerminationCondition 来模糊。例如， ompl::base::exactSolnPlannerTerminationCondition 函数返回一个终止条件，该条件导致优化计划程序在找到第一个解决方案后终止。作为另一个示例，使用 ompl::base::CostConvergenceTerminationCondition 和参数 solutionsWindow=10 和 epsilon=1，导致优化计划程序 _exactly_在找到 10 个解决方案时终止。您可以使用 ompl::base::p lannerOrTerminationCondition 和 ompl::base::p lannerAndTerminationCondition 来组合计划程序终止条件（例如，“在找到 10 个解决方案或 超过 10 秒的时间限制时终止”）。有关详细信息，请参阅 Planner 终止条件 。 其他工具: Hill Climbing Genetic Search 基于控制的规划器如果所考虑的系统受到差异约束，则使用基于控制的规划器。这些规划者依靠 状态传播 而不是简单的插值来生成运动。这些规划器不需要 转向功能 ，但如果用户实现它，它们（KPIECE除外）都将使用它。下面的前两个规划器是对上面相应几何规划师的基诺动力学改编。 快速探索随机树 （RRT） 稀疏稳定RRT SST 是 RRT 的渐近接近最优增量版本。 膨胀空间树 （EST） 通过内外细胞探索（KPIECE）进行Kinodynamic规划 顾名思义，基于控件的KPIECE版本首先出现，几何版本是从中派生出来的。 路径导向细分树 （PDST） 基于控制的PDST版本实际上出现在几何版本之前。鉴于基于控件的版本，也很容易实现几何版本。 Syclop，一个元规划器，在较低级别使用其他规划器 Syclop 是一个元规划器，它将通过状态空间分解计算的高级指南与低级规划算法相结合。低级规划人员所做的进度将反馈给高级规划员，高级规划师使用此信息来更新指南。Syclop 有两种不同版本： Syclop使用RRT作为低级规划器 Syclop 使用 EST 作为低级规划器 线性时态逻辑规划器 （LTLPlanner） LTLPlanner 为运动规划问题找到解决方案，其中目标由线性时态逻辑 （LTL） 规范指定。 OMPL 如何选择基于控件的计划员如果使用 ompl::control::SimpleSetup 类（强烈推荐）来定义和解决运动规划问题，则 OMPL 将自动选择适当的规划器（除非您明确指定了一个）。如果状态空间具有默认投影（如果使用任何内置状态空间，情况就是如此），则它将使用 KPIECE。 该规划器已被证明在许多现实世界的运动规划问题上都能很好地工作，这就是为什么它是默认选择的原因。如果状态空间没有默认投影，则将 使用 RRT 。请注意，没有基于双向控制的规划器，因为我们不假设有一个转向功能可以精确地连接两个状态 _exactly_。 基于多层次的规划器为了解决涉及高维状态空间的问题，我们通常可以使用多级抽象来简化状态空间，从而使专门的规划者能够更快地找到解决方案。此类中的规划器支持状态空间序列，可用于具有几何和动态约束的状态空间。有指南 guide， 教程 和 演示 形式的大量文档。 快速探索随机商空间树 （QRRT） RRT的推广，以在不同的抽象级别上进行规划。 快速交货率* QRRT 的渐近最优版本 商空间路线图规划器 （QMP） PRM的泛化，用于在不同的抽象级别上进行规划。 QMP* QMP 的渐近最优版本 稀商空间路线图规划器 （SPQR）* SPARS向多层次规划的推广。","tags":["🦾ROS2"]},{"title":"URDF 导出资料（ROS2）","path":"/posts/711bc132/","content":"坐标系建立 如图所示按照DH坐标法建立各个坐标系 坐标系建立方法去复习机器人导论 建立完成可能会很乱 不用担心 插件安装和使用插件下载地址 经测试 1.6.1支持 solidworks 2022 sp5（实验室当前使用的版本） warning: 插件要在装配体里面才有反应 插件使用打开插件 base_link normal_link 其中关节类型如下 关节类型 描述 continuous 旋转关节，可以围绕单轴无限旋转 revolute 旋转关节，类似于continuous,.但是有旋转的角度极限 一定要设置上下限不然默认为0 prismatic 滑动关节，沿某一轴线移动的关节，带有位置极限 plannar 平面关节，允许在平面正交方向上平移或者旋转 floating 浮动关节，允许进行平移、旋转运动 fixed 固定关节，不允许运动的特殊关节 设置完成后单击导出按钮 导出即可 注意导出名即为ros中的包名，勿乱写 URDF 测试CoppeliaSim Edu 导入URDF 简单拖动旋转测试一下 URDF 文件包修改修改CMakelist.txt根据自己的情况修改 1234567cmake_minimum_required(VERSION 3.10.2)project(moveit_resources_fanuc_description) # 修改为自己的包名find_package(ament_cmake REQUIRED)ament_package()install(DIRECTORY meshes urdf DESTINATION share/$&#123;PROJECT_NAME&#125;) 修改package.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot;?&gt;&lt;package format=&quot;3&quot;&gt; &lt;!-- # 根据内容修改 --&gt; &lt;name&gt;moveit_resources_panda_description&lt;/name&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;description&gt;panda Resources used for MoveIt testing&lt;/description&gt; &lt;author email=&quot;isucan@willowgarage.edu&quot;&gt;Ioan Sucan&lt;/author&gt; &lt;author email=&quot;acorn@willowgarage.edu&quot;&gt;Acorn Pooley&lt;/author&gt; &lt;maintainer email=&quot;dave@dav.ee&quot;&gt;Dave Coleman&lt;/maintainer&gt; &lt;license&gt;BSD&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt;&lt;/package&gt; 编译包将包放入 ros2 或者 moveit2 工作空间中 1colcon build --packages-select moveit_resources_fanuc_description # 修改为自己的包名 MoveIt Setup Assistant 配置1234567# 激活ros2环境source /opt/ros/foxy/setup.bash# 激活moveit环境source ~/moveit2_ws/install/setup.bash # 刚才编译包的路径# 启动moveit MoveIt Setup Assistantros2 launch moveit_setup_assistant setup_assistant.launch.py 剩下的就参照官网文档 演示12# 运行演示ros2 launch panda_moveit_config demo.launch.py # 修改为自己的包名 其他我在导出复杂模型时遇到一些问题，可能是插件的问题，导出的模型有些问题，但是简单模型没有问题 经过CoppeliaSim Edu导入再导出，可以解决这个问题（记得修改urdf内的文件路径）","tags":["🦾ROS2"]},{"title":"旭日x3PI的开发日常","path":"/posts/5ecf4bea/","content":"常用命令123456789101112131415161718hrut_somstatus # 用于实时查询温度传感器读数及 CPU/BPU 频率实时信息echo performance &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor # CPU 频率固定在最高值:sudo apt update # 更新软件源sudo apt full-upgrade # 更新系统sudo nmcli device wifi rescan # 扫描wifisudo nmcli device wifi list # 列出wifisudo wifi_connect &quot;SSID&quot; &quot;PASSWD&quot; # 连接wifi wifi支持开热点 具体看 https://developer.horizon.ai/api/v1/fileData/documents_pi/System_Configuration/System_Configuration.html#id2 QT相关QT 安装 1sudo apt install qt5-default QT Creator 安装 1sudo apt install qtcreator 第三方包 串口 sudo apt install libqt5serialport5-dev 蓝牙 sudo apt-get install libkf5bluezqt-dev # 如果不行再尝试这个 sudo apt-get install libbluetooth-dev 截图 sudo apt-get install xfce4-screenshooter # 安装后键盘上面的 prtsc 按键就可以用了 录屏 sudo apt-get install kazam # 找应用即可其他包类似 可以用 apt search 搜索 蓝牙蓝牙连接嵌入式设备 12# 先配对然后连接sudo rfcomm connect hci0 (macaddress) ros 修复ROS2使用zsh无法用tab补全 ros2 指令的相关问题 1sudo apt install python3-argcomplete python3-colcon-common-extensions 然后，在.zshrc里面添加如下语句， 123456source /usr/share/colcon_cd/function/colcon_cd.shexport _colcon_cd_root=/opt/ros/foxy/source /usr/share/colcon_argcomplete/hook/colcon-argcomplete.zsheval &quot;$(register-python-argcomplete3 ros2)&quot;eval &quot;$(register-python-argcomplete3 colcon)&quot; 后记看着内容不多，但在搜索引擎里面找这些废了不少功夫，所以就写了这个，方便自己也方便别人。","tags":["X3PI"]},{"title":"QtCreator 一键打包你的APP","path":"/posts/ca763a9f/","content":"打开这个 添加工具 添加外部程序 修改如下内容 执行挡： powershell 参数（一行）： 12# qt Creator 8 以上版本 其他版本请根据最下面的提示修改md %&#123;ActiveProject:Path&#125;/package/ ; copy %&#123;ActiveProject:RunConfig:Executable:FilePath&#125; %&#123;ActiveProject:Path&#125;/package/%&#123;ActiveProject:RunConfig:Executable:FileName&#125; ; windeployqt %&#123;ActiveProject:Path&#125;/package/%&#123;ActiveProject:RunConfig:Executable:FileName&#125; Base environment 改为 Current build environment 双击可以重命名 其他保持默认即可 使用 (可选)将编译模式改为release 单击运行即可 运行后可以看到下图即为成功 打开项目所在目录 package 文件夹即为打包后的文件夹 如果使用了Git 不要忘记把package文件夹加入到忽略列表中 其他 qt Creator 版本单击红色方框后 单击右侧环境变量按钮 将 %{ActiveProject:Path} %{ActiveProject:RunConfig:Executable:FilePath} %{ActiveProject:RunConfig:Executable:FileName} 替换为对应的环境变量即可 如 4 版本的qt Creator 12# qt Creator 4 版本md %&#123;CurrentProject:Path&#125;/package/ ; copy %&#123;CurrentRun:Executable:FilePath&#125; %&#123;CurrentProject:Path&#125;/package/%&#123;CurrentRun:Executable:FileName&#125; ; windeployqt %&#123;CurrentProject:Path&#125;/package/%&#123;CurrentRun:Executable:FileName&#125;","tags":["😄QT"]},{"title":"leetcode 刷题记录（倒序）","path":"/posts/d444c6c7/","content":"15. 三数之和复制粘贴 25. K 个一组翻转链表复制粘贴 215. 数组中的第K个最大元素复制粘贴 LRU 缓存机制提交记录是先去b站看了解析视频然后自己写的，很多cpp的内容还是不熟悉，要继续。 状态 日期 语言 时间 空间 优化 通过 2023.10.10 C++ 372 ms 161.7 MB 官方题解 通过 2023.10.10 C++ 372 ms 161.4 MB ai 优化 通过 2023.10.10 C++ 476 ms 170.7 MB 通过 2023.10.10 C++ 488 ms 170.8 MB 超出时间限制 2023.10.10 C++ N&#x2F;A N&#x2F;A 超出时间限制 2023.10.10 C++ N&#x2F;A N&#x2F;A 执行出错 2023.10.09 C++ N&#x2F;A N&#x2F;A 执行出错 2023.10.09 C++ N&#x2F;A N&#x2F;A 自己的最终代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class LRUCache &#123;public: LRUCache (int capacity) &#123; __cap = capacity; &#125; int get (int key) &#123; //key = 0; if (hashmap.find (key) == hashmap.end ())&#123; // 没找到 return -1; &#125; else &#123; // 添加 key_value kv; kv.key = key; kv.value = hashmap [key]-&gt;value; value_list.erase (hashmap [key]); value_list.push_front (kv); hashmap [key] = value_list.begin (); return kv.value; &#125; return key; &#125; void put (int key, int value) &#123; if (hashmap.find (key) == hashmap.end ())&#123; // 没找到 // 满了吗？ if (__cap == hashmap.size ())&#123; hashmap.erase ( value_list.back ().key); value_list.pop_back (); &#125; // 添加 key_value kv; kv.key = key; kv.value = value; value_list.push_front ( kv); hashmap [key] = value_list.begin (); &#125; else &#123; // 找到了 // 删除并添加到头 value_list.erase (hashmap [key]); // 添加 key_value kv; kv.key = key; kv.value = value; value_list.push_front ( kv); hashmap [key] = value_list.begin (); &#125; &#125;private: int __cap; struct key_value &#123; int key; int value; bool operator==(const key_value&amp; kv)&#123; return key == kv.key; &#125; &#125;; map&lt;int, list&lt;key_value&gt;::iterator&gt; hashmap; list&lt;key_value&gt; value_list;&#125;; ai优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;class LRUCache &#123;public: LRUCache (int capacity) : capacity (capacity) &#123; &#125; int get (int key) &#123; if (cache_map.find (key) == cache_map.end ()) &#123; return -1; // 未找到 &#125; else &#123; // 将键值对移到链表头部表示最近使用 moveToFront (key); return cache_map [key]-&gt;second; &#125; &#125; void put (int key, int value) &#123; if (cache_map.find (key) == cache_map.end ()) &#123; if (cache_map.size () &gt;= capacity) &#123; // 缓存已满，删除最久未使用的项目 int lru_key = lru_list.back ().first; cache_map.erase (lru_key); lru_list.pop_back (); &#125; // 添加新项目到链表头部 lru_list.push_front (std::make_pair (key, value)); cache_map [key] = lru_list.begin (); &#125; else &#123; // 更新已存在的键值对的值，然后移到链表头部表示最近使用 cache_map [key]-&gt;second = value; moveToFront (key); &#125; &#125;private: int capacity; std::unordered_map&lt;int, std::list&lt;std::pair&lt;int, int&gt;&gt;::iterator&gt; cache_map; std::list&lt;std::pair&lt;int, int&gt;&gt; lru_list; // 将键值对移到链表头部 void moveToFront (int key) &#123; auto it = cache_map [key]; lru_list.splice (lru_list.begin (), lru_list, it); cache_map [key] = lru_list.begin (); &#125;&#125;; 206. 反转链表看了下提交记录，应该是复制粘贴，主要是cpp不熟，改天重写一遍 这里就记录一下官方答案吧 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return ret; &#125;&#125;; 3 无重复字符的最长子串独立编写 代码1234567891011121314151617181920212223int lengthOfLongestSubstring(string s)&#123; string temp; int ftemp = 0; for(int i = s.length(); i &gt; 0; i--) &#123; if (temp.find(s[s.length() - i]) &gt; temp.length()) // 无重复 temp.find(s[s.length() - i]) == -1 但会很大 所以 &#123; // 无重复 temp.push_back(s[s.length() - i]); ftemp = temp.length() &gt; ftemp ? temp.length() : ftemp; &#125; else &#123; // 有重复 i += (temp.length() - temp.find(s[s.length() - i]) - 1); temp.clear(); temp.push_back(s[s.length() - i]); ftemp = temp.length() &gt; ftemp ? temp.length() : ftemp; &#125; &#125; return ftemp;&#125; 使用到的函数1234string::find(char c) // 返回c在string中的位置 无则返回string::nposstring::length() // 返回string的长度string::push_back(char c) // 在string的末尾添加cstring::clear() // 清空string 思路刚开始看错了题 做完去看评论 发现这个题的思路是滑动窗口 然鹅我不知道那是什么东东 只是大概理解字面意思 这道题主要用到思路是：滑动窗口 什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要把队列的左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 时间复杂度：O(n)O(n)O(n) 作者：powcai链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/3982/hua-dong-chuang-kou-by-powcai/ 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结c++ 很多特性还不会用 要继续学习","tags":["😄leetcode"]},{"title":"旭日 x3PI RealSense人体关键点识别","path":"/posts/6306f887/","content":"起因简单介绍一下我的目标 获取部分人体关键点的空间坐标 控制双臂机器人进行拥抱 首次尝试2022.11 开始做识别部分的内容，开始挑选硬件这是当时小组会的PPT X3就不用多说了 非常强大 初次接触人体关键点识别刚开始是拿了一个普通的USB摄像头进行识别，但是摄像头的输出像素格式是YUYV，当时关键点识别还只能用mjpeg的USB摄像头或者MIPI的摄像头，于是乎买了官方的MIPI进行尝试 效果确实不错，但是我不光要关键点的二维坐标，还要三维坐标，这里就需要深度相机了 实验室刚好有一台Intel的深度相机435，折腾了好久，因为并不熟悉这些东西，最后也没折腾出来 仔细想想，机器人头上装俩摄像头就很奇怪，想想就脑壳痛。 当时问群里的开发人员，他们说这个相机暂时不支持，后面可能会支持。其实当时已经有codec模块了，但是好像没有文档，反正是没找到。 所以转去了用笔记本做主控，但是因为一些结构上的原因我又回来了 其实也就花了两天的时间，比我移植ALPHAPOSE快多了 RealSense 人体关键点识别先讲一下整体思路 Realsense node发布的是rgb格式的图像，使用hobot_codec把rgb转成jpeg jpeg转nv12（rgb8好像不能转nv12 我也不知道为什么 程序说的）,最后nv12送给mono2d_body_detection 就可以了 安装realsense2 SDK设置网络环境这里因为网络原因需要设置一下GITHUB的代理的host，不然无法访问。 打开https://www.ipaddress.com/ 输入raw.githubusercontent.com 查询IP地址 找不到就一直往下滑，直到找到 把找到的ip按这个格式保存好 12345140.82.112.3 github.com185.199.108.133 raw.githubusercontent.com185.199.109.133 raw.githubusercontent.com185.199.110.133 raw.githubusercontent.com185.199.111.133 raw.githubusercontent.com 编辑hosts文件 123456sudo vim /etc/hosts# 重启网络/etc/init.d/networking restart # ping一下试试ping raw.githubusercontent.com 添加ROS apt源1234567sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasesudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/nullsudo apt update 安装Realsense SDK这一步因为网络原因可能会比较漫长，耐心等待，不如起来活动活动吃个饭。 1234567# 显示ROS当前版本，如果显示为空，请source /opt/tros/setup.bashecho $ROS_DISTRO # 安装RealSense SDKsudo apt-get install ros-$ROS_DISTRO-librealsense2* -y # 安装RealSense ros wrappersudo apt-get install ros-$ROS_DISTRO-realsense2-camera -ysudo apt-get install ros-$ROS_DISTRO-realsense2-description -y 建立软连接123cd /opt/tros## 使用/opt/tros目录下的create_soft_link.py创建ROS package至tros.b的软连接sudo python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros/ 到这里Realsense2 SDK就安装完成了 运行测试运行前要先： source /opt/ros/foxy/setup.bash 然后： source /opt/tros/setup.bash 运行程序： ros2 launch realsense2_camera rs_launch.py depth_module.profile:=640x480x15 这里要感谢一下王卓大佬 运行这里我写了个脚本，保存为.sh文件，然后运行就好了，当然你也可以一步步运行看看哪里出错了 12345678910111213141516171819202122232425echo &#x27;设置ros2环境变量&#x27;source /opt/ros/foxy/setup.bashsource /opt/tros/setup.bashsleep 5echo &#x27;启动ros2 realsense 节点&#x27;ros2 launch realsense2_camera rs_launch.py depth_module.profile:=640x480x15 &amp;sleep 5echo &#x27;启动ros2 rgb8 2 jpeg 节点&#x27;ros2 run hobot_codec hobot_codec_republish --ros-args -p channel:=0 -p in_mode:=ros -p in_format:=rgb8 -p out_mode:=ros -p out_format:=jpeg -p sub_topic:=/camera/color/image_raw -p pub_topic:=/image_jpeg --log-level error &amp;sleep 5echo &#x27;启动ros2 jpeg 2 nv12 节点&#x27;ros2 run hobot_codec hobot_codec_republish --ros-args -p channel:=1 -p in_mode:=ros -p in_format:=jpeg -p out_mode:=shared_mem -p out_format:=nv12 -p sub_topic:=/image_jpeg -p pub_topic:=/hbmem_img --log-level error &amp;sleep 5echo &#x27;启动ros2 websocket 节点&#x27;ros2 run websocket websocket --ros-args -p image_topic:=/image_jpeg -p image_type:=mjpeg -p smart_topic:=/hobot_mono2d_body_detection --log-level error &amp;sleep 5echo &#x27;启动ros2 mono2d_body_detection 节点&#x27;ros2 run mono2d_body_detection mono2d_body_detection --log-level error &amp;sleep 5echo &#x27;启动ros2 websocket 节点&#x27;ros2 launch websocket hobot_websocket.launch.py &amp; 需要注意的是 rgb8(ros) -&gt; jpeg(ros) -&gt; nv12(shared_mem) -&gt; mono2d_body_detection 参考链接安装realsense SDK参考：https://c-gitlab.horizon.ai/HHP/box/hobot_slam/orb_slam3 软链接参考：https://developer.horizon.ai/api/v1/fileData/TogetherROS/quick_start/install_use_ros_pkg.html codec参考：https://c-gitlab.horizon.ai/HHP/box/hobot_codec 注如果有哪里有问题，包括我的问题和你运行的问题，欢迎评论指出，我会及时修改 这里还要感谢一下王卓大佬 关于realsense 的文档藏的也太深了。。。 To Do深度信息获取与计算表情视频切换播放","tags":["X3PI"]},{"title":"MoneyProgress_win","path":"/posts/3ouvu5p/","content":"起因前段时间分享了一个MoneyProgress的Mac软件,一直有人在论坛发帖问有没有win版的,恰好最近在看Qt,于是就有了这个项目. 写这个贴子的目的是为了记录一下开发过程,以及遇到的问题. 以后可以拿它做参考,也可以给有需要的人提供一些帮助. MAC版的项目地址: MoneyProgressWIN版的项目地址: MoneyProgress_win 程序很大程度参考了原作者的UI设计,这里再次感谢原作者. 开发环境 Windows 10 20H2(这个不是很重要) Qt 5.15 with Mingw(这个很重要) 开发过程这块看我的commit记录就行了,虽然有点乱,但是基本上都是有用的. 这里只记录一些比较重要的问题,其他的问题可以参考Qt官方文档 多看文档,多看文档,多看文档. 问题1: 图片过大原作者的图片都是png格式,大小足足有3.27MB,分辨率为1024x1024,应该是自己画的吧. 刚开始导入图片设置为label设置样式表background-image: url(:/img/avatar.png); 是这样的: 可以看到图片很大,很奇怪, 解决办法: 设置为border-image: url(:/img/avatar.png); 这样它就会自动缩放了.可以通过设置label的width和height来控制图片的大小. 问题2: 无法获取到正确的屏幕分辨率这个问题是论坛上有人提出来的,我也遇到了. 原代码为: 12345// 这里省略了一些代码// 获取屏幕分辨率高度QApplication::desktop()-&gt;width(); 实际获取的不一定就是当前屏幕的分辨率,有时候会获取到错误的值.比如你有多块屏幕,它会获取到所有屏幕的分辨率的和.就很离谱.这就会导致我们的程序在不同的屏幕上显示的效果不一样.任务栏的弹窗就奇奇怪怪的.甚至看不到. 解决办法: 1234// 这里省略了一些代码QApplication::screenAt(QCursor().pos())-&gt;geometry().width() 意为获取鼠标所在屏幕的分辨率宽度.非常ok. 问题3: 文本无法正常更新问题代码: 因为我想实现每次点击任务栏图标都会弹出一个弹窗,显示当前的挣钱进度,所以我在MoneyProgress类中添加了一个IconMessage类的对象(一个小widget),并且在MoneyProgress类中添加了一个update函数,用来更新弹窗中的文本.同时update还要负责更新主窗口中的文本.所以就有了如下代码 1234567891011121314151617181920void MoneyProgress::update()&#123; // 这里省略了一些代码 // 判断两个界面是否可见 if (this-&gt;isVisible()) &#123; ui-&gt;labelMoneyNow-&gt;setText(&quot;您当前已经挣了&quot;+QString::number(moneyday*progress/1000,&#x27;f&#x27;,1)+&quot;元;&quot;); ui-&gt;labelDay-&gt;setText(&quot;您一月工作&quot; + QString::number(days) + &quot;天;&quot;); ui-&gt;labelMoneyDay-&gt;setText(&quot;您一天能挣&quot; + QString::number(moneyday, &#x27;f&#x27;, 1) + &quot;元;&quot;); ui-&gt;labelHourDay-&gt;setText(&quot;您一天工作&quot; + QString::number(hours, &#x27;f&#x27;, 1) + &quot;小时;&quot;); ui-&gt;labelMoneySecond-&gt;setText(&quot;您一秒钟能挣&quot; + QString::number(moneysecond, &#x27;f&#x27;, 6) + &quot;元;&quot;); &#125; if (iconmessage.isVisible()) &#123; iconmessage.update(progress, moneyday); qDebug() &lt;&lt; progress; &#125;&#125; 可以看到大致思路就是判断两个界面是否可见,如果可见就更新文本.但是任务栏那个小窗口的文本无法更新,调试发现了一个低级错误 12345update(); //错误的写法iconmessage.show();// update(); 把update()放在这里就可以更新了 确实很低级 问题4: QSettings 无效这个问题是在保存时间的时候遇到的,我想把设置保存到QSettings里面,但是发现无论怎么设置都无效.在网上逛了半天,发现是因为QSettings只能在构造函数和析构函数中使用,不能在其他函数中使用. 问题代码: 12345678910//原本设计的是每次设置改变就保存一次,但是发现无效void MoneyProgress::on_timeSleepdown_userTimeChanged(const QTime &amp;time)&#123; // 这里省略了一些代码 settings 是一个QSettings对象,在.h文件中定义 settings.setValue(&quot;sleepDown&quot;, sleepDown); // 保存设置&#125; 解决办法: 将QSettings的保存设置放到析构函数中,这样就可以正常使用了. 12345678910111213141516171819202122MoneyProgress::~MoneyProgress()&#123; QSettings settings(&quot;MuYin&quot;, &quot;MoneyProgress_win&quot;); // 保存设置 settings.setValue(&quot;money&quot;, money); settings.setValue(&quot;days&quot;, days); settings.setValue(&quot;workUp&quot;, workUp); settings.setValue(&quot;workDown&quot;, workDown); settings.setValue(&quot;sleepUp&quot;, sleepUp); settings.setValue(&quot;sleepDown&quot;, sleepDown); // settings.setValue(&quot;geometry&quot;, this-&gt;saveGeometry()); // settings.setValue(&quot;windowState&quot;, this-&gt;saveState()); // 保存设置 settings.sync(); delete ui;&#125; 问题5: QSS样式表不会用因为我设置了标题栏隐藏 this-&gt;setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint); // 隐藏标题栏 所以一直弄不出来borde的样式,最后发现改centralwidget的border属性就可以了. 问题代码: 123456QWidget &#123; background-color: rgb(255, 255, 255); border-width: 3px; border-color: rgba(255, 216, 58, 225); border-radius: 15px;&#125; 解决方法 12345678910QWidget &#123; background-color: rgb(255, 255, 255); border-color: rgba(255, 216, 58, 225); border-radius: 15px;&#125;QWidget#centralwidget &#123; background-color: rgb(255, 255, 255); border: 3px solid #ffee6f; /* border-color: rgba(255, 216, 58, 225); */&#125; css还是不太了解,回头需要好好学习一下. 问题6: 程序整体缩放问题引用网友的话: Qt下高分屏的问题，几乎是一场灾难。希望未来 Qt 能有更好的解决方案。 解决方法: 添加 qt/etc/qt.conf文件,注意这是在qrc文件中的路径,它的完整路径是qrc:/qt/etc/qt.conf,网上说一定不要弄错文件内容的意思为不使用QT的缩放功能,而是使用系统的缩放功能 123[Platforms]WindowsArguments = dpiawareness=0 具体看这个commit 问题7: QtCreator 无法Debug将build模式从release改为debug就可以了……………………………. 总结项目不大,时间也不算长,大概两三个晚上的样子,但是在这个过程中学到了很多东西,比如说QSettings的使用,QSS的使用,QTimer的使用,QApplication::screenAt(QCursor().pos())-&gt;geometry().width()的使用,以及一些小技巧,比如说QSettings只能在构造函数和析构函数中使用,QSS的border属性要写在centralwidget上,QTimer的start函数可以传入一个参数,表示延迟多久开始计时,QApplication::screenAt(QCursor().pos())-&gt;geometry().width()可以获取鼠标所在屏幕的分辨率宽度等等. 最后希望大家能够多多支持,如果有什么问题,欢迎指正,可以在评论区留言,我会尽快回复的.","tags":["⌨️Qt"],"categories":["💻Code"]},{"title":"ROS2自定义消息使用记录","path":"/posts/2llqu4i/","content":"起因最近在做人体姿态估计的项目,需要用到ROS2,但是ROS2的消息类型不够用,所以需要自定义消息类型,这里记录一下自定义消息类型的过程. 使用的工具如下 ROS2 Humble VSCode Alphapose 之前跟着官方文档做过一次,但是学会了,但又没学会.这次是真的要用,反而出问题了. 自定义消息类型之前以为每个包里面都可以自定义消息,但是想多了,需要独立的包来存放自定义消息. 创建包1ros2 pkg create --build-type ament_python --node-name people_msgs people_msgs 创建消息1234# Point.msgfloat32 xfloat32 yfloat32 z 12# People.msg 以为人体关键点是26个,所以这里就写26个,但是后面发现出了问题Point[26] keypoints 记住这个26,问题就出在这里. 12# PeopleArray.msgPeople[] people 编译1colcon build --packages-select people_msgs 使用1source install/setup.bash 使用自定义消息创建包1ros2 pkg create --build-type ament_python --node-name people_sub people_sub 编写代码1234567891011121314151617181920212223242526272829303132333435363738394041# people_sub.pyimport rclpyfrom rclpy.node import Nodefrom people_msgs.msg import PeopleArrayclass PeopleSub(Node): def __init__(self): super().__init__(&#x27;people_sub&#x27;) self.sub = self.create_subscription(PeopleArray, &#x27;people&#x27;, self.people_callback, 10) def people_callback(self, msg): self.get_logger().info(&#x27;I heard: %s&#x27; % msg) def getnode(self): # 假如说这是识别后处理关键点的函数 peoplearray = PeopleArray() for i in peoplelist: # 假如说这是识别后所有人的列表 people = People() # people.keypoints.clear() # 这里是关键,不然会出问题 for j in i: #每个人身上的关键点 point = Point() point.x = j[0] point.y = j[1] point.z = j[2] people.keypoints.append(point) peoplearray.people.append(people) return peoplearray return selfdef main(args=None): rclpy.init(args=args) people_sub = PeopleSub() rclpy.spin(people_sub) people_sub.destroy_node() rclpy.shutdown()if __name__ == &#x27;__main__&#x27;: main() 编译1colcon build --packages-select people_sub 使用12source install/setup.bashros2 run people_sub people_sub 问题我使用自定义消息进行接收,发现接收到的消息是空的,后来发现是因为我在创建消息的时候,它会默认创建一个空的消息(26个数据都是0),所以我在创建消息的时候,需要先清空消息,然后再添加数据. 感悟果然实践是检验真理的唯一标准 这次的问题是单步调试出来的,调试之前处理了python路径的问题,不然无法使用VSCode调试. python扩展路径问题12# 1.通过脚本查看python路径python -c &quot;import sys; print(sys.path)&quot; 设置环境vscode路径 Python扩展 设置 -&gt; Pythoninterpreter Path -&gt; (&#x2F;usr&#x2F;bin&#x2F;python3)换成上一步的路径即可解决 还有个问题我问了下GPT ROS2使用自定义Python解释器要指定ROS 2使用的Python解释器，您可以设置环境变量PYTHON_EXECUTABLE，将其设置为要使用的Python解释器的路径。例如，假设您的自定义Python解释器位于&#x2F;path&#x2F;to&#x2F;my&#x2F;python，则可以使用以下命令在终端中设置环境变量： export PYTHON_EXECUTABLE=/path/to/my/python 设置环境变量后，ROS 2将使用指定的Python解释器。您可以在启动ROS 2节点时验证Python解释器是否正确设置，例如： ros2 run my_package my_node --ros-args --log-level debug 这将在终端输出ROS 2节点的日志信息，其中包括使用的Python解释器。如果您看到的输出中包含您自定义的Python解释器路径，则表示ROS 2正在使用指定的Python解释器。 注意，设置自定义Python解释器可能会导致ROS 2某些功能无法正常工作，因为ROS 2可能依赖于特定版本的Python和Python库。如果您遇到问题，请尝试使用ROS 2默认的Python解释器，或者确保您的自定义Python解释器与ROS 2所需的Python版本和库兼容。","tags":["🦾ROS2"]},{"title":"FreeRTOS","path":"/posts/1rvt88k/","content":"大部分内容都为摘抄其实已经看过很多遍，但一直没用过。 内存管理task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。 FreeRTOS的5种内存管理方法 文件 优点 缺点 heap_1.c 分配简单，时间确定 只分配、不回收 heap_2.c 动态分配、最佳匹配 碎片、时间不定 heap_3.c 调用标准库函数 速度慢、时间不定 heap_4.c 相邻空闲内存可合并 可解决碎片问题、时间不定 heap_5.c 在heap_4基础上支持分隔的内存块 可解决碎片问题、时间不定 heap_1.c 实现最简单 没有碎片问题 一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1 heap_2.c 弃用Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。 heap_3.cHeap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。 C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。 heap_4.c跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。 Heap_4使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。 heap_5.cHeap_5分配内存、释放内存的算法跟Heap_4是一样的。 相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。 在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。 既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大： 在使用pvPortMalloc之前，必须先指定内存块的信息 使用vPortDefineHeapRegions来指定这些信息 Heap相关的函数 函数 说明 void *pvPortMalloc( size_t xWantedSize ) | 分配内存void vPortFree( void *pv ) | 释放内存size_t xPortGetFreeHeapSize( void ) | 获取剩余内存size_t xPortGetMinimumEverFreeHeapSize( void ) | 获取最小剩余内存 malloc失败的钩子函数 在pvPortMalloc函数内部 123456789101112131415void * pvPortMalloc( size_t xWantedSize )&#123; ...... #if ( configUSE_MALLOC_FAILED_HOOK == 1 ) &#123; if( pvReturn == NULL ) &#123; extern void vApplicationMallocFailedHook( void ); vApplicationMallocFailedHook(); &#125; &#125; #endif return pvReturn; &#125; 所以，如果想使用这个钩子函数： 在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1 提供vApplicationMallocFailedHook函数 pvPortMalloc失败时，才会调用此函数 任务管理在FreeRTOS中，任务就是一个函数，原型如下： 1void ATaskFunction( void *pvParameters ); 要注意的是： 这个函数不能返回 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数 函数内部，尽量使用局部变量： 每个任务都有自己的栈 每个任务运行这个函数时 任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里 不同任务的局部变量，有自己的副本 函数使用全局变量、静态变量的话 只有一个副本：多个任务使用的是同一个副本 要防止冲突(后续会讲) 创建任务创建任务时使用的函数如下： 123456BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数 const char * const pcName, // 任务的名字 const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节 void * const pvParameters, // 调用任务函数时传入的参数 UBaseType_t uxPriority, // 优先级 TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务 参数说明： 参数 描述 pvTaskCode 函数指针，可以简单地认为任务就是一个C函数。它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)” pcName 任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。长度为：configMAX_TASK_NAME_LEN usStackDepth 每个任务都有自己的栈，这里指定栈大小。单位是word，比如传入100，表示栈大小为100 word，也就是400字节。最大值为uint16_t的最大值。怎么确定栈的大小，并不容易，很多时候是估计。精确的办法是看反汇编码。 pvParameters 调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters) uxPriority 优先级范围：0~(configMAX_PRIORITIES – 1)数值越小优先级越低，如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1) pxCreatedTask 用来保存xTaskCreate的输出结果：task handle。以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。如果不想使用该handle，可以传入NULL。 返回值 成功：pdPASS；失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)注意：文档里都说失败时返回值是pdFAIL，这不对。pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。 任务的删除删除任务时使用的函数如下： 1void vTaskDelete( TaskHandle_t xTaskToDelete ); 参数说明： 参数 描述 pvTaskCode 任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。也可传入NULL，这表示删除自己。 怎么删除任务？举个不好的例子： 自杀：vTaskDelete(NULL) 被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄 杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄 任务优先级和Tick任务优先级在上个示例中我们体验过优先级的使用：高优先级的任务先运行。 优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。 FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。 通用方法使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。 架构相关的优化的方法架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。使用这种方法时，configMAX_PRIORITIES的取值不能超过32。configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。 在学习调度方法之前，你只要初略地知道： FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行 对于相同优先级的、可运行的任务，轮流执行 这无需记忆，就像我们举的例子： 厨房着火了，当然优先灭火 喂饭、回复信息同样重要，轮流做 Tick对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。 任务状态以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。 对于非运行的状态，还可以继续细分，比如前面的FreeRTOS_04_task_priority中： Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行 Task3运行期间，Task1、Task2也处于非运行状态，但是它们随时可以运行 这两种”非运行”状态就不一样，可以细分为： 阻塞状态(Blocked) 暂停状态(Suspended) 就绪状态(Ready) Delay函数有两个Delay函数： vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态 vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。 空闲任务及其钩子函数为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用vTaskStartScheduler() 函数来创建、启动调度器时，这个函数内部会创建空闲任务： 空闲任务优先级为0：它不能阻碍用户任务运行 空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞 空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。 我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些： 执行一些低优先级的、后台的、需要连续执行的函数 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。 空闲任务的钩子函数的限制： 不能导致空闲任务进入阻塞状态、暂停状态 如果你会使用vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。 调度算法 配置项 A B C D E configUSE_PREEMPTION 1 1 1 1 0 configUSE_TIME_SLICING 1 1 0 0 x configIDLE_SHOULD_YIELD 1 0 1 0 x 说明 常用 很少用 很少用 很少用 几乎不用 注： A：可抢占+时间片轮转+空闲任务让步 B：可抢占+时间片轮转+空闲任务不让步 C：可抢占+非时间片轮转+空闲任务让步 D：可抢占+非时间片轮转+空闲任务不让步 E：合作调度 同步互斥与通信队列： 里面可以放任意数据，可以放多个数据 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据 事件组： 一个事件用一bit表示，1表示事件发生了，0表示事件没发生 可以用来表示事件、事件的组合发生了，不能传递数据 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒 信号量： 核心是”计数值” 任务、ISR释放信号量时让计数值加1 任务、ISR获得信号量时，让计数值减1 任务通知： 核心是任务的TCB里的数值 会被覆盖 发通知给谁？必须指定接收任务 只能由接收任务本身获取该通知 互斥量： 数值只有0或1 谁获得互斥量，就必须由谁释放同一个互斥量 队列队列(queue)可以用于”任务到任务”、”任务到中断”、”中断到任务”直接传输信息。 队列可以包含若干个数据：队列中有若干项，这被称为”长度”(length) 每个数据大小固定 创建队列时就要指定长度、数据大小 数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读 也可以强制写队列头部：覆盖头部数据 队列的特性传输数据的两种方法FreeRTOS使用拷贝值的方法，这更简单： 局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据 无需分配buffer来保存数据，队列中有buffer 局部变量可以马上再次使用 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据 如果数据实在太大，你还是可以使用队列传输它的地址 队列的空间有FreeRTOS内核分配，无需任务操心 对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。 队列阻塞访问只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。 任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。 某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。 既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？ 优先级最高的任务 如果大家的优先级相同，那等待时间最久的任务会进入就绪态 跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。 既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？ 优先级最高的任务 如果大家的优先级相同，那等待时间最久的任务会进入就绪态 队列函数使用队列的流程：创建队列、写队列、读队列、删除队列。 创建队列的创建有两种方法：动态分配内存、静态分配内存， 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配 函数原型如下： 1QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize ); 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 返回值 非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足 静态分配内存：xQueueCreateStatic，队列的内存要事先分配好 函数原型如下： 123456QueueHandle_t xQueueCreateStatic( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer ); 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 pucQueueStorageBuffer 如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组，此数组大小至少为”uxQueueLength * uxItemSize” pxQueueBuffer 必须执行一个StaticQueue_t结构体，用来保存队列的数据结构 返回值 非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为pxQueueBuffer为NULL 示例代码： 123456789101112131415161718192021// 示例代码 #define QUEUE_LENGTH 10 #define ITEM_SIZE sizeof( uint32_t ) // xQueueBuffer用来保存队列结构体 StaticQueue_t xQueueBuffer; // ucQueueStorage 用来保存队列的数据 // 大小为：队列长度 * 数据大小 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) &#123;\tQueueHandle_t xQueue1; // 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE\txQueue1 = xQueueCreateStatic( QUEUE_LENGTH, ITEM_SIZE, ucQueueStorage, &amp;xQueueBuffer ); &#125; 复位队列刚被创建时，里面没有数据；使用过程中可以调用xQueueReset()把队列恢复为初始状态，此函数原型为： 1234/* pxQueue : 复位哪个队列; * 返回值: pdPASS(必定成功) */BaseType_t xQueueReset( QueueHandle_t pxQueue); 删除删除队列的函数为vQueueDelete()，只能删除使用动态方法创建的队列，它会释放内存。原型如下： 1void vQueueDelete( QueueHandle_t xQueue ); 写队列可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 等同于xQueueSendToBack * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait */BaseType_t xQueueSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );/* * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait */BaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );/* * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞 */BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken );/* * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait */BaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );/* * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞 */BaseType_t xQueueSendToFrontFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); 这些函数用到的参数是类似的，统一说明如下： 参数 说明 xQueue 队列句柄，要写哪个队列 pvItemToQueue 数据指针，这个数据的值会被复制进队列，复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 如果队列满则无法写入新数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法写入数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写 返回值 pdPASS：数据成功写入了队列errQUEUE_FULL：写入失败，因为队列满了。 读队列使用xQueueReceive()函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下： 123456789BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait );BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken ); 参数说明如下： 参数 说明 xQueue 队列句柄，要读哪个队列 pvBuffer bufer指针，队列的数据会被复制到这个buffer复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 果队列空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 返回值 pdPASS：从队列读出数据入errQUEUE_EMPTY：读取失败，因为队列空了。 查询可以查询队列中有多少个数据、有多少空余空间。函数原型如下： 123456789/* * 返回队列中可用数据的个数 */UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );/* * 返回队列中可用空间的个数 */UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ); 覆盖&#x2F;偷看当队列长度为1时，可以使用xQueueOverwrite()或xQueueOverwriteFromISR()来覆盖数据。注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。函数原型如下： 123456789101112131415/* 覆盖队列 * xQueue: 写哪个队列 * pvItemToQueue: 数据地址 * 返回值: pdTRUE表示成功, pdFALSE表示失败 */BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); 如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是xQueuePeek()或xQueuePeekFromISR()。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。函数原型如下： 12345678910111213141516/* 偷看队列 * xQueue: 偷看哪个队列 * pvItemToQueue: 数据地址, 用来保存复制出来的数据 * xTicksToWait: 没有数据的话阻塞一会 * 返回值: pdTRUE表示成功, pdFALSE表示失败 */BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait );BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void *pvBuffer, ); 信号量前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。 有时候我们只需要传递状态，并不需要传递具体的信息，比如： 我的事做完了，通知一下你 卖包子了、卖包子了，做好了1个包子！做好了2个包子！做好了3个包子！ 这个停车位我占了，你们只能等着 在这种情况下我们可以使用信号量(semaphore)，它更节省内存。 信号量的常规操作两种信号量的对比信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。 差别列表如下： 二进制信号量 技术型信号量 被创建时初始值为0 被创建时初始值可以设定 其他操作是一样的 其他操作是一样的 信号量函数创建使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样： 二进制信号量 计数型信号量 动态创建 xSemaphoreCreateBinary计数值初始值为0 xSemaphoreCreateCounting vSemaphoreCreateBinary(过时了)计数值初始值为1 静态创建 xSemaphoreCreateBinaryStatic xSemaphoreCreateCountingStatic 创建二进制信号量的函数原型如下： 1234567891011/* 创建一个二进制信号量，返回它的句柄。 * 此函数内部会分配信号量结构体 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateBinary( void );/* 创建一个二进制信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer ); 创建计数型信号量的函数原型如下： 123456789101112131415161718/* 创建一个计数型信号量，返回它的句柄。 * 此函数内部会分配信号量结构体 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);/* 创建一个计数型信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * pxSemaphoreBuffer: StaticSemaphore_t结构体指针 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer ); 删除对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。 vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下： 1234/* * xSemaphore: 信号量句柄，你要删除哪个信号量 */void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); give&#x2F;take二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下： 在任务中使用 在ISR中使用 give xSemaphoreGive xSemaphoreGiveFromISR take xSemaphoreTake xSemaphoreTakeFromISR xSemaphoreGive的函数原型如下： 1BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore ); xSemaphoreGive函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，释放哪个信号量 返回值 pdTRUE表示成功,如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 pxHigherPriorityTaskWoken的函数原型如下： 1234BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); xSemaphoreGiveFromISR函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，释放哪个信号量 pxHigherPriorityTaskWoken 如果释放信号量导致更高优先级的任务变为了就绪态，则*pxHigherPriorityTaskWoken &#x3D; pdTRUE 返回值 pdTRUE表示成功,如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 xSemaphoreTake的函数原型如下： 1234BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait ); xSemaphoreTake函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，获取哪个信号量 xTicksToWait 如果无法马上获得信号量，阻塞一会：0：不阻塞，马上返回portMAX_DELAY: 一直阻塞直到成功其他值: 阻塞的Tick个数，可以使用pdMS_TO_TICKS()来指定阻塞时间为若干ms 返回值 pdTRUE表示成功 xSemaphoreTakeFromISR的函数原型如下： 1234BaseType_t xSemaphoreTakeFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); xSemaphoreTakeFromISR函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，获取哪个信号量 pxHigherPriorityTaskWoken 如果获取信号量导致更高优先级的任务变为了就绪态，则*pxHigherPriorityTaskWoken &#x3D; pdTRUE 返回值 pdTRUE表示成功 互斥量在多任务系统中，任务A正在使用某个资源，还没用完的情况下任务B也来使用的话，就可能导致问题。 比如对于串口，任务A正使用它来打印，在打印过程中任务B也来打印，客户看到的结果就是A、B的信息混杂在一起。 上述问题的解决方法是：任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。 互斥量也被称为互斥锁，使用过程如下： 互斥量初始值为1 任务A想访问临界资源，先获得并占有互斥量，然后开始访问 任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞 任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源 任务B使用完毕，释放互斥量 正常来说：在任务A占有互斥量的过程中，任务B、任务C等等，都无法释放互斥量。 但是FreeRTOS未实现这点：任务A占有互斥量的情况下，任务B也可释放互斥量。 函数创建互斥量是一种特殊的二进制信号量。 使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。 创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下： 1234567891011/* 创建一个互斥量，返回它的句柄。 * 此函数内部会分配互斥量结构体 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateMutex( void );/* 创建一个互斥量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer ); 要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义： 1#define configUSE_MUTEXES 1 其他函数要注意的是，互斥量不能在ISR中使用。 各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。 123456789101112131415161718192021222324/* * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量 */void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );/* 释放 */BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );/* 释放(ISR版本) */BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken );/* 获得 */BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );/* 获得(ISR版本) */xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); 事件组事件组可以简单地认为就是一个整数： 每一位表示一个事件 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下 这些位，值为1表示事件发生了，值为0表示事件没发生 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位 可以等待某一位、某些位中的任意一个，也可以等待多位 事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？ 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件 configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位 事件组的操作事件组和队列、信号量等不太一样，主要集中在2个地方： 唤醒谁？ 队列、信号量：事件发生时，只会唤醒一个任务 事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用 是否清除事件？ 队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了 事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件 以上图为列，事件组的常规操作如下： 先创建事件组 任务C、D等待事件： 等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。 得到事件时，要不要清除？可选择清除、不清除。 任务A、B产生事件：设置事件组里的某一位、某些位 事件组函数创建使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。 有两种创建方法：动态分配内存、静态分配内存。函数原型如下： 1234567891011/* 创建一个事件组，返回它的句柄。 * 此函数内部会分配事件组结构体 * 返回值: 返回句柄，非NULL表示成功 */EventGroupHandle_t xEventGroupCreate( void );/* 创建一个事件组，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ); 删除对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。 vEventGroupDelete可以用来删除事件组，函数原型如下： 1234/* * xEventGroup: 事件组句柄，你要删除哪个事件组 */void vEventGroupDelete( EventGroupHandle_t xEventGroup ) 设置事件可以设置事件组的某个位、某些位，使用的函数有2个： 在任务中使用xEventGroupSetBits() 在ISR中使用xEventGroupSetBitsFromISR() 有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。 函数原型如下： 12345678910111213141516171819202122/* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位? * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了) */EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );/* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位? * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有 * 返回值: pdPASS-成功, pdFALSE-失败 */BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t * pxHigherPriorityTaskWoken ); 值得注意的是，ISR中的函数，比如队列函数xQueueSendToBackFromISR、信号量函数xSemaphoreGiveFromISR，它们会唤醒某个任务，最多只会唤醒1个任务。 但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以xEventGroupSetBitsFromISR函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。 如果后台任务的优先级比当前被中断的任务优先级高，xEventGroupSetBitsFromISR会设置*pxHigherPriorityTaskWoken为pdTRUE。 如果daemon task成功地把队列数据发送给了后台任务，那么xEventGroupSetBitsFromISR的返回值就是pdPASS。 等待事件使用xEventGroupWaitBits来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。 函数原型如下： 12345EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ); 先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。 函数参数说明列表如下： 参数 说明 xEventGroup 等待哪个事件组？ uxBitsToWaitFor 等待哪些位？哪些位要被测试？ xWaitForAllBits 怎么测试？是”AND”还是”OR”？pdTRUE: 等待的位，全部为1;pdFALSE: 等待的位，某一个为1即可 xClearOnExit 函数提出前是否要清除事件？pdTRUE: 清除uxBitsToWaitFor指定的位pdFALSE: 不清除 xTicksToWait 如果期待的事件未发生，阻塞多久。可以设置为0：判断后即刻返回；可设置为portMAX_DELAY：一定等到成功才返回；可以设置为期望的Tick Count，一般用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 返回的是事件值，如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；如果是超时退出，返回的是超时时刻的事件值。 举例如下： 事件组的值 uxBitsToWaitFor xWaitForAllBits 说明 0100 0101 pdTRUE 任务期望bit0,bit2都为1，当前值只有bit2满足，任务进入阻塞态；当事件组中bit0,bit2都为1时退出阻塞态 0100 0110 pdFALSE 任务期望bit0,bit2某一个为1，当前值满足，所以任务成功退出 0100 0110 pdTRUE 任务期望bit1,bit2都为1，当前值不满足，任务进入阻塞态；当事件组中bit1,bit2都为1时退出阻塞态 你可以使用xEventGroupWaitBits()等待期望的事件，它发生之后再使用xEventGroupClearBits()来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。 可以使用设置xClearOnExit为pdTRUE，使得对事件组的测试、清零都在xEventGroupWaitBits()函数内部完成，这是一个原子操作。 同步点有一个事情需要多个任务协同，比如： 任务A：炒菜 任务B：买酒 任务C：摆台 A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭 使用xEventGroupSync()函数可以同步多个任务： 可以设置某位、某些位，表示自己做了什么事 可以等待某位、某些位，表示要等等其他任务 期望的时间发生后，xEventGroupSync()才会成功返回。 xEventGroupSync成功返回后，会清除事件 xEventGroupSync函数原型如下： 1234EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ); 参数列表如下： 参数 说明 xEventGroup 哪个事件组？ uxBitsToSet 要设置哪些事件？我完成了哪些事件？比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 uxBitsToWaitFor 等待那个位、哪些位？比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 xTicksToWait 如果期待的事件未发生，阻塞多久。可以设置为0：判断后即刻返回；可设置为portMAX_DELAY：一定等到成功才返回；可以设置为期望的Tick Count，一般用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 返回的是事件值，如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；如果是超时退出，返回的是超时时刻的事件值。 任务通知所谓”任务通知”，你可以反过来读”通知任务”。 使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”： 优势及限制任务通知的优势： 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。 任务通知的限制： 不能发送数据给ISR：ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。 数据只能给该任务独享使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。 无法缓冲数据使用队列时，假设队列深度为N，那么它可以保持N个数据。使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。 无法广播给多个任务使用事件组可以同时给多个任务发送事件。使用任务通知，只能发个一个任务。 如果发送受阻，发送方无法进入阻塞状态等待假设队列已经满了，使用xQueueSendToBack()给队列发送数据时，任务可以进入阻塞状态等待发送完成。使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。 通知状态和通知值每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员： 一个是uint8_t类型，用来表示通知状态 一个是uint32_t类型，用来表示通知值 12345678typedef struct tskTaskControlBlock&#123; ...... /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */ volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; ......&#125; tskTCB; 通知状态有3种取值： taskNOT_WAITING_NOTIFICATION：任务没有在等待通知 taskWAITING_NOTIFICATION：任务在等待通知 taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理) 123#define taskNOT_WAITING_NOTIFICATION ( ( uint8_t ) 0 ) /* 也是初始状态 */#define taskWAITING_NOTIFICATION ( ( uint8_t ) 1 )#define taskNOTIFICATION_RECEIVED ( ( uint8_t ) 2 ) 通知值可以有很多种类型： 计数值 位(类似事件组) 任意数值 任务通知的使用使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。 两类函数任务通知有2套函数，简化版、专业版，列表如下： 简化版函数的使用比较简单，它实际上也是使用专业版函数实现的 专业版函数支持很多参数，可以实现很多功能 简化版 专业版 发出通知 xTaskNotifyGivevTaskNotifyGiveFromISR xTaskNotifyxTaskNotifyFromISR 取出通知 ulTaskNotifyTake xTaskNotifyWait xTaskNotifyGive&#x2F;ulTaskNotifyTake在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知： 使得通知值加一 并使得通知状态变为”pending”，也就是taskNOTIFICATION_RECEIVED，表示有数据了、待处理 可以使用ulTaskNotifyTake函数来取出通知值： 如果通知值等于0，则阻塞(可以指定超时时间) 当通知值大于0时，任务从阻塞态进入就绪态 在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零 使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。 这几个函数的原型如下： 12345BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ); xTaskNotifyGive函数的参数说明如下： 参数 说明 xTaskToNotify 任务句柄(创建任务时得到)，给哪个任务发通知 返回值 必定返回pdPASS vTaskNotifyGiveFromISR函数的参数说明如下： 参数 说明 xTaskHandle 任务句柄(创建任务时得到)，给哪个任务发通知 pxHigherPriorityTaskWoken 被通知的任务，可能正处于阻塞状态。此函数发出通知后，会把它从阻塞状态切换为就绪态。如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。 ulTaskNotifyTake函数的参数说明如下： 参数 说明 xClearCountOnExit 函数返回前是否清零：pdTRUE：把通知值清零pdFALSE：如果通知值大于0，则把通知值减一 xTicksToWait 任务进入阻塞态的超时时间，它在等待通知值大于0。0：不等待，即刻返回；portMAX_DELAY：一直等待，直到通知值大于0；其他值：Tick Count，可以用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 函数返回之前，在清零或减一之前的通知值。如果xTicksToWait非0，则返回值有2种情况：1. 大于0：在超时前，通知值被增加了2. 等于0：一直没有其他任务增加通知值，最后超时返回0 xTaskNotify&#x2F;xTaskNotifyWaitxTaskNotify 函数功能更强大，可以使用不同参数实现各类功能，比如： 让接收任务的通知值加一：这时xTaskNotify()等同于xTaskNotifyGive() 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似xQueueOverwrite()函数，这就是轻量级的邮箱。 xTaskNotify()比xTaskNotifyGive()更灵活、强大，使用上也就更复杂。xTaskNotifyFromISR()是它对应的ISR版本。 这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？ 使用xTaskNotifyWait()函数！它比ulTaskNotifyTake()更复杂： 可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据) 还可以在函数进入、退出时，清除通知值的指定位 这几个函数的原型如下： 1234567891011BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ); xTaskNotify函数的参数说明如下： 参数 说明 xTaskToNotify 任务句柄(创建任务时得到)，给哪个任务发通知 ulValue 怎么使用ulValue，由eAction参数决定 eAction 见下表 返回值 pdPASS：成功，大部分调用都会成功pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为”pending”(表示有新数据未读)，这时就会失败。 eNotifyAction参数说明： eNotifyAction取值 说明 eNoAction 仅仅是更新通知状态为”pending”，未使用ulValue。这个选项相当于轻量级的、更高效的二进制信号量。 eSetBits 通知值 &#x3D; 原来的通知值 | ulValue，按位或。相当于轻量级的、更高效的事件组。 eIncrement 通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。相当于轻量级的、更高效的二进制信号量、计数型信号量。相当于xTaskNotifyGive()函数。 eSetValueWithoutOverwrite 不覆盖。如果通知状态为”pending”(表示有数据未读)，则此次调用xTaskNotify不做任何事，返回pdFAIL。如果通知状态不是”pending”(表示没有新数据)，则：通知值 &#x3D; ulValue。 eSetValueWithOverwrite 覆盖。无论如何，不管通知状态是否为”pendng”，通知值 &#x3D; ulValue。 xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数pxHigherPriorityTaskWoken。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下： 被通知的任务，可能正处于阻塞状态 xTaskNotifyFromISR函数发出通知后，会把接收任务从阻塞状态切换为就绪态 如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。 xTaskNotifyWait函数列表如下： 参数 说明 ulBitsToClearOnEntry 在xTaskNotifyWait入口处，要清除通知值的哪些位？通知状态不是”pending”的情况下，才会清除。它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。比如传入0x01，表示清除通知值的bit0；传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 ulBitsToClearOnExit 在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。在清除某些位之前，通知值先被赋给”*pulNotificationValue”。比如入0x03，表示清除通知值的bit0、bit1；传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 pulNotificationValue 用来取出通知值。在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。如果不需要取出通知值，可以设为NULL。 xTicksToWait 任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。0：不等待，即刻返回；portMAX_DELAY：一直等待，直到通知状态变为”pending”；其他值：Tick Count，可以用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 1. pdPASS：成功这表示xTaskNotifyWait成功获得了通知：可能是调用函数之前，通知状态就是”pending”；也可能是在阻塞期间，通知状态变为了”pending”。2. pdFAIL：没有得到通知。 软件定时器软件定时器的特性我们在手机上添加闹钟时，需要指定时间、指定类型(一次性的，还是周期性的)、指定做什么事；还有一些过时的、不再使用的闹钟。 使用定时器跟使用手机闹钟是类似的： 指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。 指定类型，定时器有两种类型： 一次性(One-shot timers)：这类定时器启动后，它的回调函数只会被调用一次；可以手工再次启动它，但是不会自动启动它。 自动加载定时器(Auto-reload timers )：这类定时器启动后，时间到之后它会自动启动它；这使得回调函数被周期性地调用。 指定要做什么事，就是指定回调函数 实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态： 运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用 冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用 定时器运行情况示例如下： Timer1：它是一次性的定时器，在t1启动，周期是6个Tick。经过6个tick后，在t7执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。 Timer2：它是自动加载的定时器，在t1启动，周期是5个Tick。每经过5个tick它的回调函数都被执行，比如在t6、t11、t16都会执行。 软件定时器的上下文守护任务要理解软件定时器API函数的参数，特别是里面的xTicksToWait，需要知道定时器执行的过程。 FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行。在哪里执行定时器函数？第一印象就是在Tick中断里执行： 在Tick中断中判断定时器是否超时 如果超时了，调用它的回调函数 FreeRTOS是RTOS，它不允许在内核、在中断中执行不确定的代码：如果定时器函数很耗时，会影响整个系统。 所以，FreeRTOS中，不在Tick中断中执行定时器函数。 在哪里执行？在某个任务里执行，这个任务就是：RTOS Damemon Task，RTOS守护任务。以前被称为”Timer server”，但是这个任务要做并不仅仅是定时器相关，所以改名为：RTOS Damemon Task。 当FreeRTOS的配置项configUSE_TIMERS被设置为1时，在启动调度器时，会自动创建RTOS Damemon Task。 我们自己编写的任务函数要使用定时器时，是通过”定时器命令队列”(timer command queue)和守护任务交互，如下图所示： 守护任务的优先级为：configTIMER_TASK_PRIORITY；定时器命令队列的长度为configTIMER_QUEUE_LENGTH。 守护任务的调度守护任务的调度，跟普通的任务并无差别。当守护任务是当前优先级最高的就绪态任务时，它就可以运行。它的工作有两类： 处理命令：从命令队列里取出命令、处理 执行定时器的回调函数 能否及时处理定时器的命令、能否及时执行定时器的回调函数，严重依赖于守护任务的优先级。下面使用2个例子来演示。 例子1：守护任务的优先性级较低 t1：Task1处于运行态，守护任务处于阻塞态。守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。至于守护任务能否马上执行，取决于它的优先级。 t2：Task1调用xTimerStart()要注意的是，xTimerStart()只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。在本例中，Task1的优先级高于守护任务，所以守护任务无法抢占Task1。 t3：Task1执行完xTimerStart()但是定时器的启动工作由守护任务来实现，所以xTimerStart()返回并不表示定时器已经被启动了。 t4：Task1由于某些原因进入阻塞态，现在轮到守护任务运行。守护任务从队列中取出”start timer”命令，启动定时器。 t5：守护任务处理完队列中所有的命令，再次进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。 注意：假设定时器在后续某个时刻tX超时了，超时时间是”tX-t2”，而非”tX-t4”，从xTimerStart()函数被调用时算起。 例子2：守护任务的优先性级较高 t1：Task1处于运行态，守护任务处于阻塞态。守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。至于守护任务能否马上执行，取决于它的优先级。 t2：Task1调用xTimerStart()要注意的是，xTimerStart()只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。在本例中，守护任务的优先级高于Task1，所以守护任务抢占Task1，守护任务开始处理命令队列。Task1在执行xTimerStart()的过程中被抢占，这时它无法完成此函数。 t3：守护任务处理完命令队列中所有的命令，再次进入阻塞态。此时Task1是优先级最高的就绪态任务，它开始执行。 t4：Task1之前被守护任务抢占，对xTimerStart()的调用尚未返回。现在开始继续运行次函数、返回。 t5：Task1由于某些原因进入阻塞态，进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。 注意，定时器的超时时间是基于调用xTimerStart()的时刻tX，而不是基于守护任务处理命令的时刻tY。假设超时时间是10个Tick，超时时间是”tX+10”，而非”tY+10”。 回调函数定时器的回调函数的原型如下： 1void ATimerCallback( TimerHandle_t xTimer ); 定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。 所以，定时器的回调函数不要影响其他人： 回调函数要尽快实行，不能进入阻塞状态 不要调用会导致阻塞的API函数，比如vTaskDelay() 可以调用xQueueReceive()之类的函数，但是超时时间要设为0：即刻返回，不可阻塞 软件定时器的函数根据定时器的状态转换图，就可以知道所涉及的函数： 创建要使用定时器，需要先创建它，得到它的句柄。 有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下： 1234567891011121314151617181920212223242526272829/* 使用动态分配内存的方法创建定时器 * pcTimerName:定时器名字, 用处不大, 尽在调试时用到 * xTimerPeriodInTicks: 周期, 以Tick为单位 * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性 * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器 * pxCallbackFunction: 回调函数 * 返回值: 成功则返回TimerHandle_t, 否则返回NULL */TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction );/* 使用静态分配内存的方法创建定时器 * pcTimerName:定时器名字, 用处不大, 尽在调试时用到 * xTimerPeriodInTicks: 周期, 以Tick为单位 * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性 * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器 * pxCallbackFunction: 回调函数 * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器 * 返回值: 成功则返回TimerHandle_t, 否则返回NULL */TimerHandle_t xTimerCreateStatic(const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer ); 回调函数的类型是： 123void ATimerCallback( TimerHandle_t xTimer );typedef void (* TimerCallbackFunction_t)( TimerHandle_t xTimer ); 删除动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下： 1234567/* 删除定时器 * xTimer: 要删除哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait ); 定时器的很多API函数，都是通过发送”命令”到命令队列，由守护任务来实现。 如果队列满了，”命令”就无法即刻写入队列。我们可以指定一个超时时间xTicksToWait，等待一会。 启动&#x2F;停止启动定时器就是设置它的状态为运行态(Running、Active)。 停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。 涉及的函数原型如下： 123456789101112131415161718192021222324252627282930313233343536373839/* 启动定时器 * xTimer: 哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );/* 启动定时器(ISR版本) * xTimer: 哪个定时器 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, * 表示需要进行任务调度 * 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列 * pdPASS表示成功 */BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );/* 停止定时器 * xTimer: 哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );/* 停止定时器(ISR版本) * xTimer: 哪个定时器 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, * 表示需要进行任务调度 * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列 * pdPASS表示成功 */BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken ); 注意，这些函数的xTicksToWait表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。 xTicksToWait不是定时器本身的超时时间，不是定时器本身的”周期”。 创建定时器时，设置了它的周期(period)。xTimerStart()函数是用来启动定时器。假设调用xTimerStart()的时刻是tX，定时器的周期是n，那么在tX+n时刻定时器的回调函数被调用。 如果定时器已经被启动，但是它的函数尚未被执行，再次执行xTimerStart()函数相当于执行xTimerReset()，重新设定它的启动时间。 复位从定时器的状态转换图可以知道，使用xTimerReset()函数可以让定时器的状态从冬眠态转换为运行态，相当于使用xTimerStart()函数。 如果定时器已经处于运行态，使用xTimerReset()函数就相当于重新确定超时时间。假设调用xTimerReset()的时刻是tX，定时器的周期是n，那么tX+n就是重新确定的超时时间。 复位函数的原型如下： 12345678910111213141516171819/* 复位定时器 * xTimer: 哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );/* 复位定时器(ISR版本) * xTimer: 哪个定时器 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, * 表示需要进行任务调度 * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列 * pdPASS表示成功 */BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken ); 修改周期从定时器的状态转换图可以知道，使用xTimerChangePeriod()函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。 修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用xTimerChangePeriod()函数的时间tX，新的周期是n，则tX+n就是新的超时时间。 相关函数的原型如下： 123456789101112131415161718192021222324/* 修改定时器的周期 * xTimer: 哪个定时器 * xNewPeriod: 新周期 * xTicksToWait: 超时时间, 命令写入队列的超时时间 * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xTicksToWait );/* 修改定时器的周期 * xTimer: 哪个定时器 * xNewPeriod: 新周期 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, * 表示需要进行任务调度 * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken ); 定时器ID定时器的结构体如下，里面有一项pvTimerID，它就是定时器ID： 怎么使用定时器ID，完全由程序来决定： 可以用来标记定时器，表示自己是什么定时器 可以用来保存参数，给回调函数使用 它的初始值在创建定时器时由xTimerCreate()这类函数传入，后续可以使用这些函数来操作： 更新ID：使用vTimerSetTimerID()函数 查询ID：查询pvTimerGetTimerID()函数 这两个函数不涉及命令队列，它们是直接操作定时器结构体。 函数原型如下： 123456789101112/* 获得定时器的ID * xTimer: 哪个定时器 * 返回值: 定时器的ID */void *pvTimerGetTimerID( TimerHandle_t xTimer );/* 设置定时器的ID * xTimer: 哪个定时器 * pvNewID: 新ID * 返回值: 无 */void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ); 中断管理两套API函数为什么需要两套API在任务函数中，我们可以调用各类API函数，比如队列操作函数：xQueueSendToBack。但是在ISR中使用这个函数会导致问题，应该使用另一个函数：xQueueSendToBackFromISR，它的函数名含有后缀”FromISR”，表示”从ISR中给队列发送数据”。 FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名含有”FromISR”后缀。 为什么要引入两套API函数？ 很多API函数会导致任务计入阻塞状态： 运行这个函数的任务进入阻塞状态 比如写队列时，如果队列已满，可以进入阻塞状态等待一会 ISR调用API函数时，ISR不是”任务”，ISR不能进入阻塞状态 所以，在任务中、在ISR中，这些函数的功能是有差别的 为什么不使用同一套函数，比如在函数里面分辨当前调用者是任务还是ISR呢？示例代码如下： 1234567891011121314BaseType_t xQueueSend(...)&#123; if (is_in_isr()) &#123; /* 把数据放入队列 */ /* 不管是否成功都直接返回 */ &#125; else /* 在任务中 */ &#123; /* 把数据放入队列 */ /* 不成功就等待一会再重试 */ &#125;&#125; FreeRTOS使用两套函数，而不是使用一套函数，是因为有如下好处： 使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，是的函数更长、更复杂、难以测试 在任务、ISR中调用时，需要的参数不一样，比如： 在任务中调用：需要指定超时时间，表示如果不成功就阻塞一会 在ISR中调用：不需要指定超时时间，无论是否成功都要即刻返回 如果强行把两套函数揉在一起，会导致参数臃肿、无效 移植FreeRTOS时，还需要提供监测上下文的函数，比如is_in_isr() 有些处理器架构没有办法轻易分辨当前是处于任务中，还是处于ISR中，就需要额外添加更多、更复杂的代码 使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR总调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。这个问题可以解决： 把中断的处理推迟到任务中进行(Defer interrupt processing)，在任务中调用库函数 尝试在库函数中使用”FromISR”函数： 在任务中、在ISR中都可以调用”FromISR”函数 反过来就不行，非FromISR函数无法在ISR中使用 第三方库函数也许会提供OS抽象层，自行判断当前环境是在任务还是在ISR中，分别调用不同的函数 两套API函数列表 类型 在任务中 在ISR中 队列(queue) xQueueSendToBack xQueueSendToBackFromISR xQueueSendToFront xQueueSendToFrontFromISR xQueueReceive xQueueReceiveFromISR xQueueOverwrite xQueueOverwriteFromISR xQueuePeek xQueuePeekFromISR 信号量(semaphore) xSemaphoreGive xSemaphoreGiveFromISR xSemaphoreTake xSemaphoreTakeFromISR 事件组(event group) xEventGroupSetBits xEventGroupSetBitsFromISR xEventGroupGetBits xEventGroupGetBitsFromISR 任务通知(task notification) xTaskNotifyGive vTaskNotifyGiveFromISR xTaskNotify xTaskNotifyFromISR 软件定时器(software timer) xTimerStart xTimerStartFromISR xTimerStop xTimerStopFromISR xTimerReset xTimerResetFromISR xTimerChangePeriod xTimerChangePeriodFromISR xHigherPriorityTaskWoken参数xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。 还是以写队列为例。 任务A调用xQueueSendToBack()写队列，有几种情况发生： 队列满了，任务A阻塞等待，另一个任务B运行 队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行 队列没满，任务A成功写入队列，即刻返回 可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做”context switch”，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。 xQueueSendToBackFromISR()函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下： 123456789101112131415161718/* * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞 */BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken );/* 用法示例 */BaseType_t xHigherPriorityTaskWoken = pdFALSE;xQueueSendToBackFromISR(xQueue, pvItemToQueue, &amp;xHigherPriorityTaskWoken);if (xHigherPriorityTaskWoken == pdTRUE)&#123; /* 任务切换 */ &#125; pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换 *pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换 *pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要 为什么不在”FromISR”函数内部进行任务切换，而只是标记一下而已呢？为了效率！示例代码如下： 12345678void XXX_ISR()&#123; int i; for (i = 0; i &lt; N; i++) &#123; xQueueSendToBackFromISR(...); /* 被多次调用 */ &#125;&#125; ISR中有可能多次调用”FromISR”函数，如果在”FromISR”内部进行任务切换，会浪费时间。解决方法是： 在”FromISR”中标记是否需要切换 在ISR返回之前再进行任务切换 示例代码如下 12345678910111213141516void XXX_ISR()&#123; int i; BaseType_t xHigherPriorityTaskWoken = pdFALSE; for (i = 0; i &lt; N; i++) &#123; xQueueSendToBackFromISR(.. &amp;xHigherPriorityTaskWoken); /* 被多次调用 */ &#125; /* 最后再决定是否进行任务切换 */ if (xHigherPriorityTaskWoken == pdTRUE)\t&#123; /* 任务切换 */ &#125;&#125; 上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。 在ISR中调用API时不进行任务切换，而只是在”xHigherPriorityTaskWoken”中标记一下，除了效率，还有多种好处： 效率高：避免不必要的任务切换 让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂 可移植性 在Tick中断中，调用vApplicationTickHook()：它运行与ISR，只能使用”FromISR”的函数 使用”FromISR”函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。 怎么切换任务FreeRTOS的ISR函数中，使用两个宏进行任务切换： 123portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );或portYIELD_FROM_ISR( xHigherPriorityTaskWoken ); 这两个宏做的事情是完全一样的，在老版本的FreeRTOS中， portEND_SWITCHING_ISR使用汇编实现 portYIELD_FROM_ISR使用C语言实现 新版本都统一使用portYIELD_FROM_ISR。 使用示例如下： 123456789101112131415void XXX_ISR()&#123; int i; BaseType_t xHigherPriorityTaskWoken = pdFALSE; for (i = 0; i &lt; N; i++) &#123; xQueueSendToBackFromISR(.. &amp;xHigherPriorityTaskWoken); /* 被多次调用 */ &#125; /* 最后再决定是否进行任务切换 * xHigherPriorityTaskWoken为pdTRUE时才切换 */ portYIELD_FROM_ISR(xHigherPriorityTaskWoken);&#125; 中断的延迟处理前面讲过，ISR要尽量快，否则： 其他低优先级的中断无法被处理：实时性无法保证 用户任务无法被执行：系统显得很卡顿 如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套 如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分： ISR：尽快做些清理、记录工作，然后触发某个任务 任务：更复杂的事情放在任务中处理 这种处理方式叫”中断的延迟处理”(Deferring interrupt processing)，处理流程如下图所示： t1：任务1运行，任务2阻塞 t2：发生中断， 该中断的ISR函数被执行，任务1被打断 ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2 t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为”deferred processing task”，中断的延迟处理任务。 t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行 中断与任务间的通信前面讲解过的队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。 要注意的是，在ISR中使用的函数要有”FromISR”后缀。 资源管理屏蔽中断屏蔽中断有两套宏：任务中使用、ISR中使用： 任务中使用：taskENTER_CRITICA()/taskEXIT_CRITICAL() ISR中使用：taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR() 在任务中屏蔽中断在任务中屏蔽中断的示例代码如下： 123456789/* 在任务中，当前时刻中断是使能的 * 执行这句代码后，屏蔽中断 */taskENTER_CRITICAL();/* 访问临界资源 *//* 重新使能中断 */taskEXIT_CRITICAL(); 在taskENTER_CRITICA()/taskEXIT_CRITICAL()之间： 低优先级的中断被屏蔽了：优先级低于、等于configMAX_SYSCALL_INTERRUPT_PRIORITY 高优先级的中断可以产生：优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 但是，这些中断ISR里，不允许使用FreeRTOS的API函数 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 这套taskENTER_CRITICA()/taskEXIT_CRITICAL()宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用taskEXIT_CRITICAL()才会重新使能中断。 使用taskENTER_CRITICA()/taskEXIT_CRITICAL()来访问临界资源是很粗鲁的方法： 中断无法正常运行 任务调度无法进行 所以，之间的代码要尽可能快速地执行 在ISR中屏蔽中断要使用含有”FROM_ISR”后缀的宏，示例代码如下： 1234567891011121314151617void vAnInterruptServiceRoutine( void )&#123; ## 用来记录当前中断是否使能 */ UBaseType_t uxSavedInterruptStatus; ## 在ISR中，当前时刻中断可能是使能的，也可能是禁止的## * 所以要记录当前状态, 后面要恢复为原先的状态## * 执行这句代码后，屏蔽中断## */ uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR(); ## 访问临界资源 */ ## 恢复中断状态 */ taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus ); ## 现在，当前ISR可以被更高优先级的中断打断了 */&#125; 在taskENTER_CRITICA_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()之间： 低优先级的中断被屏蔽了：优先级低于、等于configMAX_SYSCALL_INTERRUPT_PRIORITY 高优先级的中断可以产生：优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 但是，这些中断ISR里，不允许使用FreeRTOS的API函数 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 暂停调度器如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。 如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。 使用这2个函数来暂停、恢复调度器： 12345678/* 暂停调度器 */void vTaskSuspendAll( void );/* 恢复调度器 * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了 *## 可以不理会这个返回值 */BaseType_t xTaskResumeAll( void ); 示例代码如下： 12345vTaskSuspendScheduler();/* 访问临界资源 */xTaskResumeScheduler(); 这套vTaskSuspendScheduler()/xTaskResumeScheduler()宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用taskEXIT_CRITICAL()才会重新使能中断。 参考原文地址","tags":["🦾RTOS"]},{"title":"2022照片故事分享","path":"/posts/6679f469/","content":"虽然我不经常拍照，但是我还是有一些照片的，分享一下这些照片的故事(简短)。 12 回家躺尸 11 开始接触旭日x3派，非常不错的一块板子，但是它不带gpu 10 我以为那是一只松鼠，可惜不是 9 辛苦打工人，玩各种模块 8 在寝室躺尸，那天天气很红 7辛苦打工人 6 毕业 5 入党 4 跟3d打印机干架（维修） 3 樱花真的很美，但看多了也就习惯了，香味很喜欢 2 考研找导师 1 折腾内网穿透","tags":["Life"]},{"title":"串口应用层通信协议代码解析","path":"/posts/a941f9c6/","content":"背景介绍串口这里不再多说，不懂的进链接去了解一下。在STM32中，串口的通信协议一般是应用层协议，即上位机和下位机之间的通信协议。这里的应用层协议是师兄设计的，之前也看过几遍，但没看懂，今天来仔细分析一下。 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 是串口接收中断的回调函数，简单理解就是每次串口接收到数据都会调用这个函数。 协议格式123456789A00B0000// A后面的两位数字代表通道号// B后面的四位数字代表值// 注：均为字符格式A01B1200 代码正文1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;\t/*define a symbol\trcvstate:\t| 7\t| 6\t| 5\t|\t4 |3|\t2|\t1|\t0|\tstate bit |&#x27;A&#x27;received|&#x27;B&#x27;received|cmd rcv cplt| ERROR\t| receive index |\t*/\tstatic uint8_t rcvstate = 0x00; switch (UART_RCV_DATA)\t//switch the received data &#123; case &#x27;A&#x27;:\t//data head is &#x27;A&#x27; UART_RCV_BUFFER[0] = &#x27;A&#x27;; rcvstate |= 0x81;\t//set A flag and data cnt 1 break; case &#x27;B&#x27;:\t//data head2 is &#x27;B&#x27; if(rcvstate == 0x83)\t//if get &#x27;A&#x27; and data index equals 3 &#123; rcvstate = 0xC4;\t//set A and B flag and data cnt 4 UART_RCV_BUFFER[3] = &#x27;B&#x27;; &#125; else &#123; rcvstate = 0x00;\t//reset state &#125; break; default: if(UART_RCV_DATA - &#x27;0&#x27; &lt;= 9)\t//check if data is numbers &#123; if(rcvstate &amp; 0xC0)\t//if rcvstate is 0x8X or 0xCX, result is true &#123; UART_RCV_BUFFER[rcvstate &amp; 0x0F] = UART_RCV_DATA;\t//save data to buffer[index] rcvstate += 1;\t//data index increase &#125; else &#123; rcvstate = 0x00;\t//reset state &#125; &#125; else\t//other data received &#123; //now no other CMD is defined rcvstate = 0x00;\t//reset state &#125; if((rcvstate &amp; 0x0F) == 8)\t//Data receive completed &#123; rcvstate |= 0x20;\t//SET complete flag /* CMD_temp: high 16 bits =\tContral Channel low 16 bits =\tContral Value */ uint32_t CMD_temp = 0x00000000; CMD_temp = 10 * (UART_RCV_BUFFER[1] - &#x27;0&#x27;)\t//calculate ctrl channel + (UART_RCV_BUFFER[2] - &#x27;0&#x27;); CMD_temp &lt;&lt;= 16;\t//move channel data to high 16 bits CMD_temp += 1000 * (UART_RCV_BUFFER[4] - &#x27;0&#x27;)\t//calculate ctrl value + 100 * (UART_RCV_BUFFER[5] - &#x27;0&#x27;) + 10 * (UART_RCV_BUFFER[6] - &#x27;0&#x27;) + 1 * (UART_RCV_BUFFER[7] - &#x27;0&#x27;); //send CMD message if(osMessageQueuePut(CMD_QueueHandle, &amp;CMD_temp, 0, 0) == osOK) &#123; rcvstate = 0x00;\t//reset state &#125; else &#123; rcvstate |= 0x10;\t//report error &#125; &#125; break; &#125;\tif(rcvstate &amp; 0x10)\t//ERROR report signal\t&#123; //send error report rcvstate = 0x00;\t//reset state\t&#125;&#125; 解析过程代码里面有注释可以参考，口头表述比较困难这里用结果来表示吧。 1234567891011121314151617//char input[13] = &quot;A02B0005CCCC&quot;;输入的数据为 :A rcvstate: 81输入的数据为 :0 rcvstate: 82输入的数据为 :2 rcvstate: 83输入的数据为 :B rcvstate: c4输入的数据为 :0 rcvstate: c5输入的数据为 :0 rcvstate: c6输入的数据为 :0 rcvstate: c7输入的数据为 :5 rcvstate: e8输入的数据为 :C rcvstate: 0输入的数据为 :C rcvstate: 0输入的数据为 :C rcvstate: 0输入的数据为 :C rcvstate: 0输入的数据为 : rcvstate: 0 已知的BUG发送 A02B010 也会有数据产生，而且会乱码","tags":["Lab","STM32","串口"]},{"title":"戴森球计划[游戏安利]","path":"/posts/7c3617f6/","content":"游戏介绍 探索未知的星球，发现珍奇，让你的足迹遍布星辰大海。 《戴森球计划》是一款融合了太空、自动化工厂、冒险、探索等元素的科幻题材沙盒建造类游戏。在未来，人类踏入高级文明的行列之时，科技的强大带来了飞速的发展，虚拟现实迭代了空间与时间。人类创造了超级计算机——“主脑”，以期待利用其强大的计算能力来进一步扩大虚拟世界的运用。 作为玩家的你，加入了空间管理联盟COSMO开启的一项代号为“戴森球计划”的工程项目，建造戴森球，为“主脑”提供持续稳定的能量。在游戏中，玩家将从上帝视角进行工厂建造及资源管理。在这一过程中，你势必会遭遇诸多困难，毕竟宇宙之大，什么都可能发生。然而，你的创造力与想象力将会助你达成这一宏大的目标，整个银河势必将在你的规划下成为人类文明前进的基石。 你可以不断解锁科技，一步一步打造专属你的戴森球；也可以探索宇宙，发现宇宙珍奇，踏遍星辰大海；或是架设星际物流系统，串联出庞大的工业帝国；亦或是不断优化设计，让生产流水线的效率更高。 随机生成的星图，每一局都是独一无二的宇宙。更加微观的建造戴森球，从一个零件开始构架。千变万化的宇宙生态，中子星、白矮星、红巨星，甚至黑洞。不止于地表的自动化生产流水线，跨越星系运输物资。多种可自主定制的设定，打造属于你自己的戴森球计划。球形地表，完美表现在一颗星球之上完成建设的特色。 将资源通过传送带串联在各个建筑之间，形成高效的流水线生产，让科技自主的前进。同时在建造过程中建筑会自动吸附网格，铺设流水线时可以利用建筑网格吸附功能自动对齐建筑，大大提高建造的效率，形成大规模的自动化流水线。 跨越地表运输的限制，组建你的星际运输大队，将另一个星球的物资传递过来，集合全宇宙的力量来快速发展自己。 每一次游戏的开始都会随机生成全新的星图，拥有不同的星球种类，矿物分布。每一个星球的地形也会变化。在这个千变万化的宇宙中去完全属于你自己的“戴森球计划”。 同时游戏中直接展现了各式各样的星球和天象，中子星、白矮星、红巨星、气态星球、日冕、永昼永夜等，统统都可以在这里看到。 宣传视频 买家秀 一些有趣但很真实的评论 早上八点打开游戏，关闭游戏是已经是早上七点，这游戏能让时间倒流！！！ 配置要求不高，但是后期PPT是无法避免的 戴森球计划（❌） 时间消失模拟器（✔️） 千人大厂十连抽，五人作坊戴森球！ 70块钱他就能给你几十个恒星系玩哎，当你看到戴森球代替恒星升起，物流飞船遍布整个宇宙，自动化生产线源源不断生产出一些看上去非常厉害的东西的时候，那感觉，真的绝了 还没出的战斗序列《戴森球计划》TGS战斗系统宣传视频：黑雾崛起 玩家文档https://wiki.biligame.com/dsp/%E9%A6%96%E9%A1%B5 最后测试一下我的随机图片壁纸","tags":["🎮Game"]},{"title":"ROS 自定义订阅者","path":"/posts/7e7b94b3/","content":"背景介绍软件平台 The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it’s all open source. Robot操作系统(ROS)是一组软件库和工具，可帮助您构建机器人应用程序。从驱动程序到最先进的算法，再加上强大的开发工具，ROS为您的下一个机器人项目提供了所需的一切。而且这一切都是开源的。 硬件平台 地平线旭日®️X3派是一款面向生态开发者的嵌入式AI开发板，接口兼容树莓派，具有5Tops端侧推理与4核ARM A53处理能力。可同时多路Camera Sensor的输入并支持H.264&#x2F;H.265编解码。结合地平线的高性能AI工具链与机器人开发平台，助力开发者快速落地解决方案。 ROS 订阅机制ROS 2将复杂的系统分解为许多模块化节点。 主题是 ROS 图的重要组成部分，充当节点交换消息的总线。 一个节点可以将数据发布到任意数量的主题，同时订阅任意数量的主题。 主题是数据在节点之间移动的主要方式之一，因此也是在系统的不同部分之间移动的主要方式之一。 (不得不说官方文档还是写的很不错的) 自定义订阅者(这里参考了很多官方文档) 创建包打开一个新终端并获取 ROS 2 安装，以便命令正常工作。ros2 导航到上一教程中创建的目录。ros2_ws 回想一下，包应该在目录中创建，而不是在工作区的根目录中创建。 因此，导航到 并运行包创建命令：srcros2_ws/src ros2 pkg create --build-type ament_python py_pubsub 您的终端将返回一条消息，验证您的软件包及其所有必要文件和文件夹的创建。 编写订阅节点导航到 py_pubsub 回想一下，此目录是一个 Python 包，与它嵌套的 ROS 2 包同名。ros2_ws/src/py_pubsub/py_pubsub 1234567891011121314151617181920212223242526272829303132333435363738import rclpyfrom rclpy.node import Nodefrom std_msgs.msg import Stringclass MinimalSubscriber(Node): def __init__(self): super().__init__(&#x27;minimal_subscriber&#x27;) self.subscription = self.create_subscription( String, &#x27;topic&#x27;, self.listener_callback, 10) self.subscription # prevent unused variable warning def listener_callback(self, msg): self.get_logger().info(&#x27;I heard: &quot;%s&quot;&#x27; % msg.data)def main(args=None): rclpy.init(args=args) minimal_subscriber = MinimalSubscriber() rclpy.spin(minimal_subscriber) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber.destroy_node() rclpy.shutdown()if __name__ == &#x27;__main__&#x27;: main() 添加依赖将一个级别导航回目录，其中已为您创建了目录和文件。ros2_ws/src/py_pubsub setup.py setup.cfg package.xml 使用文本编辑器打开。package.xml 如上一教程所述，请确保填写&lt;description&gt; &lt;maintainer&gt; &lt;license&gt;标记： 123&lt;description&gt;Examples of minimal publisher/subscriber using rclpy&lt;description&gt;&lt;maintainer email=&quot;you@email.com&quot;&gt;Your Name&lt;/maintainer&gt;&lt;license&gt;Apache License 2.0&lt;/license&gt; 在上述行之后，添加与节点的导入语句对应的以下依赖项： 12&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt; 这声明了包的需求以及何时执行其代码 添加入口点打开setup.py文件。 同样，将 、 和 字段与您的 ：maintainer maintainer_email description licensepackage.xml 12345maintainer=&#x27;YourName&#x27;,maintainer_email=&#x27;you@email.com&#x27;,description=&#x27;Examples of minimal publisher/subscriber using rclpy&#x27;,license=&#x27;Apache License 2.0&#x27;, 在字段的括号内添加以下行： 12345entry_points=&#123; &#x27;console_scripts&#x27;: [ &#x27;talker = py_pubsub.publisher_member_function:main&#x27;, ],&#125;, 不要忘记保存。 检查设置.cfg文件的内容应自动正确填充，如下所示：setup.cfg 1234[develop]script-dir=$base/lib/py_pubsub[install]install-scripts=$base/lib/py_pubsub 这只是告诉设置工具将您的可执行文件放入 ，因为会在那里寻找它们。 您现在可以构建软件包，获取本地安装文件并运行它，但让我们先创建订阅者节点，以便您可以看到完整的系统在工作。 消息格式参考旭日x3的ai_msgs ai_msgs自定义的ai msg，包括人&#x2F;物&#x2F;车等检测框roi，跟踪track id，抓拍，特征，手势识别等结果。用于算法模型推理后，发布推理结果。 message详细说明如下： PerceptionTargets.msg感知结果的消息定义，一般每帧图像对应一个感知结果消息。消息包含： 1、std_msgs&#x2F;Header header 消息头，包含stamp和frame_id，和用于模型推理的图片header一致，用于表示此消息所对应的图片。 2、int16 fps 感知结果的输出帧率，即算法模型推理处理帧率，小于0无效。 当fps小于sensor的图像输出帧率时，说明算法模型推理耗时比较长，需要对推理流程进行优化。 3、Perf[] perfs 性能统计信息，比如记录每个模型推理的耗时。 当有多个模型时，可以通过记录每个模型的性能信息发现模型推理流程的性能瓶颈。同时当发生推理异常导致无ai消息输出时，也能够根据性能统计信息中的模型名，判断是哪个模型没有输出，实现快速缩小排查范围。 4、Target[] targets 感知目标集合。 5、Target[] disappeared_targets 消失目标集合。 CaptureTargets.msg抓拍结果的消息定义。消息包含： 1、std_msgs&#x2F;Header header 消息头，包含stamp和frame_id，和用于模型推理的图片header一致，用于表示此消息所对应的图片。 2、Perf.msg 性能统计信息，比如记录每个模型推理的耗时 4、Target[] targets 抓拍目标集合。 Perf.msg性能统计信息。 1、string type 类型，用于表示处理模块。例如type为模型名时，表示对此模型推理的性能统计。 2、builtin_interfaces&#x2F;Time stamp_start 开始处理的时间戳。 3、builtin_interfaces&#x2F;Time stamp_end 处理完成的时间戳。 Target.msg目标消息。 1、string type 目标类型名称，如：人、车、动物、物体，具体值可以定义为为person&#x2F;car&#x2F;object&#x2F;animal 2、uint64 track_id 目标跟踪ID号。 3、Roi[] rois 目标的检测框。一个目标可能包含多个检测框，如同时具有人体、人头和人脸检测框。 4、Attribute[] attributes 属性。一个目标可能包含多个属性信息，如同时具有年龄、性别和手势结果。 5、Point[] points 关键点。一个目标可能包含多个关键点信息，如同时具有人脸关键点、人体骨骼点、人手关键点 6、Capture[] captures 跟踪目标抓拍图信息，包含抓拍图、特征、特征的底库检索结果信息。 Roi.msgroi感知消息，如：人体检测框、人头检测框、人脸检测框、人手检测框。 1、string type roi类型，如body&#x2F;head&#x2F;face&#x2F;hand。 2、sensor_msgs&#x2F;RegionOfInterest rect 检测框。 3、float32 score 检测结果的置信度。 Attribute.msg属性感知消息，如：年龄、性别、手势、眼镜、口罩、活体信息、车辆类型、车辆颜色、车辆速度、车辆所在车道等信息。 1、string type 属性类型，如年龄：age，性别：gender， 手势：gesture。 2、float32 value 属性数值。 如age数值定义举例： ​\tval为实际年龄数值 gender数值定义举例： ​\t“1”: “男”, “-1”: “女” gesture数值定义举例： ​\t0: Background, &#x2F;&#x2F; 无手势 ​\t1: FingerHeart, &#x2F;&#x2F; 比心 ​\t2: ThumbUp, &#x2F;&#x2F; 大拇指向上 ​\t3: Victory, &#x2F;&#x2F; V手势 ​\t4: Mute, &#x2F;&#x2F; 嘘 ​\t10: Palm, &#x2F;&#x2F; 手掌 ​\t11: Okay, &#x2F;&#x2F; OK手势 ​\t12: ThumbRight, &#x2F;&#x2F; 大拇指向右 ​\t13: ThumbLeft, &#x2F;&#x2F; 大拇指向左 ​\t14: Awesome, &#x2F;&#x2F; 666手势 3、float32 confidence 属性结果的置信度。 Point.msg关键点感知结果，如：人脸关键点、人体骨骼点、人手关键点。 1、string type 类型，如body_kps&#x2F;face_kps&#x2F;hand_kps。 2、geometry_msgs&#x2F;Point32[] point 关键点数值。 3、float32[] confidence 每个关键点的置信度，维度和关键点数值相同。 Capture.msg抓拍信息。 1、std_msgs&#x2F;Header header 抓拍图对应原视频帧的timestamp和frame_id。 2、sensor_msgs&#x2F;Image img 抓拍图。 3、float32[] features 抓拍图对应的特征数据，数据长度为0时表示无特征。 4、DBResult db_result 特征的底库检索结果。只有当有特征时底库检索结果有效。 DBResult.msg底库检索结果。 1、string db_type 底库名称。 2、string match_id 匹配目标ID。 3、float32 distance 特征比对距离。 4、float32 similarity 特征比对相似度。 构建和运行编译 colcon build --packages-select py_pubsub 打开一个新终端，导航到 ，并获取安装文件： . install/setup.bash 现在运行说话者节点： ros2 run py_pubsub listener 我的代码修改其实Python脚本代码可以直接运行，无需编译 12345678910111213141516171819202122232425262728293031323334353637383940414243import rclpyfrom rclpy.node import Nodefrom ai_msgs.msg import PerceptionTargetsclass MinimalSubscriber(Node): def __init__(self): super().__init__(&#x27;minimal_subscriber&#x27;) self.subscription = self.create_subscription( PerceptionTargets, &#x27;hobot_mono2d_body_detection&#x27;, self.listener_callback, 10) self.subscription # prevent unused variable warning def listener_callback(self, msg): if len(msg.targets) &gt; 1: self.get_logger().info(&#x27;I heard:&#x27; + str(msg.targets[0].type) + str(msg.fps))# &quot;%s&quot;&#x27; % msg.data else: self.get_logger().info(&#x27;dont&#x27;)# https://c-gitlab.horizon.ai/HHP/box/hobot_msgs/-/tree/develop/ai_msgsdef main(args=None): rclpy.init(args=args) minimal_subscriber = MinimalSubscriber() rclpy.spin(minimal_subscriber) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber.destroy_node() rclpy.shutdown()if __name__ == &#x27;__main__&#x27;: main() 结果展示1234567891011[INFO] [1672741631.264257258] [minimal_subscriber]: I heard:person30[INFO] [1672741631.295972687] [minimal_subscriber]: I heard:person30[INFO] [1672741631.327739324] [minimal_subscriber]: I heard:person30[INFO] [1672741631.363461421] [minimal_subscriber]: I heard:person30[INFO] [1672741631.392870207] [minimal_subscriber]: I heard:person30[INFO] [1672741631.429643377] [minimal_subscriber]: I heard:person30[INFO] [1672741631.465771636] [minimal_subscriber]: I heard:person30[INFO] [1672741631.496358035] [minimal_subscriber]: I heard:person30","tags":["🦾ROS"]},{"title":"干饭日记","path":"/posts/39fh31o/","content":"","tags":["🍚干饭日记"]},{"title":"address_calculate","path":"/posts/2scrgfh/","content":"记录一次芯片的地址计算 地址介绍前几天刚发了一篇ltc2497的六层板绘制过程,这两天准备写它的驱动,奈何芯片比较小众只能自己写(练习一下) 先看他的地址列表 12345678910111213141516171819202122232425262728// #define LTC2497_I2C_ADDRESS 0x14 // Low Low Low// #define LTC2497_I2C_ADDRESS 0x16 // Low Low High// #define LTC2497_I2C_ADDRESS 0x15 // Low Low Float// #define LTC2497_I2C_ADDRESS 0x26 // Low High Low// #define LTC2497_I2C_ADDRESS 0x34 // Low High High// #define LTC2497_I2C_ADDRESS 0x27 // Low High Float// #define LTC2497_I2C_ADDRESS 0x17 // Low Float Low// #define LTC2497_I2C_ADDRESS 0x25 // Low Float High// #define LTC2497_I2C_ADDRESS 0x24 // Low Float Float// #define LTC2497_I2C_ADDRESS 0x56 // High Low Low// #define LTC2497_I2C_ADDRESS 0x64 // High Low High// #define LTC2497_I2C_ADDRESS 0x57 // High Low Float// #define LTC2497_I2C_ADDRESS 0x74 // High High Low// #define LTC2497_I2C_ADDRESS 0x76 // High High High// #define LTC2497_I2C_ADDRESS 0x75 // High High Float// #define LTC2497_I2C_ADDRESS 0x65 // High Float Low// #define LTC2497_I2C_ADDRESS 0x67 // High Float High// #define LTC2497_I2C_ADDRESS 0x66 // High Float Float// #define LTC2497_I2C_ADDRESS 0x35 // Float Low Low// #define LTC2497_I2C_ADDRESS 0x37 // Float Low High// #define LTC2497_I2C_ADDRESS 0x36 // Float Low Float// #define LTC2497_I2C_ADDRESS 0x47 // Float High Low// #define LTC2497_I2C_ADDRESS 0x55 // Float High High// #define LTC2497_I2C_ADDRESS 0x54 // Float High Float// #define LTC2497_I2C_ADDRESS 0x44 // Float Float Low// #define LTC2497_I2C_ADDRESS 0x46 // Float Float High// #define LTC2497_I2C_ADDRESS 0x45 // Float Float Float 看起来很复杂,貌似没有规律 地址计算刚开始我也没看出来,然后我把它放到万能的excel中排了一下序列,结果如下 (第一排是16进制,缺了 0x 不要介意) 规律如下: 第一排的第一个数字,也就是地址前四位依次为1-7 第二排都为4-7 low &lt; float &lt; high 是不是发现了规律 本质上就是三进制转为8进制+4进制再加一个基地址0x14 程序编写验证拿clion新建了个工程试一下 123456789101112131415161718192021222324252627282930313233void set_ltc2497_adress(uint8_t addr2,uint8_t addr1, uint8_t addr0)&#123; //auto calculate the address uint8_t num = 0x00; num = addr2*9 + addr1*3 + addr0*1; num = ((num/4) &lt;&lt; 4)|(num%4); num = num + 0x14; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; &quot;0x&quot; &lt;&lt; std::hex &lt;&lt; int(num) &lt;&lt; std::endl; &#125;int main()&#123; //输出全部地址 for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; for (int k = 0; k &lt; 3; k++) &#123; set_ltc2497_adress(i, j, k); &#125; &#125; &#125; system(&quot;pause&quot;); return 0;\treturn 0;&#125; 输出结果如下 123456789101112131415161718192021222324252627address: 0x14address: 0x15address: 0x16address: 0x17address: 0x24address: 0x25address: 0x26address: 0x27address: 0x34address: 0x35address: 0x36address: 0x37address: 0x44address: 0x45address: 0x46address: 0x47address: 0x54address: 0x55address: 0x56address: 0x57address: 0x64address: 0x65address: 0x66address: 0x67address: 0x74address: 0x75address: 0x76 至此,结束","tags":["Embeded"],"categories":["💻Code"]},{"title":"pcb_6","path":"/posts/2nqj13j/","content":"记录第一次画6层板的过程为防止意外,添加了水印 设计目标最近做实验气阀控制板上面的接口总是不够用，最近正好有时间，就想着做一个，这个板子的目标是： 可扩展 闭环 尽可能多的接口 尽可能小 （不喜欢太大的板子） i2c接口 （单纯的不喜欢spi） 6层板 （前两天看见6层板免费了，还有盘中孔工艺） 芯片选型气阀主要是pwm信号来控制的，在半岛小芯上面根据自己的需求筛选了一下芯片，最终选定了一款16路pwm芯片和adc芯片，以及一个附加的参考电压芯片。 pca9685 一款led驱动芯片 有62个可选地址 ltc2497 adc芯片 有28个可选地址 lt1236-5 5v参考电压芯片 所以最终理论最大气阀接口数量为 16*28&#x3D;448 足够了 电路设计pwm信号通过运放进行放大驱动气阀，adc读取气阀反馈值，通过主控芯片进行闭环运算。 整体参考官方手册进行设计，有两个要注意的是： 输入电压12V 需要降压电路 5V 3.3V 都需要，比较麻烦 结果如下： pcb 绘制这里闹了笑话 一开始搞不清 过孔 埋孔 盲埋孔（读者请自行百度）画了一堆盲埋孔（制作工艺复杂）嘉立创无法生产，后来又在孔的直径上面出了问题 免费直径 0.45 最终还是画好了 结果如下 不同颜色代表不同的层 关于6层板的层定义这里不再写。 芯片采购板子大部分都直接smt贴片了，只有三个芯片自行邮寄 这里又被淘宝坑了一波，他没货不跟我说，也怪我，耽误了5天 芯片不到pcb都不做！！！！嘉立创规则。。。。。。我的错 到货讲真 到货后大吃一惊 如图 芯片漏贴一个(芯片封装我买错了,打了电话芯片才寄过来自己手动改造了一下) 2.54排针弄成了1.27排针………. TODO 程序验证 结果PWM 没有进行RC滤波处理ADC 转换速率慢7.5SPS 项目上肯定是不能用了 续集无了","tags":["🦾PCB"]},{"title":"invoice_ocr","path":"/posts/3ie04lo/","content":"因最近实验室财务政策(报销的相关事情)有一些改变，需要自己去写入库单，然后去财务处报销，但是我不想手写Word，然后就有了这个工具。 之前财务也有用过一个OCR的工具，但是我觉得不太好用，所以就干脆自己写了一个。 在提高效率的同时，也可以学习一下OCR的相关知识。 用到的库语言当然不用说了，Python。 ocr(文字识别)：百度的OCR api 增值税发票识别（封面也是这里找的） json：用来解析百度OCR的返回值 python-docx：用来生成Word文档 pypdf2：用来生成PDF文档 datetime：用来生成时间戳 思路 从淘宝等网站获取订单发票 用百度OCR识别发票信息 生成Word文档 将发票pdf重命名并归档 效果部分效果图如下： 代码很长且没有注释，但是我觉得很好理解，就不贴了。 其实自己也快忘了hhhh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457from datetime import datetimeimport shutilfrom time import sleepfrom aip import AipOcrimport PyPDF2 as pdfimport jsonimport docximport os&quot;&quot;&quot; 你的 APPID AK SK &quot;&quot;&quot;APP_ID = &#x27;xxxx&#x27;API_KEY = &#x27;xxx&#x27;SECRET_KEY = &#x27;xxxx&#x27;client = AipOcr(APP_ID, API_KEY, SECRET_KEY)&quot;&quot;&quot; 读取pdf &quot;&quot;&quot;def get_file_content(filePath): with open(filePath, &#x27;rb&#x27;) as fp: return fp.read()# 遍历文件夹下所有pdf文件def get_pdffiles(dir_path): import os files = os.listdir(dir_path) pdf_files = [] for file in files: if file.endswith(&#x27;.pdf&#x27;): pdf_files.append(dir_path+&#x27;/&#x27;+file) return pdf_files# 商品类class Commodity: def __init__(self): self.name = &#x27;&#x27; self.type = &#x27;&#x27; self.unit = &#x27;&#x27; self.price = 0 self.tax_rate = 0 self.tax = 0 self.total_price = 0 self.num = 0 # 入库单类# 入库单# Warehouse receiptclass WarehouseReceipt(): def __init__(self, pdf_file_path=&#x27;&#x27;): self.order_num = &#x27;&#x27; self.order_date = &#x27;&#x27; self.supplier = &#x27;&#x27; self.commodity_list = [] self.total_price = 0 self.json = &#x27;&#x27; self.pdf_file_path = pdf_file_path self.company = &#x27;&#x27; self.c_price = &#x27;&#x27; def __str__(self): return &#x27;订单号：&#x27;+self.order_num+&#x27;，订单日期：&#x27;+self.order_date+&#x27;，供应商：&#x27;+self.supplier+&#x27;，总价：&#x27;+self.total_price def ocr(self): # pdf_file_path = &#x27;invoice/1.pdf&#x27; if self.get_pdf_num() &gt; 1: #print(&#x27;pdf文件页数大于1,暂不支持&#x27;) return else: #print(&#x27;pdf文件页数为1&#x27;) #print(&#x27;开始识别&#x27;) #print(self.pdf_file_path) pdf_file = self.get_file_content() self.json = client.vatInvoicePdf(pdf_file) # with open(&#x27;&#123;&#125;.json&#x27;.format(self.pdf_file_path), &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(self.json, f, ensure_ascii=False, indent=4) #print(self.json) def ocr_pic(self): # pdf 转图片 def pdf_to_pic(self): from pdf2image import convert_from_path pages = convert_from_path(self.pdf_file_path, 200) for page in pages: page.save(self.pdf_file_path.replace(&#x27;.pdf&#x27;,&#x27;.jpg&#x27;), &#x27;JPEG&#x27;) pdf_to_pic(self) # 识别图片 image = self.get_pic_content() self.json = client.receipt(image) # 保存json数据 with open(&#x27;invoice/&#123;&#125;.json&#x27;.format(self.pdf_file_path), &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(self.json, f, ensure_ascii=False, indent=4) #print(self.json) def handle_json(self): json_data = self.json # 商品对象列表 self.commodity_list = [] words_result = json_data[&#x27;words_result&#x27;] for i in range(0, len(words_result[&#x27;CommodityTaxRate&#x27;])): # 商品名称 self.commodity_list.append(Commodity()) if i == len(words_result[&#x27;CommodityTaxRate&#x27;])-1: for j in range(int(words_result[&#x27;CommodityTaxRate&#x27;][i][&#x27;row&#x27;])-1, len(words_result[&#x27;CommodityName&#x27;])): #print(i, j) self.commodity_list[i].name += words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;] # self.commodity_list[i]+=(words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;]) else: for j in range(int(words_result[&#x27;CommodityTaxRate&#x27;][i][&#x27;row&#x27;])-1, int(words_result[&#x27;CommodityTaxRate&#x27;][i+1][&#x27;row&#x27;])-1): #print(i, j) self.commodity_list[i].name += words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;] # self.commodity_list[i]+=(words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;]) # 商品单价(含税) # 判断是否含税 if &#x27;%&#x27; in words_result[&#x27;CommodityTaxRate&#x27;][i][&#x27;word&#x27;]: #print(&#x27;含税&#x27;,i) #print(&#x27;ll&#x27;,self.commodity_list) #print(&#x27;ll&#x27;,self.commodity_list[i]) self.commodity_list[i].price = float( words_result[&#x27;CommodityPrice&#x27;][i][&#x27;word&#x27;]) + float(words_result[&#x27;CommodityTax&#x27;][i][&#x27;word&#x27;]) / int(words_result[&#x27;CommodityNum&#x27;][i][&#x27;word&#x27;]) #print(&#x27;%&#x27;) else: self.commodity_list[i].price = float( words_result[&#x27;CommodityPrice&#x27;][i][&#x27;word&#x27;]) # 商品类型(只能单页) if words_result[&#x27;CommodityType&#x27;]: self.commodity_list[i].type = words_result[&#x27;CommodityType&#x27;][i][&#x27;word&#x27;] #self.commodity_list[i].price = words_result[&#x27;CommodityPrice&#x27;][i][&#x27;word&#x27;] # 单个商品总价 self.commodity_list[i].total_price = self.commodity_list[i].price * \\ int(words_result[&#x27;CommodityNum&#x27;][i][&#x27;word&#x27;]) # 处理单价和总价的小数点 self.commodity_list[i].price = round( self.commodity_list[i].price, 2) self.commodity_list[i].total_price = round( self.commodity_list[i].total_price, 2) self.commodity_list[i].num = int( words_result[&#x27;CommodityNum&#x27;][i][&#x27;word&#x27;]) # 商品单位 self.commodity_list[i].unit = words_result[&#x27;CommodityUnit&#x27;][i][&#x27;word&#x27;] self.total_price = float(words_result[&#x27;AmountInFiguers&#x27;]) self.order_date = words_result[&#x27;InvoiceDate&#x27;] self.company = words_result[&#x27;SellerName&#x27;] self.c_price = words_result[&#x27;AmountInWords&#x27;] # 商品名称 #print(self.commodity_list) for i in self.commodity_list: #print(i.name) #print(i.price) #print(i.total_price) #print(i.num) #print(i.type) #print(i.unit) pass # 生成入库单word文件 def generate_word(self): from docx.shared import Pt from docx.oxml.ns import qn from docx.shared import Inches from docx.enum.text import WD_ALIGN_PARAGRAPH import datetime from docx.enum.table import WD_TABLE_ALIGNMENT from docx.enum.table import WD_ALIGN_VERTICAL from docx.enum.text import WD_PARAGRAPH_ALIGNMENT # 生成word文件 doc = docx.Document() # 设置所有字体为宋体 doc.styles[&#x27;Normal&#x27;].font.name = u&#x27;宋体&#x27; doc.styles[&#x27;Normal&#x27;]._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), u&#x27;宋体&#x27;) # 设置所有段落的行距为1.5倍 doc.styles[&#x27;Normal&#x27;].paragraph_format.line_spacing = 1.5 # 设置 title = doc.add_paragraph(&quot;浙江工业大学耗材入库单&quot;, style=&#x27;Normal&#x27;) # 设置标题字体大小 title.runs[0].font.size = Pt(18) # 加粗 title.runs[0].font.bold = True # 设置标题居中 title.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 添加当天时间 today = datetime.datetime.now().strftime(&#x27;%Y年%m月%d日&#x27;) today = doc.add_paragraph(today, style=&#x27;Normal&#x27;) today.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 添加部门公章 doc.add_paragraph(&quot;部门（公章）： 单位：\t元&quot;, style=&#x27;Normal&#x27;) # 设置表格 table = doc.add_table(rows=1, cols=7, style=&#x27;Table Grid&#x27;) # 左下 table.alignment = WD_ALIGN_VERTICAL.CENTER # table.alignment = # table.alignment = WD_TABLE_ALIGNMENT.LEFT # table.alignment = WD_TABLE_ALIGNMENT.BOTTOM # 根据内容自动调整列宽 # table.autofit = True # table.autofitcontent = True # 设置每一列的宽度 table.cell(0, 1).width = Inches(4) table.cell(0, 2).width = Inches(3) # 设置 首行 table.cell(0, 0).text = &#x27;供货单位&#x27; table.cell(0, 1).text = self.company table.cell(0, 2).text = &#x27;入库日期&#x27; table.cell(0, 3).text = self.order_date # 合并单元格 table.cell(0, 3).merge(table.cell(0, 4)) table.cell(0, 5).text = &#x27;入库单号&#x27; table.cell(0, 6).text = self.order_num # 表格 根据内容自动调整 table.allow_autofit = True hdr_cells = table.add_row().cells hdr_cells[0].text = &#x27;序号&#x27; hdr_cells[1].text = &#x27;耗材名称&#x27; hdr_cells[2].text = &#x27;规格型号&#x27; hdr_cells[3].text = &#x27;单位&#x27; hdr_cells[4].text = &#x27;数量&#x27; hdr_cells[5].text = &#x27;单价&#x27; hdr_cells[6].text = &#x27;金额&#x27; for index,i in enumerate(self.commodity_list): row_cells = table.add_row().cells row_cells[0].text = str(index+1) row_cells[1].text = i.name row_cells[2].text = i.type row_cells[3].text = i.unit row_cells[4].text = str(i.num) row_cells[5].text = str(i.price) row_cells[6].text = str(i.total_price) # 合计行 row_cells = table.add_row().cells row_cells[0].text = &#x27;合计&#x27; # 合并单元格 row_cells[1].text = &#x27;(大写)&#x27; row_cells[2].merge(row_cells[3]).merge(row_cells[4]).text = self.c_price row_cells[5].text = &#x27;(小写)&#x27; row_cells[6].text = str(self.total_price) # 添加制表等 doc.add_paragraph(&quot;制表（保管）： 采购： 入库验收：&quot;, style=&#x27;Normal&#x27;) last = doc.add_paragraph( &quot;第一联：存根联\t第二联：财务\t第三联：供货单位（采购）\t第四联：验收人&quot;, style=&#x27;Normal&#x27;) last.runs[0].font.size = Pt(10) last.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 保存文件 doc.save(&#x27;invoice/word/&#x27;+str(self.total_price)+self.company+self.order_date+&#x27;.docx&#x27;) def get_file_content(self): with open(self.pdf_file_path, &#x27;rb&#x27;) as fp: return fp.read() def get_pic_content(self): with open(self.pdf_file_path.replace(&#x27;.pdf&#x27;,&#x27;.jpg&#x27;), &#x27;rb&#x27;) as fp: return fp.read() # 获取pdf页码 def get_pdf_num(self): pdfFileObj = open(self.pdf_file_path, &#x27;rb&#x27;) pdfReader = pdf.PdfFileReader(pdfFileObj) num = pdfReader.numPages return num def cp(self): # 复制并重命名pdf文件 shutil.copy(self.pdf_file_path, &#x27;invoice/pdf/&#x27;+str(self.total_price)+self.company+self.order_date+&#x27;.pdf&#x27;) # 删除原pdf文件 os.remove(self.pdf_file_path) def deal(self): self.ocr() # 捕捉异常 try: self.handle_json() except Exception as e: print(e, &#x27;json文件处理失败&#x27;) # 创建错误日志 with open(&#x27;invoice/log/error-&#123;&#125;.log&#x27;.format(datetime.now().strftime(&#x27;%Y年%m月%d日%H-%M&#x27;)), &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(self.pdf_file_path+&#x27; &#x27;+str(e) + &#x27;\\r &#x27;+str(self.json)+&#x27;\\r &#x27;) #print(e) #print(&#x27;处理json文件出错&#x27;) # 抛出异常 else: #print(&#x27;处理json文件成功&#x27;) print(&#x27;处理json文件成功&#x27;,self.pdf_file_path) # 创建成功日志 with open(&#x27;invoice/log/success-&#123;&#125;.log&#x27;.format(datetime.now().strftime(&#x27;%Y年%m月%d日%H-%M&#x27;)), &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(self.pdf_file_path+&#x27;\\r &#x27;) self.generate_word() self.cp() # options = &#123;&#125; # options[&#x27;pdf_file_num&#x27;] = get_pdf_num(pdf_file_path) # res_pdf = client.vatInvoicePdf(pdf_file, options) # # 保存json数据 # with open(&#x27;invoice/1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(res_pdf, f, ensure_ascii=False, indent=4) def dealdebug(self): self.ocr() # 捕捉异常 self.handle_json() self.generate_word() # options = &#123;&#125; # options[&#x27;pdf_file_num&#x27;] = get_pdf_num(pdf_file_path) # res_pdf = client.vatInvoicePdf(pdf_file, options) # # 保存json数据 # with open(&#x27;invoice/1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(res_pdf, f, ensure_ascii=False, indent=4)# read json# def read_json(file_path):# with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:# json_data = json.load(f)# handle_json(json_data)if __name__ == &#x27;__main__&#x27;: for i in get_pdffiles(&#x27;invoice/new&#x27;): WarehouseReceipt(i).deal() #WarehouseReceipt(&#x27;invoice/new/202205171971483062.pdf&#x27;).dealdebug() # WarehouseReceipt(&#x27;invoice ew\\202209102153729425.pdf&#x27;).deal() # wh1 = WarehouseReceipt(&#x27;invoice/invoice.pdf&#x27;) # with open(&#x27;invoice/invoice.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: # wh1.json = json.load(f) # wh1.ocr() # wh1.handle_json() # wh1.deal() # wh1.handle_json() # wh1 = WarehouseReceipt() # with open(&#x27;invoice/invoice.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: # wh1.json = json.load(f) # wh1.handle_json() # wh1.generate_word() # read_json(&#x27;invoice/invoice.json&#x27;) # read_json(&#x27;invoice/1.json&#x27;) # pdf_file_path = &#x27;invoice/1.pdf&#x27; # pdf_file = get_file_content(pdf_file_path) # options = &#123;&#125; # options[&#x27;pdf_file_num&#x27;] = get_pdf_num(pdf_file_path) # res_pdf = client.vatInvoicePdf(pdf_file, options) # # 保存json数据 # with open(&#x27;invoice/1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(res_pdf, f, ensure_ascii=False, indent=4)# 从文件读取json数据(测试用)# 调用增值税发票识别# res_image = client.vatInvoice(image)# res_url = client.vatInvoiceUrl(url)# res_pdf = client.vatInvoicePdf(pdf_file)# #print(res_image)# #print(res_url)# #print(res_pdf)# 如果有可选参数# options = &#123;&#125;# options[&#x27;pdf_file_num&#x27;] = get_invoice_num(file_path)# res_image = client.vatInvoice(image, options)# res_url = client.vatInvoiceUrl(url, options)# res_pdf = client.vatInvoicePdf(pdf_file, options)# #print(res_image)# #print(res_url)# #print(res_pdf)","tags":["Python","OCR"]},{"title":"qt_study","path":"/posts/307ko19/","content":"Now现在在悄咪咪的学qml(为什么悄咪咪?自己悟) 等项目有需要再去光明正大的学Widget 来看看最近的小玩意吧 mac 授权 小工具(功能完全实现) 串口助手(还在写) 因虽然之前学习过一些MFC的相关知识,但是缺少对整体的学习,最近需要用到QT,顺便也系统的学习一下QT的相关知识。 但是传统QT写的界面非常简陋,一点也不好看,最近正在找办法写个好看的.哪怕是Python自带的tkinter都有很好看的主题可以选择. 还在找办法写个好看的,但是目前还是没有找到好的方法,先系统的学着吧. 好看的同时我还想保证兼容性和速度,难哇! Qt Widgets 与 Qt Quicker这个官方视频讲的很不错,建议观看 Qt 版本区别 Qt4.8.7是Qt4的终结版本，是Qt4系列版本中最稳定最经典的（很多嵌入式板子还是用Qt4.8），其实该版本是和Qt5.5差不多时间发布的。（大版本之间存在同时开发维护） Qt5.6.3最最后支持xp系统的长期支持版本，Qt5.7.0是最后支持xp系统的非长期支持版本。 Qt5.12.3是最后提供mysql数据库插件的版本，往后的版本需要自行编译对应的mysql数据库插件，官方安装包不再提供。 Qt5.12.5是最后样式表性能最高的版本，经过酷码大佬查阅代码发现此后版本的样式表源码中为了修复一个bug做了循环嵌套设置，导致性能急剧下降，界面越多性能暴降10倍以上。 Qt5.14.2是最后提供二进制安装包的版本，后面的版本都需要在线安装。 Qt5.15系列是最后支持win7的版本，后面的Qt6系列版本需要更改源码编译才能支持，这对于小白来说难于上青天。_Qt_5.15 Qt 5.15 LTS 维护至 2023年5月29日 算算我毕业都2024了 所以 干脆QT6吧! 版本选择一图看懂Qt版本选择","tags":["⌨️Qt"]},{"title":"Python_study","path":"/posts/3ahvaci/","content":"虽然之前学过不少 python 的知识，但是还是没有系统的学习过一些基础知识，补一下。参考书 Python 基础教程(第 3 版)_百度百科 丑话说在前面只记一下易错点和之前不会的点吧，个人向。 大量 复制粘贴 不喜勿看 因篇幅较长,请移步至Document","tags":["💻Code"]},{"title":"cloudreve配置修复","path":"/posts/49u3l9/","content":"初最近通过 Cloudreve 搭建了实验室网盘系统，但是在使用时遇到一个 bug：无法上传大于 1MB 的文件，下面来讲讲修复之路。 启拿到问题当然要找找问题所在，方可对症下药， 如图所示，报错奇奇怪怪，也看不懂，拿去百度搜索也搜不到，起初是以为nginx的反向代理问题，所以去尝试修改nginx的配置文件。 修改多次无果，我开始换nginx版本，从二进制版本换为编译版本，无果 网上找了一些教程，发现可能是nginx重启不彻底，手动搜索进程进行重启，无果 潮问题没解决，我临时换了其他网盘去用，但是解决不了问题，心里始终不舒服，所以继续花时间找原因。 宝塔？？？ 前去找这个报错的来源 找了半天找到了这个 看了下里面的日志，果然，就是他 终你问我什么结果，当然是删掉这个插件了 修改了一下配置，毕竟网站安全也很重要","tags":["🦾Cloudreve","🦾Bug","🦾Nginx","🦾宝塔"]},{"title":"C++学习","path":"/posts/21r8od0/","content":"因目前 c++的学习主要是针对三个方向 基本语法 数据结构 QT(能用就行的地步) 参考书: C++ Primer Plus（第 6 版） 数据结构、算法与应用 C++语言描述原书第 2 版 Qt 5.9 C++开发指南 (王维波 栗宝鹃 侯春望) Qt5 开发及实例（第 3 版） (陆文周) 因篇幅较长,请移步至Document","tags":["💻Code","🦾C++","🦾Study"]},{"title":"学习路线","path":"/posts/1s2b6vp/","content":"前两天收到了导师发的学习清单，准备正式开始梳理自己未来的学习路线，在这之前一直都很迷茫，下面的路线有很多交叉的地方，需要融会贯通。 现在初步只是思维导图，后续我将根据自己的情况进行补充计划。 目前主要学习科目：机器人导论 Freertos 当前的重点c++主要是数据结构和c++的基础主要参考书籍为C++_Primer_Plus Data-Structures-Algorithms-and-Applications-in-Cpp-Second-Edition还有 QT 仓库地址wxydejoy&#x2F;cpp_study · GitHub embeded systemstm32esp32Linux这个只能边做边学 scientificmatlab配合机器人导论 robotics机器人导论视频课程 Python实战 练习 脚本 机器学习 otherslatex正则 2022 级新生学习清单零、必会工具软件WORD、PPT、excel、solidworks、CAXA&#x2F;CAD、matlab、LABVIEW一、基础理论与方法0、高等数学、线性代数、复变函数、概率论、矩阵理论1、数值计算2、数学建模3、实验设计与分析二、专业基础0、机械制图、机械原理、机械设计、理论力学中的力学与运动学动力学原理与方法、单片机原理、经典控制论1、电机拖动、传感器原理、人工神经网络、计算机接口与控制、气压&#x2F;液压传动与控制、信号处理三、机器人研究方向1、机器人学导论2、ROS 系统3、美国机器人路线图 2020 机器人2020 版机器人路线图 架构与设计实现 移动性 抓取与操作 感知 规划与控制 学习与适应 多机器人系统 人机交互 基础知识 基本的英文 学会使用 科学上网 线性代数 https://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html 微积分 理论力学 Matlab or Python 控制理论 数字电路与模拟电路 一点点单片机 Linux 和 C 语言 基本的 3D 设计 入门主要工具书 机器人学导论（原书第 4 版） 空间变换 运动学 雅可比矩阵 动力学 控制 实践 动手 Penn’s Robotics Specialization ROS 进阶 数学 Modern Robotics 控制 运动规划 机器学习 强化学习 最新论文 科研子主题 1数值计算数学建模嵌入式（本科初步了解，研究生初期深入学习）开发平台 CPU: Intel x86 x64, ARM64 MCU 编程：C51, STM32 FPGA 嵌入式开发软件 Keil uVision, STM32Cube, JTAG debugger, System Viewer 嵌入式 Linux Bootloader, Driver, … 实时操作系统 uCOS, FreeRTOS, ROS（严格来说是 ROS2） 外设 Timer, ADC &#x2F; DAC, ROM &#x2F; RAM, PWM, I&#x2F;O &#x2F; GPIO, … 执行器 电机(步进, 无刷, 舵机, …), 电调, FOC 传感器 陀螺仪, 加速度计, 超声波, 红外, … 电路电子元件 电容, 电阻, 开关, 二极管, 晶振… PCB 设计, 元件焊接 通信协议 Bluetooth, Zigbee, Wifi, UART, TCP, UDP, I2C, … 仪器 万用表, 示波器, 信号发生器, 逻辑分析仪, … 总路线其他编程 Python 作为兴趣 or 工具 作为机器学习等相关知识的基础 AHK 键盘脚本，提高效率 软件 收集各种小工具 52pojjie Repo Github 日常闲逛 机械（本科）本科完成所有知识的学习，研究生期间根据未来方向加深图学 基本二维图纸的绘制 力学 理论力学 材料力学 热力学 有限元方法 机械 机械原理 机械设计 基础电学 电路基础 电工与电子技术 材料与工艺 工程材料 金属工艺学 基本控制 测试与传感技术 微机原理与结构技术 单片机原理及应用 CAD&#x2F;CAM 数控技术及应用 机电控制系统分析与设计 生产 互换性与技术测量 制造技术基础 机械制造工艺学 管理参考链接嵌入式经典书籍分享电子科技大学软件学院本科阶段计算机体系结构学习&amp;嵌入式开发的公开课&#x2F;书籍&#x2F;Blog&#x2F;资料整理嵌入式，计算机常用电子书籍整理开源机器人学学习指南","tags":["🦾Python","🦾学习","🦾路线","🦾机器人","🦾嵌入式","🦾科研","🦾其他"]},{"title":"StepperMotor","path":"/posts/1325oa2/","content":"&#x3D;&#x3D;文章内容大部分来源于网络，仅做摘抄笔记。&#x3D;&#x3D; 定义步进电机是一种将电脉冲信号转换成相应角位移或线位移的电动机。每输入一个脉冲信号，转子就转动一个角度或前进一步，其输出的角位移或线位移与输入的脉冲数成正比，转速和角加速度与脉冲频率成正比（在非超载的情况下）。因此，步进电动机又称脉冲电动机。 步进电机作为一种可控制用的特种电机，利用其没有累计误差的特点，广泛的用于各种开环控制。 学习资料[野火]电机应用开发实战指南 — [野火]电机应用开发实战指南—基于 STM32 文档 步进与伺服这个问题从当年开始学习伺服电机就分不清楚，这里放个视频，讲的不错。 6 分钟讲透伺服电机与步进电机的区别_哔哩哔哩_bilibili &#x2F;&#x2F;","tags":["⚙️Machine","🦾StepperMotor"]},{"title":"ESP32","path":"/posts/3foj6j8/","content":"初芯片涨价、支持国产、物联网、方便好用、支持低代码 这些都是选择ESP32的原因之一 使用方法AT指令可以使用简单的AT指令实现一些比较常用的功能 这里丢个链接AT 固件 - ESP32 - — ESP-AT 用户指南 latest 文档 C&#x2F;C++语言编程 VScode 不建议小白使用，网上例程少，上手慢。 初次编译慢，但后续修改方便，配合上vscode的错误提示，还可。 这个是我目前在用的，因为AT指令不能完全满足我的需求，所以只能自己敲代码了。 当然你也可以选择arduino，不过我觉得它又丑又慢，而且我本身经常用vscode。 通过官方插件，日常使用还是很不错的。 Arduino 每次修改都要完全重新编译。 又丑又慢，不过胜在编程操作简单。 而且网上有很多例程，可以借鉴，开发效率稍微高点，建议新手使用。 一些问题 不建议使用esp32的ADC接口，精度较低。 AT指令无法调试PWM，暂未找到解决办法。 ESP32资源有限，只能用在小项目或者副芯片。","tags":["💻嵌入式"],"categories":["💻Code"]},{"title":"STM32&Cubeide","path":"/posts/2fsd2a9/","content":"初 如图所示，stm32有很多种ide，CubeIde综合了其他软件的特点，是st公司推出的一款软件，然鹅，选择stm32的最直接，最简单的原因是它有黑色主题！！！ 由于网上资料较少，所以整理如下笔记。 Printf &amp; Scanf 重定向 取消编译syscalls.c文件或者删除与以下代码相冲突的代码。 添加retarget.h 和 retarget.c （点击即可下载代码） 在main.c中#include &quot;retarget.c&quot; retarget_init(); 完成以上步骤即可 Stlink 调试注意事项接线图如下 另外32最小板使用cubeide调试时一定要5v供电，否则会报错找不到设备。 Muselab DAP 仿真器 DAPLink真的很不错，可以使用cubeide调试，而且调试器很小，还有串口。 使用 DAPLink 配合 cubeide 非常舒服，但是不知道为什么我的不会自动reset，可能是换了国产芯片的原因吧。 定时器公式（截图来自b站洋桃电子视频） 仍在学习中！！！","tags":["🦾STM32"]},{"title":"2021年终总结","path":"/posts/2h3skbi/","content":"因其他博主的年终总结都在元旦或者春节，而我，喜欢在一件大事结束之后进行总结。从去年这个月到现在，我的学习生活中最重要的一件事就是考研，那我就沿着考研的时间线来进行总结。 总的来说，折腾博客从未停止，可以说博客陪我考研，而且是&#x3D;博客是一个很好的倾述地点，在这里，由衷的感谢各位朋友，还有正在看文章的你。 下面的复盘主要是两个方面 考研 or 博客 初三月份，刚刚开学没多久，课程表如图所示（教师已打码） 那时还要上课，但是课程不多，其实三月前就已经确定好了考本校。三月就开始做高数（张宇的基础题）和英语（背背单词什么的），其实三月份并不认真，三天打鱼两天晒网，效率一般，但胜在心态比较好，当时的计划是慢慢适应考研生活，为后面集中精力学习打好心态基础。 三月底，我买了人生中第一个域名，并且搭建了第一个正式的博客 那会刚刚知道 Github，对很多事情还是很陌生，Git 也不会用。 4 月状态已经好很多了，每天都能做到在教室学习（教室 5 楼基本没有人）学习效率也还可以。 博客这边就是经常魔改，瞎折腾。当时还很喜欢逛酷安，甚至莫名其妙上了一次推荐。 中 5 月份，博客这边还在痴迷图床，想要找到一个安全稳定的图床，想用 onedrive 做图床，甚至还为此通宵。 5 月底，视觉识别课程开始编写程序，我就在寝室摸索了几天，最后做的还不错。这里不得不吐槽一下当时的队友（已经记不清名字了），啥也不干，人家忙的很，当然，没干活的最后给了 5%的分数，参与分。 5 月份学习具体在做什么已经不知道了，也找不到记录。。。。 6 月 按部就班吧，心态好像还可以，忙着各种大作业 7 月开始打卡日记，具体内容去日记看吧。 7 月 因为有期末考试，实习参观等等，心态很差，基本三天打鱼两天晒网，没学多少。 说到这里 不得不提吉利余姚 当时去参观 开工资 3000 我们人傻了 老师也傻了 笑而不语 夏令营表现还行，但拿到了优秀营员，这里要感谢机器人视觉识别课程的老师，让我有东西可以讲。 7 月底进行了整体规划(实际上是心态崩了，不想学) 潮8 月 最肝的一个月，因为图书馆只开两层，每天都要早期去占位，一坐就是一天。那段时间比较刻苦，现在想想也是很怀念。 9 月我好像就开始看政治了 最后政治考的一般般 对这东西确实不敏感 9 月 学校开学，整个学校都开始乱糟糟的，自然心态也不是很好。 其实从开始备考到 10 月左右吧，游戏基本没断过，算是一个情绪的出口。 但是之后因为时间紧张还是停掉了。 10 月 想国庆回家来着，但没回 11 月 开始背政治 12 月 考试 2 月底 成绩 406 3 月底 复试 总总的来说，这一年酸甜苦辣咸有，所有的付出都是值得的。 刚开始写这篇文章感觉可以写很多字，但是越到后面，越发现没什么可以写，每天都是重复而机械的日子，但偶尔也有一些收获，这一年让我认清了很多事情，也重新认识了一些人，总之这一年感谢自己的努力，也感谢身边人的照顾。","tags":["Life"]},{"title":"Texttool","path":"/posts/1v242pf/","content":"To practice my English skill, I will use English to finish my idea.Because of my study, I have to finish it later, but trust me, I will finish it. IntroduceIn our daily life, we need to process the sentences, which includes chaotic characters, usually. To solve this problem, I prepare to compile my own tool. Lanage Python UI Tkinter The reason why I use Python and Tkinter is that I have used before. Meanwhile, I can finish it quickly. Feature Real-time processing Usage record Adaptive interface Small function with my heart Character conversion Punctuation modification Spaces and blank lines Links convert Markdown shortcut Find and Replace so on ProcedureContinuous updating Real-time processing Usage record Adaptive interface 1234567891011121314151617181920def window(): root = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称 screenWidth = root.winfo_screenwidth() # 屏幕宽度 screenHeight = root.winfo_screenheight() # 屏幕高度 w = 550 # 窗口宽 x = (screenWidth - w) / 2 # 窗口左上角x轴位置 y = (screenHeight - w) / 2 # 窗口左上角y轴位置 root.geometry(&quot;%dx%d+%d+%d&quot; % (w, w, x, y)) # 表示距离屏幕左上角(400,200) root.title(&quot;Text tool&quot;) # 窗口的标题 root.geometry(&quot;550x550&quot;) # 窗口的大小 root.configure(bg=&#x27;white&#x27;) # root.iconbitmap(&quot;snake.ico&quot;) maintext = Text(root,bg=&#x27;#2B2B2B&#x27;,borderwidth=0,font=(&#x27;microsoft yahei&#x27;, 14, &#x27;bold&#x27;),foreground=&#x27;white&#x27;) maintext.place(relx=0, rely=0, relwidth=1, relheight=1) root.mainloop() # 让程序继续运行，同时进入等待与处理窗口事件，放在程序最后一行 Small function with my heart Character conversion Punctuation modification Spaces and blank lines Links convert Markdown shortcut Find and Replace Final","tags":["💻Code","🦾Study","🦾Python","🦾Tkinter"]},{"title":"机械工程专业复试复习","path":"/posts/jugpa0/","content":"一些重点材料选用的一般原则 1.材料的力学性能: 根据零件的工作条件、损坏(或失效)形式 , 选择满足力学性能的材料。 2.材料的工艺性能:对零件加工生产有直接的影响,甚至是决定性的。 3.材料的经济性:主要是性价比。 润滑油润滑在工程中的应用最普遍，常用的供油方式有：滴油润滑、浸油润滑、飞溅润滑、喷油润滑、油雾润滑等 齿面磨损 齿面点蚀 齿面胶合 塑性变形 抗拉强度、抗压强度、抗弯强度、抗剪强度、抗扭强度等。 体心立方晶格 面心立方晶格 密排六方晶格 点缺陷 线缺陷 面缺陷 铁素体 奥氏体 渗碳体 珠光体 莱氏体 包晶转变反应式、共晶转变反应式、共析转变反应式。 工业纯铁 ( ingot iron ) 共析钢 ( eutectoid steel ) 亚共析钢 ( hypoeutectoid steel ) 过共析钢 ( hypereutectoid steel ) 共晶白口铁 ( eutectoid white iron ) 亚共晶白口铁( hypoeutectoid white iron ) 过共晶白口铁( hypereutectoid white iron ) 界温度以上 30 ～ 50℃ 随炉冷却 退火 消除应力;降低硬度;细化晶粒;均匀成分;为最终热处理作好组织准备。界温度以上 30 ～ 50℃ 空气冷却 正火 消除应力;调整硬度;细化晶粒;均匀成分;为最终热处理作好组织准界温度以上 30 ～ 50℃ 水、油冷 淬火 为了获得马氏体组织,提高钢的硬度和耐磨性。A1 线以下某个温度,保温一段时间,然后冷却到窒温。 回火 消除淬火应力,降低脆性;稳定工件尺寸;调整淬火零件的力学性能。 最大拉应力（第一强度）理论：最大伸长线应变（第二强度）理论：最大切应力（第三强度）理论：畸变能密度理论（第四强度理论）： 由于机械、动力行业遇到的载荷往往较不稳定，因而较多地采用偏于安全的第三强度理论；土建行业的载荷往往较为稳定，安全系数的估计较准确，因而较多地采用第四强度理论。 变应力 疲劳断裂 干摩擦，边界摩擦，流体摩擦，混合摩擦 磨粒磨损 疲劳磨损 粘附磨损 冲蚀磨损 腐蚀磨损 微动磨损 润滑油 润滑脂 固体润滑剂 矩形螺纹三角形螺纹梯形螺纹锯齿形螺纹 圆柱螺纹 圆锥螺纹 管螺纹 最大应力发生在带的紧边开始绕小带轮处 n 工程图学 机械制图第一次螺纹连接 第二次螺纹紧固件及键、销 第三次零件画图 第四次零件图技术要求 第五次零件读图 第六次装配图拼图 第七次装配拆图 第八次装配拆图 第九次装配图拆 大学物理这个就大致看一下吧！ 光量子（光子）假设，光电效应 康普顿效应 光的干涉、偏振、衍射 电工电子技术找到了之前整理的思维导图，转了一下格式。 半导体8.1 半导体的基础知识和 PN 结 p 型半导体 n 型半导体 pn 结 8.2 半导体二极管 稳压管 8.3 晶体三极管 基本组成 集电极 c 基极 B 发射极 E 分类 PNP NPN 放大作用的条件 发射结正向偏置 集电结反向偏置 三个工作区 +-放大区 ++饱和区 –截止区 8.4 特殊三极管 基本放大电路基本交流放大电路 耦合电容的作用 C1 用来隔断放大电路与信号源之间的直流通路 C2 用来隔断放大电路与负载之间 的通路 静态分析 将电容断路 三个公式见课本 P139、 图解法 横坐标交点 Uce 纵坐标交点 Ic 动态分析 电容通路 微变等效电路分析法 输入电阻 输出电阻 射极输出器 集成运算放大器集成运放概述 电压传输特性 饱和区 线性区 理想运放只有饱和区 放大电路中的负反馈 串并联与电流电压判断 反馈信号和输入信号相连为并联反之为串联 输出直接连反馈，为电压，反之为电流 负反馈的作用 - 降低放大倍数 - 提高放大倍数的稳定性 - 扩展通频带 - 减小非线性失真 - 对输入电阻和输出电阻的影响 - 输入电阻 - 串联提高 - 并联降低 - 输出电阻 - 电压降低 - 电流增高 集成运放的基本运算电路 比例运算 同相 反相 电压跟随器 加法运算 差动运算（减法） 积分运算 微分运算 信号处理中常用的运算放大电路 采样保持电路 电压比较器 有源滤波器 有源低通滤波器允许低频段的信号通过，阻止高频段的信号通过。 信号发生电路 正弦信号发生器 正弦信号发生器的振荡条件 幅度平衡条件 相位平衡条件 组成 放大电路 （右） 正反馈电路 选频电路（左） 稳幅电路 RC 桥式正弦波振荡电路 矩形波发生器 三角波发生器 锯齿波发生器 使用运放应注意的几个问题13 时序逻辑电路集成触发器 基本 RS 触发器 同步 RS 触发器和 D 锁存器 同步 RS 触发器 D 锁存器 正边沿触发的 D 触发器 负边沿触发的 JK 触发器 T 触发器 时序逻辑电路 时序逻辑电路的分析方法 寄存器 计数器 12.组合逻辑电路基本逻辑关系 与门 或门 非门 基本运算规则 一般 交换律 A ＋ B&#x3D; B ＋ A A·B &#x3D; B ·A 自等律 A ＋ 0 ＝ A A · 1 ＝ A 互补律 结合律 A ＋ B ＋ C &#x3D; (A ＋ B)＋ C&#x3D; A ＋( B ＋ C ) A · B · C &#x3D; ( A · B ) · C&#x3D; ( C · A ) · B 要记的 0-1 律 A ＋ 1&#x3D; 1 A · 0&#x3D; 0 摩根定律 重叠律 A ＋ A ＝ A A · A ＝ A 吸收律 逻辑关系的表示与化简 最简与或式 与项最少，与项中的变量最少 合并项法 吸收法 消去法 配项法 TTL 与非门电路 TTL 与非电路 TTL 三态与非门电路 集电极开路“与非”门电路 CMOS 门电路 组合逻辑电路编码译码和数字显示 编码器 将信息转换成二进制码 译码器 将二进制码转换成相应信息 数字显示 11.稳压电源和大功率电子电路直流稳压电源 单相桥式整流电路 滤波电路 串联型稳压电路的工作原理理论力学第 1 章 静力学公理和物体的受力分析静力学：研究物体的受力分析、力系的等效替换（或简化）、建立各种力系的平衡条件的科学。 刚体：在力的作用下，其内部任意两点间的距离始终保持不变的物体。 力：物体间相互的机械作用，作用效果使物体的机械运动状态发生改变。 力的三要素：大小、方向、作用点。力是矢量。 力系：一群力(平面汇交力系、平面平行力系、平面力偶系、平面任意力系、空间汇交力系、空间平行力系、空间力偶系和空间任意力系)。 等效力系：一个力系作用于物体的效果与另一个力系作用于该物体的效果相同。 平衡力系：与零力系等效的力系。 平衡：物体相对惯性参考系（如地面）静止或作匀速直线运动。 受力分析：分析物体（包括物体系）受哪些力，每个力的作用位置和方向，并画出物体的受力图。 力系的等效替换（或简化）：用一个简单力系等效代替一个复杂力系。 力系平衡条件：建立各种力系的平衡条件，并应用这些条件解决静力学实际问题 。 公理 1 力三角形 公理 2 二力平衡条件 公理 3 加减平衡力系公理 推论 1 力的可传性 推论 2 三力平衡汇交定理 若刚体受三个力作用而处于平衡，且其中二力作用线相交于一点，则这三个力必位于同一平面内，且它们的作用线必定汇交于一点。 公理 4 作用与反作用定律 公理 5 刚化公理 自由体：能在空间任意运动的物体 非自由体：运动受到某些其它物体限制的物体 约束：对非自由体的运动起限制作用的物体 约束力：约束作用在被约束物体上的力 主动力：约束反力以外的已知力。（可主动改变物体运动状态） 几种常见约束类型 1、光滑接触面约束 2、柔性约束 3、光滑铰链约束—向心轴承 3、光滑铰链约束—铰链 4、滚动支座 5、球铰链 6、止推轴承 7、二力杆约束 画受力图的步骤: 选定研究对象，画出所选研究对象的隔离体图。 画研究对象上受的所有主动力、主动力偶。 根据约束类型，画全部约束反力。 第 2 章 力系的等效与简化 平面汇交力系平面汇交力系：各力作用线在同一平面内且交于一点。 力多边形法则 平面力对点之矩·平面力偶力对点之矩是力对刚体的转动效应的度量。 力对点之矩：一个代数量，绝对值等于力的大小与力臂的乘积。力使得物体绕矩心逆时针转向为正，反之为负。 平面汇交力系的合力对任一点之矩，等于各分力对同一点之矩的代数和。 力偶的定义：大小相等、方向相反、不共线的两个平行力所组成的力系 力偶在任意坐标轴上的投影等于零. 力偶对任意点取矩都等于力偶矩，不因矩心的改变而改变. 只要保持力偶矩不变，力偶可在其作用面内任意移转，且可以同时改变力偶中力的大小与力臂的长短，对刚体的作用效果不变. 平面任意力系的简化力的平移定理：可以把作用在刚体上点 A 的力平行移动到任一点，但必须同时附加一个力偶，这个附加力偶的矩等于原来的力对新作用点的矩。 平面任意力系向一点的简化·主矢和主矩 平面任意力系的平衡条件和平衡方程平面任意力系平衡的充要条件：力系的主矢和对任意点的主矩都等于零 1）选取研究对象； 2）画研究对象受力图； 3）选取投影轴和矩心，列出并解平衡方程。 物体系的平衡·静定和超静定问题 当：未知量数目 ≤ 独立方程数目时，是静定问题（可求解）未知量数目＞独立方程数目时，是静不定问题（超静定问题） 平面简单桁架的内力计算 第 3 章 空间力系总体与第二章类似，不再赘述。 空间汇交力系 空间汇交力系：空间中各力作用线交于一点。 力对点之矩和力对轴的矩 空间力偶 空间任意力系向一点的简化·主矢和主矩 空间任意力系的平衡方程 重心 用实验方法测定重心的位置1）悬挂法2）称重法 第 4 章 摩擦 滑动摩擦 摩擦角和自锁现象 物体处于临界平衡状态时，全约束力和法线间的夹角—摩擦角 全约束力和法线间的夹角的正切等于静滑动摩擦因数 考虑摩擦时物体的平衡问题 滚动摩阻的概念 至此静力学结束，运动学开始。 第五章 运动学基础第六章 点的运动点的运动规律：研究点的运动就是描述每一瞬时点在参考坐标系中相对于基点的位置。 运动方程：用数学式表示的运动规律。 轨迹：点在空间运动时所经过的路线称为该点的轨迹。 速度和加速度 研究的基本条件：参考系，基点。 常用研究方法：矢量法、直角坐标法、弧坐标法，另外还有如极坐标法、柱坐标法等。 第七章 刚体的基本运动7-1 刚体的平动7-2 刚体的定轴转动7-3 转动刚体内各点的速度和加速度7-4 轮系的传动比7-5 以矢量表示角速度和角加速度以矢积表示点的速度和加速度 第八章 点的复合运动8-1 动点、动系、静系与三种运动 动点(通常为某物体上的确定点) 动参考坐标系（动系）通常将固连在相对于地球运动的参考体上的坐标系称为动参考系（是无穷大的）。 静参考坐标系（静系）通常将固定在地球上的坐标系称为静参考系。 绝对轨迹、绝对速度、绝对加速度 相对轨迹、相对速度、相对加速度 牵连轨迹、牵连速度 、牵连加速度 绝对运动 ＝ 牵连运动 ＋ 相对运动 8-2 速度合成定理 矢量方程式，相当两个标量方程式; 建立了特定瞬时三种运动之间的速度关系，可避免列写运动方程及求导处理，直接求得速度。 8-3 加速度合成定理 第九章 刚体的平面运动§9-1 平面运动的分解及其运动方程 §9-2 平面运动中各点的速度 基点法 速度投影定理 瞬心法 §9-3 用基点法求平面运动中各点的加速度 基点法的解题步骤： 选基点和动点写矢量方程 画速度四边形图和加速度矢量图； 求解。 §9-4 运动学综合应用举例 第三篇 动力学 第十章 质点动力学的基本方程§10–1 质点运动微分方程 §10–2 质点动力学的两类问题 已知质点的运动，求作用于质点的力。 已知作用于质点的力，求质点的运动。 混合问题：第一类与第二类问题的混合。 第十一章 动量定理动力学普遍定理简介包括：动量定理、动量矩定理、动能定理。 动量与冲量 动量定理及守恒定理 质心运动定理及守恒定理 质心的位置始终保持不变，质心坐标守恒。 第十二章 动量矩定理§12-1 动量矩计算（转动惯量） §12-2 动量矩定理 §12-3 刚体绕定轴转动微分方程 §12-4 质点系相对质心的动量矩定理 §12-5 刚体平面运动微分方程 第 13 章 动能定理§13-1 质点系和刚体的动能 §13-2 力的功 §13-3 动能定理 §13-4 功率、功率方程、机械效率 §13-5 势力场、势能、机械能守恒定律 §13-6 动力学普遍定理的综合应用 工程材料工程材料这门课当时学的时候正是疫情，讲真，学的很烂，勉强及格的水平。 第一章金属材料的力学性能力学性能是指材料在力的作用下抵抗变形和开裂的性能。 弹性、塑性、韧性、强度、硬度和疲劳强度等。 弹性( elasticity ):金属材料受外力作用时产生变形,当外力去掉后能恢复到原来形状及尺寸的性能。 弹性变形( elastic deformation ):随载荷撤除而消失的变形。 弹性极限( elastic limit ): 4.强度(strength):材料在载荷作用下抵抗变形和破坏的能力。 种类:抗拉强度、抗压强度、抗弯强度、抗剪强度、抗扭强度等。 屈服强度 条件屈服强度 抗拉强度 塑性(plasticity):是指材料在载荷作用下产生塑性变形而不被破坏的能力。 断面收缩率 伸长率 硬度( hardness ):是指材料抵抗其他硬物体压入其表面的能力。 布氏硬度 HB 洛氏硬度 HR 维氏硬度 HV 肖氏硬度 HS 锉刀法 冲击韧性( notch toughness ): 材料在冲击载荷作用下抵抗破坏的能力。 疲劳强度( fatigue strength ):表示材料经无数次交变载荷作用而不致引起断裂的最大应力值。 比强度 ( specific strength ): 材料的强度值与密度值之比。 第二章金属的晶体结构晶体结构的基础知识 实际金属的体结构与晶体缺陷 一.晶体与非晶体的基本概念 晶体(crystal )的基本概念:物体内部的原子(或分子)在三维空间中,按一定规律作周期性排列的固体。晶体物质所具有的性质:固定的熔点;各向异性等。例如,所有的金属、食盐等。 非晶体( non- crystal )的基本概念:物体内部的原子呈散乱分布,其物理和力学性能各向同性。例如,普通玻璃、松香等。 二.晶体学(crystallography)的基本知识 晶格(crystal lattice):用以描述晶体中原子排列规律的空间点阵格架。 晶胞( unit cell ):能完全反映晶格特征的最小几何单元。 晶格常数 ( lattice constant ) : 晶系与布拉菲点阵 晶面(crystal face): 在晶格中由一系列原子所构成的平面称为晶面。 晶面指数(indices of crystallographicplane):用密勒(Miller)指数对晶格中某一晶面进行标定。 晶向(crystal direction): 在晶格中,任意两原子之间的连线所指的方向 晶向指数: 用密勒(Miller)指数对晶格中某一原子排列在空间的位向进行标定。 三.常见的三种晶体结构 体心立方晶格 钠 ( Na ) ; 钾 ( K ) ; 铬 ( Cr ) ;钼 ( Mo ) ; 钨 ( W ) ; 钒 ( V ) ;钽 ( Ta ) ; 铌 ( Nb ) ; α-铁 ( α-Fe ) 等 。 面心立方晶格金 ( Au ) ; 银 ( Ag ) ; 铜 ( Cu ) ;铝 ( Al ) ; 镍 ( Ni ) ; 铂 ( Pt ) ;铅 ( Pb ) ; γ-铁 ( γ-Fe ) 等。 密排六方晶格 ( c&#x2F;a &#x3D; 1.633 )镁 ( Mg ) ; 锌 ( Zn ) ; 镉 ( Cd ) ;α – 钛 ( α – Ti ) ; 铍 ( Be ) 等 。 点缺陷( point defect )空位( vacancy )间隙原子( gap atom)置换原子( substitutional atom) 线缺陷( line defect )螺旋型位错( screw dislocation )刃型位错( blade dislocation ) 面缺陷( surface-defect )晶界( grain boundary ) :晶粒与晶粒之间的界面。亚晶界( sub-boundary ) :相邻晶粒位向很小(一般 1 ～ 2°)的小角度晶界。 第三章纯金属的结晶凝固与结晶的概念结晶的现象与规律同素异晶(构)转变 微小晶核 –&gt; 晶体 过冷现象 ( supercooling )过冷度 ( degree of supercooling )过冷是结晶的必要条件。 固溶体 (solid solution ) 金属化合物 ( metallic compound ) 机械混合物 ( mechanical impurity ) 第四章金属的结晶与相图 第五章铁碳合金相图 铁素体 ( F ) 奥氏体 ( A ) — Austenite 渗碳体 ( Fe3C ) 铁与碳形成的金属化合物。 珠光体 ( P ) 铁素体和渗碳体组成的机械混合物。 莱氏体 ( Ld ) 奥氏体和渗碳体组成的机械混合物。 Fe - Fe3C 相图的建立与分析 包晶反应相图 共晶反应相图 共析反应相图 五个重要的成份点: P、S、E、C、K。 四条重要的线: EF、ES、GS、FK。 三个重要转变: 包晶转变反应式、共晶转变反应式、共析转变反应式。 二个重要温度: 1148 ℃ 、727 ℃ 。 三.典型铁碳合金的结晶过程分析 工业纯铁 ( ingot iron ) 共析钢 ( eutectoid steel ) 亚共析钢 ( hypoeutectoid steel ) 过共析钢 ( hypereutectoid steel ) 共晶白口铁 ( eutectoid white iron ) 亚共晶白口铁( hypoeutectoid white iron ) 过共晶白口铁( hypereutectoid white iron ) 第四节 碳的质量分数对铁碳合金组织、性能的影响 碳的质量分数对平衡组织的影响。 碳的质量分数对力学性能的影响。 碳的质量分数对工艺性能的影响。 对铸造性能的影响。 对锻造性能的影响。 对焊接性能的影响。 对切削加工性能的影响。 钢铁的冶炼。 钢锭的组织碳素钢的分类、编号及用途、质量及缺陷。 杂质元素对钢的质量和性能的影响 有益元素Ø Si — 有很强的固溶强化作用,能脱氧。Ø Mn — 脱氧、去硫,提高钢的强度和硬度。 有害元素:Ø P — 有很强的固溶强化作用,低温韧性差 ( 冷脆 )。Ø S — 能引起钢在热加工时或高温工作下开裂 ( 热裂 )。 气体元素Ø N：钢中过饱和 N 在常温放置过程中会发生时效脆化。加 Ti、V、Al 等元素可消除时效倾向。Ø O：钢中的氧化物易成为疲劳裂纹源。Ø H：原子态的过饱和氢时将降低韧性, 引起氢脆。当氢在缺陷处以分子态析出时，会产生很高内压，形成微裂纹，其内壁为白色，称白点或发裂。 钢锭的组织及其宏观缺陷 镇静钢钢液在浇注前用锰铁、硅铁和铅进行了充分脱氧,Wo&#x3D;0.01%左右,成分较均匀、组织较致密。主要用于机械性能要求较高的零件。 半镇静钢半镇静钢是脱氧过程介于镇静钢和沸腾钢之间的钢,是用锰铁和硅铁进行脱氧。其质量也介于二者之间,可代替部分镇静钢,一般不适于做重要零件。 沸腾钢钢液在浇注仅前进行轻度假脱氧,Wo&#x3D;0.03%～ 0.07%,成分偏析较严重、组织不致密。机械性能不均匀,冲击韧性差,常用于要求不高的零件。 碳素钢的分类 按碳的质量分数分类: 低碳钢: Wc ≤ 0.25% 中碳钢: 0.25% ≤ Wc ≤ 0.6% 高碳钢: Wc &gt; 0.6% 按钢的质量分类: 碳素钢: Wp &#x3D; (0.035% ～ 0.045%) Ws &#x3D; (0.035% ～ 0.050%) 优质碳素钢: Wp &#x3D; 0.035% Ws &#x3D; (0.030% ～ 0.035%) 高级优质碳素钢: Wp ≤ 0.030% Ws &#x3D; ( 0.020%～ 0.025% ) 按钢的用途分类: 碳素结构钢(carbontructuralteel)用于制造各种机械零件、工程构件。一般为低、中碳钢。 碳素工具钢 ( carbon tool steel )用于制造各种工具。一般为高碳钢。 碳素钢编号及用途 碳素结构钢: 优质碳素结构钢45 — Wc &#x3D; 45%00较高锰质量分数的优质碳素结构钢45Mn — Wc &#x3D; 45%00WMn &#x3D; 0.7%～ 1.0% 碳素工具钢 铸造碳钢 第六章钢的热处理 概述 钢在加热时的组织转变 转变温度 奥氏体的形成 奥氏体晶粒度及对力学性能的影响 奥氏体晶粒度: 起始晶粒度:珠光体刚刚转变成奥氏体的晶粒大小。 实际晶粒度:热处理后所获得的奥氏体晶粒的大小。 本质晶粒度:度量钢本****身晶粒在 930℃ 以下,随温度升高,晶粒长大的程度。 奥氏体晶粒大小对钢的力学性能的影响 奥氏体晶粒均匀细小,热处理后钢的力学性能提高。 粗大的奥氏体晶粒在淬火时容易引起工件产生较大的变形甚至开裂。 钢在冷却时的组织转变 钢在热处理时的冷却方式贝氏体转换 上贝氏体 下贝氏体 钢的普通热处理工艺毛坯生产 预备热处理 机械加工 最终热处理 机械精加工 预备热处理 : 退火 ; 正火 最终热处理 : 淬火 ; 回火 退火定义：把零件加温到临界温度以上 30 ～ 50℃,保温一段时间,然后随炉冷却。 目的：消除应力;降低硬度;细化晶粒;均匀成分;为最终热处理作好组织准备。 完全退火 Ac3 + 30 ～ 50球化退火 Ac1 + 30 ～ 50去应力退火 500 ～ 600扩散退火 Ac3 + 150 ～ 250 热处理后的组织 : 原始组织。 正火 定义:把零件加温到临界温度以上 30 ～ 50℃,保温一段时间,然后在空气中冷却。 目的:消除应力;调整硬度;细化晶粒;均匀成分;为最终热处理作好组织准备。亚共析钢 Ac3 + 30 ～ 50共析钢 Ac1 + 30 ～ 50过共析钢 Accm + 30 ～ 50 淬火定义:把零件加温到临界温度以上 30 ～ 50℃,保温一段时间,然后快速冷却(水冷)。目的:为了获得马氏体组织,提高钢的硬度和耐磨性。亚共析钢 Ac3 + 30 ～ 50共析钢 Ac1 + 30 ～ 50过共析钢 Ac1 + 30 ～ 50 钢的淬硬性 ( Hardening of steel ) 定义:是指钢在淬火后所能达到的最高硬度。 影响钢的淬硬性的因素:主要取决于马氏体的含碳量。 钢的淬透性 定义:是指钢在淬火时所能得到的淬硬层 (马氏体组织占 50%处) 的深度。 影响钢的淬透性的因素:主要是临界淬火冷却速度 VK 的大小, VK 越大,钢的淬透性越小。 回火定义:把淬火后的零件重新加温到 A1 线以下某个温度,保温一段时间,然后冷却到窒温。目的:消除淬火应力,降低脆性;稳定工件尺寸;调整淬火零件的力学性能。淬火 + 高温回火 &#x3D; 调质处理名称 | 温度(℃) | 组织 | 用途 |——- | ——- | ——- | ——- | ——-低温回火 | 150 ～ 250 | M 回&#x3D;α0.3%C+ε | 耐磨件中温回火 | 350 ～ 500 | T 回&#x3D;F 针+Fe3C | 粒弹簧等高温回火 | 500 ～ 650 | S 回&#x3D;F 多+Fe3C | 球调质件高温软化 | 650 ～ A1 | P 回&#x3D;F 多+Fe3C | 粒高合金钢 钢的表面热处理工艺工艺的核心:使零件具有“表硬里韧”的力学性能。 表面淬火定义:是一种不改变钢表层化学成分,但改变表层组织的局部热处理工艺。工艺特征:通过快速加热使钢的表层奥氏体化,然后急冷,使表层形成马氏体组织,而心部仍保持不变。常用加工方法：感应加热、火焰加热、电接触加热法表面淬火前,必须对零件进行正火或调质处理,以保证零件有良好的基体。 化学热处理定义:将零件置于一定的化学介质中,通过加热、保温,使介质中一种或几种元素原子渗入工件表层,以改变钢表层的化学成分和组织的热处理工艺。 钢的渗碳 第七章合金钢一.合金元素对钢的组织和性能的影响Ø 合金元素与铁和碳的作用。Ø 合金元素对 Fe-Fe3C 相图的影响。Ø 合金元素对钢的热处理的影响。第二节 合金结构钢普通低合金钢: Q345 Q390 Q460 综合性能好合金渗碳钢 表硬里韧合金调质钢 既强又韧弹簧钢 韧性好滚动轴承钢 高的硬度强度和耐磨性 高的接触疲劳强度 足够的韧性和耐蚀性 高的纯净度易切削钢 适用于高速切削和在自动加工机床上加工的材料。 一.碳素刃具钢 1.性能要求: 高硬度、高耐磨性,有一定的强度和韧性。 二.合金刃具钢( alloy cutting steel ) 低合金刃具钢 ; 高速钢(高硬度、高耐磨性)。 三.合金模具钢( alloy die steel )高的热硬性、高温耐磨性;高的抗氧化能力;高的热强性和足够高的韧性;高的热疲劳抗力( 防止龟裂 );高的淬透性和导热性; 四.合金量具钢 ( alloy measuring steel )高的硬度, HRC62;高的耐磨性;高的尺寸稳定性;足够高的心部韧性;热处理变形小; 尺寸稳定;良好的耐蚀性; 第四节 特殊性能钢不锈钢 ( stainless steel )耐热钢 ( heat – resistant steel )耐磨钢 ( wear – resistant steel ) 第八章有色金属及其合金概述铝及铝合金铜及铜合金滑动轴承合金 第九章机械零件材料的选用材料选用的一般原则 1.材料的力学性能: 根据零件的工作条件、损坏(或失效)形式 , 选择满足力学性能的材料。 2.材料的工艺性能:对零件加工生产有直接的影响,甚至是决定性的。 3.材料的经济性:主要是性价比。 选材的基本过程与失效分析 典型零件的选材 材料力学 材料力学：源于工程，用于工程，是固体力学的分支；性质：机械类各专业的专业基础课；地位：固体力学的基础，工程设计的基础。 研究构件承载能力的一门科学——变形固体 第一章 绪论 材料力学的基本假设 连续性假设——物质不留空隙地充满了整个固体。 均匀性假设——固体内各点处材料的力学性能相同。 各向同性假设——固体内各点沿各方向的力学性质完全相同。 有的同学会问了：这样的假设合理么？怎么处处都有假设？假设的情况能在工程实际中使用么？1）“假设”是人们从工程实际中抽象出来的，并且是经过大量的实践检验的；——假设的可行性2）“假设”有一定的适用范围，只与某一类工程实际问题相对应； ——假设的局限性3）“假设”是人们在处理复杂工程实际问题时，抓住主要矛盾，忽略次要矛盾的结果； ——假设的方法论4）“假设”广泛存在于各类专业技术课中，希望大家认真总结，不要混淆。 ——假设的存在性 拉压、剪切、扭转、弯曲 截面法、内力和应力的概念 小变形假设：δ 远小于构件的最小尺寸，在研究构件的平衡和运动时按变形前的原始尺寸进行计算，以保证问题在几何上是线性的。这样，计算得到了很大的简化。 第二章 轴向拉伸、压缩与剪切 §2-1 轴向拉伸或压缩的概念和实例 §2-2 轴力和轴力图 画轴力图总结： 分段：在外力变化的截面处分段； 标力：截面处内力皆用正向（远离截面）画出； 建轴：x 轴正向规定与截面内力正向一致； 求解：内力计算严格按照平衡方程的矢量式求解； 画图：按照以上计算结果，画轴力图。 §2-3 拉（压）杆内的应力 轴向拉压应力计算总结 一句话：就是在轴力计算基础上除以面积；应力计算：“静力分析” + “几何（横截面）”；即：应力计算中，除了“力”的分析以外，还增加了杆件几何尺寸的考虑。不单纯是力学的分析，还需要考虑杆件的几何因素，特别是杆、轴、梁等的横截面几何度量的影响，这是材料力学的又一个特点。 §2-4 拉（压）杆的变形、胡克定律 §2-5 材料拉伸和压缩时的力学性能 §2-6 许用应力、安全因数和强度计算 关于安全因数的考虑 （1）理论与实际差别：考虑极限应力(s，  0.2，  b，  bc) 、横截面尺寸、荷载等的变异，以及计算简图与实际结构的差异。 （2）足够的安全储备：使用寿命内可能遇到意外事故或其它不利情况，也计及构件的重要性及破坏的后果。 安全系数的取值：安全系数是由多种因素决定的。可从有关规范或设计手册中查到。在一般静载下，对于塑件材料通常取为 1.2 ～ 2.5；对于脆性材料通常取为 2.0 ～ 3.5，甚至更大。 §2-7 拉（压）杆的应变能弹性体因外力作用而变形。在变形过程个，外力所作的功将转变为储存于弹性体内的能量。当外力逐渐减小，变形逐渐消失，弹性体又将释放出储存的能量而作功。在外力作用下，弹性体因变形而储存的能量称为变形能或应变能。 §2-8 应力集中的概念 §2-9 剪切和挤压实用计算 第三章 扭转 §3-1 扭转的概念和实例 受力特征：杆件受垂直于杆轴线的平面内一对大小相等，方向相反的外力偶作用。 变形特征：相邻横截面绕轴线发生相对转动，杆表面纵向线变成螺旋线，但横截面形状与大小未变。 §3-2 传动轴的外力偶矩 扭矩和扭矩图用截面法求扭矩时，建议均假设各截面扭矩 T 为正，如果由平衡方程得到 T 为正，则说明是正的扭矩，如果为负，则是负的扭矩。在画轴的扭矩图，正的扭矩画在 x 轴上方，负的扭矩画在 x 轴下方。 §3-3 纯剪切 切应力互等定理。该定理表明：在单元体相互垂直的两个平面上，切应力必然成对出现，且数值相等，两者都垂直于两平面的交线，其方向则共同指向或共同背离该交线。 单元体的四个侧面上只有切应力而无正应力作用，这种应力状态称为纯剪切应力状态。 结合 Ansys 应力分析 §3-4 圆轴扭转时的应力、强度条件 §3-5 圆轴扭转时的变形、刚度条件 第四章 弯曲内力 §4-1 弯曲的概念和实例 §4-2 梁的载荷、支座及其简化 §4-3 梁横截面上的内力、剪力和弯矩 §4-4 剪力方程和弯矩方程、剪力图和弯矩图 §4-5 载荷集度、剪力和弯矩之间的关系及其应用 第五章 弯曲应力 §5-1 纯弯曲 §5-2 纯弯曲时的正应力 §5-3 横力弯曲时的正应力、正应力强度条件 §5-4 横力弯曲时的切应力 §5-5 提高弯曲强度的措施一、合理安排梁的受力情况 梁的各横截面上的最大正应力都等于材料的许用应力[]时，称为等强度梁。 第六章 弯曲变形 §6-1 挠曲线微分方程 计算较多，不再详细记录 §6-4 提高弯曲刚度的措施一、改善结构形式，减少弯矩数值 二、选择合理的截面形状 三 、选用高强度材料，提高许用应力值 同类材料，“E”值相差不多，“b”相差较大，故换用同类材料只能提高强度，不能提高刚度和稳定性。 不同类材料，E 和 G 都相差很多（钢 E&#x3D;200GPa , 铜 E&#x3D;100GPa），故可选用不同的材料以达到提高刚度和稳定性的目的。但是，改换材料，其原料费用也会随之发生很大的改变！ 四 、改变结构的体系 所谓改变结构的体系来提高梁的刚度在这里是指增加梁的支座约束使静定梁成为超静定梁，例如在悬臂梁的自由端增加一个铰支座，又例如在简支梁的跨中增加一个铰支座。 第七章 简单的超静定问题 §7-1 超静定问题及其解法 §7-2 拉压超静定问题 §7-3 扭转超静定问题 §7-4 简单超静定梁在工程实际中，有时为了提高梁的强度与刚度，或由于构造上的需要，往往给静定梁添加附加支座，从而使得梁上约束反力的数目超过了独立的静力平衡方程数目，这类梁称为超静定梁。 第八章 应力状态和强度理论 §8-1 应力状态的概念 不仅横截面上存在应力，斜截面上也存在应力。不仅要研究横截面上的应力，而且也要研究斜截面上的应力。 §8-2 二向应力状态分析 §8-3 三向应力状态简介 §8-4 广义胡克定律 §8-6 强度理论 最大拉应力（第一强度）理论：认为构件的断裂是由最大拉应力引起的。当最大拉应力达到单向拉伸的强度极限时，构件就断裂。 试验证明，这一理论与铸铁、岩石、砼、陶瓷、玻璃等脆性材料的拉断试验结果相符，这些材料在轴向拉伸时的断裂破坏发生于拉应力最大的横截面上。 脆性材料的扭转破坏，也是沿拉应力最大的斜面发生断裂，这些都与最大拉应力理论相符，但这个理论没有考虑其它两个主应力的影响。 最大伸长线应变（第二强度）理论：认为构件的断裂是由最大拉应力引起的。当最大伸长线应变达到单向拉伸试验下的极限应变时，构件就断裂。 最大切应力（第三强度）理论：认为构件的屈服是由最大切应力引起的。当最大切应力达到单向拉伸试验的极限切应力时，构件就破坏了。 第三强度理论曾被许多塑性材料的试验结果所证实，且稍偏于安全。这个理论所提供的计算式比较简单，故它在工程设计中得到了广泛的应用。 该理论没有考虑中间主应力 σ2 的影响，其带来的最大误差不超过 15％，而在大多数情况下远比此为小。 畸变能密度理论（第四强度理论）：基本假设：畸变能密度是引起材料塑性屈服的主要因素。 适用范围：它既突出了最大主切应力对塑性屈服的作用，又适当考虑了其它两个主切应力的影响，它与塑性较好材料的试验结果比第三强度理论符合得更好。此准则也称为米塞斯（Mises ）屈服准则。 由于机械、动力行业遇到的载荷往往较不稳定，因而较多地采用偏于安全的第三强度理论；土建行业的载荷往往较为稳定，安全系数的估计较准确，因而较多地采用第四强度理论。 这个理论和许多塑性材料的试验结果相符，用这个理论判断碳素钢的屈服失效是相当准确的。 第九章 组合变形§9-1 概述§9-2 拉伸（压缩）与弯曲的组合§9-3 弯曲与扭转的组合 第十章 压杆稳定 §10-1 压杆稳定的概念 §10-2 两端铰支细长杆的临界压力 §10-3 不同杆端约束下细长压杆临界力 §10-4 欧拉公式的适用范围 经验公式 §10-5 压杆的稳定计算 §10-6 提高压杆稳定的措施 第十一章 能量法 §11-1 概述可变形固体在受外力作用而变形时，外力和内力均将作功。对于弹性体，由于变形的可逆性，外力在其相应位移上作的功，在数值上就等于积蓄在物体内的应变能： 𝑉_𝜀&#x3D;𝑊 能量法 ： 利用功和能的概念 𝑉_𝜀&#x3D;𝑊 求解弹性变形固体的位移、变形和内力等的方法。 能量法不仅适用于线弹性体，也适用于非线性弹性体。 §11-2 应变能的计算 §11-3 互等定理功互等定理:位移互等定理: §11-4 卡氏定理线弹性杆系结构的应变能对于杆件上某一载荷之变化率(导数)，等于与该载荷相应的位移。 §11-5 虚功原理 §11-6 单位载荷法 §11-7 用能量法解超静定问题超静定问题解题思路 ：综合考虑静力、几何和物理三方面 第十二章 动载荷 §12-1 概述载荷随时间急剧变化且使构件的速度有显著变化（系统产生惯性力），此类载荷为动载荷。 §12-2 动静法的应用 §12-3 杆件受冲击时的应力和变形冲击：两个物体相对碰撞时，在极短的时间内，速度发生有限的变化，产生很大的相互作用力。由于冲击时间极短， 加速度很难确定，不能用动静法进行分析。通常在以下假设的基础上用能量法作近似计算。假设 Ⅰ：不计冲击物的变形，且冲击物和被冲击物接触后不回弹；假设 Ⅱ：不计被冲击物的质量，被冲击物的变形在线弹性范围内；假设 Ⅲ ：不计冲击过程中的能量损失。 第十三章 疲劳交变应力：构件内随时间作周期性变化的应力。 疲劳与疲劳破坏：结构的构件在交变应力的作用下发生的破坏现象，称为疲劳破坏，简称疲劳 因疲劳破坏是在没有明显征兆的情况下突然发生的，极易造成严重事故。据统计，机械零件，尤其是高速运转的构件的破坏，大部分属于疲劳破坏。 机械原理第一章绪论机构是指一种用来传递与变换运动和力的可动装置。 机器是指一种执行机械运动装置，可用来变换和传递能量、物料和信息。 第二章机构的结构分析 2-1 机构结构分析的内容及目的 2-2 机构的组成 零件是机器中的一个独立制造单元体;构件是机器中的一个独立运动单元体。 2-3 机构运动简图 2-4 机构具有确定运动的条件 2-5 机构自由度的计算 复合铰链 同一运动副 复合平面高副 局部自由度 虚约束 2-6 计算平面机构自由度时应注意的事项 2-7 虚约束对机构工作性能的影响及机构结构的合理设计 2-8 平面机构的组成原理、结构分类及结构分析 2-9 平面机构中的高副低代 第三章平面机构的运动分析 3-1 机构运动分析的任务、目的和方法 3-2 用速度瞬心法作机构的速度分析三心定理:彼此作平面运动的三个构件的三个瞬心必位于同一直线上。 3-3 用矢量方程图解法作机构的速度及加速度分析 3-4 综合运用瞬心法和矢量方程图解法 对复杂机构进行速度分析 3-5 用解析法作机构的运动分析 第四章平面机构的力分析 4-1 机构力分析的任务和方法 (1)驱动力驱动机械运动的力。其特征:与其作用点的速度方向相同或者成锐角;其功为正功，称为驱动功或输入功。 (2)阻抗力阻止机械运动的力。其特征:与其作用点的速度方向相反或成钝角;其功为负功，称为阻抗功。 4-2 构件惯性力的确定 一般力学方法 质量代换法 4-3 运动副中摩擦力的确定 4-4 不考虑摩擦时机构的力分析 4-5 考虑摩擦时机构的力分析 第五章机械的效率和自锁 5-1 机械的效率 搞清楚串并联 50 50 串 25 50 50 并 50 5-2 机械的自锁 (1)自锁现象某些机械,就其机械而言是能够运动的，但由于摩擦的存在，却会出现无论驱动力如何增大，也无法使机械运动的现象。 (2)自锁意义设计机械时，为使机械能实现预期的运动，必须避免机械在所需的运动方向发生自锁;有些机械的工作需要具有自锁的特性，如手摇螺旋千斤顶。 (3)自锁条件机械发生自锁实质上是机械中的运动副发生了自锁。 第六章机械的平衡 6-1 机械平衡的目的及内容机械在运转时，构件所生产的不平衡惯性力将在运动副中引起附加的动压力。 1)刚性转子的平衡刚性转子[n&lt;(0.6 ～ 0.75)nc1]的平衡，是按理论力学中的力学平衡理论进行的。静平衡只要求其惯性力平衡;动平衡同时要求其惯性力和惯性力偶矩的平衡。 2)挠性转子的平衡挠性转子[n≥(0.6 ～ 0.75)nci]的平衡，其平衡是基于弹性梁的横向振动理论。 6-2 刚性转子的平衡计算 静平衡对于静不平衡转子，利用在其上增加或除去一部分质量，使其质心与回转轴心重合，即可使转子的惯性力得以平衡的方法。 静平衡的条件平衡后转子的各偏心质量包括平衡质量的惯性力的合力为零。即 6-3 刚性转子的平衡实验 6-4 转子的许用不平衡量 质径积表示法转子的许用不平衡质径积以[mr]表示，它是与转子质量有关的一个相对量。常用于具体给定的转子，它比较直观又便于平衡操作。 偏心距表示法转子的质心至回转轴线的许用偏心距以[e]表示，它是与转子质量无关的绝对量，用于衡量转子平衡的优劣或衡量平衡的检测精度时，比较方便。 6-5 挠性转子动平衡简述(没有内容) 6-6 平面机构的平衡 机构的部分平衡是对机构的总惯性力只需平衡其中的一部分的平衡。机构的部分平衡有以下几种方法。 第七章机械的运转及其速度波动的调节第八章平面连杆机构及其设计连杆机构设计的基本问题是根据给定的要求选定机构的型式，确定各构件的尺寸，同时还要满足结构条件、动力条件和运动连续条件等。 第九章凸轮机构及其设计 9-1 凸轮机构的应用和分类 9-2 推杆的运动规律 9-3 凸轮轮廓曲线的设计 9-4 凸轮机构基本尺寸的确定 第十章齿轮机构及其设计 10-1 齿轮机构的应用及分类 10-2 齿轮的齿廓曲线 一对齿轮传动是依靠它们的共轭齿廓来实现的。 10-3 渐开线齿廓的喷合特点 10-4 渐开线标准齿轮的基本参数和几何尺寸 10-5 渐开线直齿圆柱齿轮的啮合传动 一对渐开线齿轮在传动时，它们的齿廓啮合点都应位于其啮合线上。因此要两轮能正确啮合，应使处于啮合线上的多对轮齿能同时进入啮合。即应满足两齿轮的法向齿距相等 重合度：用来衡量齿轮连续传动的条件;代表同时参与啮合的轮齿对数的平均值。增大重合度，同时参与啮合的轮齿对数增加，故这对于提高齿轮传动平稳性，提高承载能力都有重要意义。 10-6 渐开线齿轮的变位修正“变位修正法”为目前最为广泛采用的一种齿轮修正方法。正变位齿轮 负变位齿轮 10-7 斜齿圆柱齿轮传动 10-8 蜗杆传动 10-9 圆锥齿轮传动 第十一章齿轮系及其设计 第十二章其他常用机构 机械设计01 绪论本课程中“设计”的含义是指机械装置的实体设计，涉及零件的应力、强度的分析计算，材料的选择、结构设计，考虑加工工艺性、标准化以及经济性、环境保护等。 02 机械设计总论 2-1 机器的组成 2-2 设计机器的一般程序 2-3 对机器的主要要求 2-4 机械零件的主要失效形式（一）整体断裂 整体断裂是指零件在载荷作用下，其危险截面的应力超过零件的强度极限而导致的断裂，或在变应力作用下，危险截面发生的疲劳断裂。（二）过大的残余变形当作用于零件上的应力超过了材料的屈服极限，零件将产生残余变形。（三）零件的表面破坏 零件的表面破坏主要是腐蚀、磨损和接触疲劳（点蚀）。（四）破坏正常工作条件引起的失效 有些零件只有在一定的工作条件下才能正常的工作，如： 2-5 设计机械零件时应满足的基本要求 2-6 机械零件的计算准则 2-7 机械零件的设计方法 2-8 机械零件设计的一般步骤 2-9 机械零件材料的选用原则 2-10 机械零件设计中的标准化标准化就是要通过对零件的尺寸、结构要素、材料性能、设计方法、制图要求等，制定出大家共同遵守的标准。标准化有利于保证产品质量，减轻设计工作量，便于零部件的互换和组织专业化的大生产，以降低生产成本。 03 机械零件的强度 3-1 材料的疲劳特性静应力只能在静载荷作用下产生。变应力可能由变载荷产生，也可能由静载荷产生（转动轴例） 3-2 机械零件的疲劳强度计算 3-3 机械零件的抗断裂强度 在工程实际中，往往会发生工作应力小于许用应力时所发生的突然断裂，这种现象称为低应力脆断。 通过对大量结构断裂事故分析表明，结构内部裂纹和缺陷的存在是导致低应力断裂的内在原因。 3-4 机械零件的接触强度 04 摩擦磨损及润滑 4-0 概述 4-1 摩擦 4-2 磨损一个零件的磨损过程大致可分为三个阶段，即：  磨合阶段　新的零件在开始使用时一般处于这一阶段，磨损率较高。  稳定磨损阶段　属于零件正常工作阶段，磨损率稳定且较低。  剧烈磨损阶段　属于零件即将报废的阶段，磨损率急剧升高。 4-3 润滑剂、添加剂和润滑方法 润滑油 润滑脂 润滑油与各种稠化剂（钙、钠、铝、锂等金属皂）混合稠化而成。 优点：密封简单，不需要经常添加，不易流失，对速度和温度不敏感，适用范围广。 缺点：摩擦损耗较大、机械效率低，不适宜高速场合。 固体润滑剂 用于润滑油不能胜任工作的场合：高温、低速重载。 润滑油润滑在工程中的应用最普遍，常用的供油方式有：滴油润滑、浸油润滑、飞溅润滑、喷油润滑、油雾润滑等 4-4 流体润滑原理简介一、流体动力润滑二、弹性流体动力润滑三、流体静力润滑 05 螺纹 5-1 螺纹螺旋线——一动点在一圆柱体的表面上，一边绕轴线等速旋转，同时沿轴向作等速移动的轨迹。 螺纹——一平面图形沿螺旋线运动，运动时保持该图形通过圆柱体的轴线，就得到螺纹。 螺纹有外螺纹与内螺纹之分，它们共同组成螺旋副。 5-2 螺纹连接的类型与标准连接件螺纹按工作性质分为连接用螺纹和传动用螺纹。 5-3 螺纹连接的预紧 5-4 螺纹连接的防松 5-5 螺纹连接的强度计算连接的失效形式：主要是指螺纹连接件的失效。对于受拉螺栓，其失效形式主要是螺纹部分的塑性变形和螺杆的疲劳断裂。对于受剪螺栓，其失效形式可能是螺栓杆被剪断或螺栓杆和孔壁的贴合面被压溃。 5-6 螺纹连接组的设计 5-7 螺纹连接件的材料与许用应力 5-8 提高螺纹连接强度的措施 5-9 螺旋传动 06 键 6-1 键连接 平键连接 特点：平键的两侧面是工作面，上表面与轮毂上的键槽底部之间留有间隙，键的上、下表面为非工作面。工作时靠键与键槽侧面的挤压来传递扭矩，故定心性较好。 普通平键 导向平键 滑键 半圆键连接 特点：键呈半圆形，其侧面为工作面，键能在轴上的键槽中绕其圆心摆动， 以适应轮毂上键槽的斜度，安装方便。常用与锥形轴端渔轮故的连接。 楔键连接 特点：楔键的上、下表面为工作面，两侧面为非工作面。键的上表面与键槽底面均有 1:100 的斜度。工作时，键的上下两工作面分别与轮毂和轴的键槽工作面压紧，靠其摩擦力和挤压传递扭矩。 切向键 由两个斜度为 1:100 的楔键组成。一个切向键只能传递一个方向的转矩，传递双向转矩时，须用互成 120° ～ 130° 角的两个键。 6-2 花键连接 6-3 无键连接 6-4 销连接 08 带 8-1 带传动概述 8-2 带传动的工作情况分析 8-3 V 带传动的设计计算 8-4 V 带轮结构设计 8-5 带传动的张紧装置 8-6 带传动设计实例 09 链传动 9-1 链传动的特点及应用 9-2 传动链的结构特点 齿形链又称无声链，它是一组链齿板较接而成。工作时链齿板与链轮轮齿相啮合而传递运动。 齿形链上设有导板，以防止链条工作时发生侧向审动。导板有内导板和外导板之分。内导板齿形链导向性好，工作可靠；外导板齿形链的链轮结构简单。 齿形链按铰链结构不同可分为圆销式、轴瓦式和滚柱式三种。 与滚子链相比，齿形链传动平稳无噪声承受冲击性能好，工作可靠，多用于高速或运动精度要求较高的传动装置中。 $9-3 滚子链链轮的结构和材料链轮是链传动的主要零件，其齿形已经标准化。链轮设计的主要内容是： ◆ 确定链轮的结构和尺寸； ◆ 选择链轮的材料和热处理方式；链轮的基本参数： ◆ 配用链条的节距 p、滚子的最大外径 d、排距 p、齿数 链轮的主要尺寸见下图，链轮毅孔的直径应小于其最大许用直径 dkmaxo 9-4 链传动的运动特性当主动链轮匀速转动时，从动链轮的角速度以及链传动的瞬时传动比都是周期性变化的，因此链传动不宜用于对运动精度有较高要求的场合。 链传动的不均匀性的特征，是由于围绕在链轮上的链条形成了正多边形这一特点所造成的，故称为链传动的多边形效应。 9-5 链传动的受力分析 9-6 滚子链传动的设计计算 9-7 链传动的布置、张紧和润滑 链传动的布置 链传动一般应布置在铅垂面内，尽可能避免布置在水平或倾斜平面内。 链传动的紧边在上方或在下方都可以，但在上方好一些。应尽量保持链传动的两个链轮共面，否则工作中容易脱链。 链传动的张紧 链传动张紧的目的，主要是为了避免在链条的垂度过大时产生啮合不良和链条的振动现象；同时也为了增加链条与链轮的啮合包角。 链传动的润滑 链传动中销轴与套筒之间产生磨损，链节就会伸长，这是影响链传动寿命的最主要因素。因而，润滑是延长链传动寿命的最有效的方法。润滑的作用对高速重载的链传动尤为重要。 良好的润滑可缓和冲击、减轻磨损、延长链条的使用寿命。 10 齿轮 10-1 齿轮传动概述传动效率高；结构紧凑；工作可靠，寿命长；传动比稳定；齿轮的制造及安装精度要求高，价格较贵。 按齿轮类型分：直齿圆柱齿轮传动斜齿圆柱齿轮传动锥齿轮传动人字齿轮传动 按装置形式分：开式传动–适于低速及不重要的场合半开式传动-只有简单防护罩，适用于农业机械、建筑机械及简单机械设备,闭式传动-润滑、密封良好，用于汽车、机床及航空发动机等的齿轮传动中。 按使用情况分：动力齿轮一以动力传输为主，常为高速重载或低速重载传动。传动齿轮一以运动准确为主，一般为轻载高精度传动。 按齿面硬度分：软齿面齿轮（齿面硬度&lt;350HBS，38HRC）硬齿面齿轮（齿面硬度&gt;350HBS） 10-2 齿轮传动的失效形式及设计准则轮齿折断 产生原因：疲劳；过载；载荷集中； 提高轮齿抗折断能力的措施： 减小齿根应力集中：增大齿根过渡圆角半径，消除加工刀痕 使轮齿接触线上受力较为均匀：增大轴及支承刚度 使轮齿芯部具有足够韧性：采用合适的热处理 提高疲劳强度：采用喷丸、滚压等工艺，对齿根表面层进行强化处理 齿面磨损 开式齿轮传动的主要失效形式之一 产生原因：齿面间存在杂质；提高齿面抗磨损能力的措施： 提高齿面材料的硬度； 采用闭式齿轮传动，加以合理的润滑； 尽量为齿轮传动保持清洁的工作环境。 齿面点蚀 闭式齿轮传动的主要失效形式之一 产生原因：疲劳提高齿面抗点蚀能力的措施： 提高齿面材料的硬度； 采用合理的润滑降低接触应力； 在合理的限度内增大齿轮直径，从而减小接触应力； 在合理的限度内，采用较高粘度的润滑油。 齿面胶合 胶合产生的原因 1.瞬时温度过高 2.润滑不良.提高抗胶合能力的措施：&gt;采用抗胶合能力强的润滑油&gt;在润滑油中加入极压添加剂 塑性变形 提高齿面硬度，采用高粘度的或有极压添加剂的润滑油均有助于减缓或防止齿面产生塑性变形。 对一般工况下的齿轮传动，其设计准则是： 保证弯曲疲劳强度，以免发生齿根折断。 保证接触疲劳强度，以免发生齿面点蚀。 对高速重载齿轮传动，除以上两设计准则外，还应按齿面抗胶合能力的准则进行设计。 10-3 齿轮的材料及其选择原则 对齿轮材料性能的要求 齿轮的齿体应有较高的抗折断能力，齿面应有较强的抗点蚀、抗磨损和较高的抗胶合能力，即要求：齿面硬、齿芯韧。 常用的齿轮材料 钢：许多钢材经适当的热处理或表面处理，可以成为常用的齿轮材料； 铸铁：常作为低速、轻载、不太重要的场合的齿轮材料； 非金属材料：适用于高速、轻载、且要求降低噪声的场合。 齿轮材料选用的基本原则 齿轮材料必须满足工作条件的要求，如强度、寿命、可靠性、经济性等； 应考虑齿轮尺寸大小，毛坏成型方法及热处理和制造工艺； 钢制软齿面齿轮，其配对两轮齿面的硬度差应保持在 30~50HBS 或更多。 10-4 齿轮传动的计算载荷减小动载荷的办法：齿顶修缘 10-5 标准直齿圆柱齿轮传动的强度计算 10-6 齿轮传动设计参数、许用应力与精度选择 10-7 标准斜齿圆柱齿轮传动的强度计算 10-8 标准锥齿轮传动的强度计算 10-9 齿轮的结构设计通过强度计算确定出了齿轮的齿数 z、模数 m、齿宽 B、螺旋角 B、分度圆直径 d 等主要尺寸。齿轮的结构设计主要是确定轮缘，轮辐，轮毂等结构形式及尺寸大小。在综合考虑齿轮几何尺寸，毛坯，材料，加工方法，使用要求及经济性等各方面因素的基础上，按齿轮的直径大小，选定合适的结构形式，再根据推荐的经验数据进行结构尺寸计算。 10-10 齿轮传动的润滑 11 蜗杆 11-0 蜗杆传动概述蜗杆传动是一种在空间交错轴间传递运动的机构。蜗杆传动的主要特点有： 传动比大，一般为 i&#x3D;5~80，大的可达 300 以上； 重合度大，传动平稳，噪声低； 摩擦磨损问题突出，磨损是主要的失效形式； 传动效率低，具有自锁性时，效率低于 50%。 由于上述特点，蜗杆传动主要用于运动传递，而在动力传输中的应用受到限制。 11-1 蜗杆传动的类型圆柱蜗杆传动环面蜗杆传动锥蜗杆传动 11-2 普通蜗杆传动的参数与尺寸　较少的蜗杆头数（如：单头蜗杆）可以实现较大的传动比，但传动效率较低；蜗杆头数越多，传动效率越高，但蜗杆头数过多时不易加工。通常蜗杆头数取为 1、2、4、6。 11-3 普通蜗杆传动的承载能力计算 11-5 普通蜗杆传动的效率、润滑与热平衡 润滑的主要目的在于减摩与散热。具体润滑方法与齿轮传动的润滑相近。 润滑油润滑油的种类很多，需根据蜗杆、蜗轮配对材料和运转条件选用。 润滑油粘度及给油方式一般根据相对滑动速度及载荷类型进行选择。给油方法包括：油池润滑、喷油润滑等，若采用喷油润滑，喷油嘴要对准蜗杆啮入端，而且要控制一定的油压。 润滑油量润滑油量的选择既要考虑充分的润滑，又不致产生过大的搅油损耗。对于下置蜗杆或侧置蜗杆传动，浸油深度应为蜗杆的一个齿高；当蜗杆上置时，浸油深度约为蜗轮外径的 1&#x2F;3。 11-6 圆柱蜗杆和蜗轮的结构设计蜗杆螺旋部分的直径不大，所以常和轴做成一个整体。当蜗杆螺旋部分的直径较大时，可以将轴与蜗杆分开制作。 12 滑动轴承 12-1 滑动轴承概述 轴承的作用是支承轴。轴在工作时可以是旋转的，也可以是静止的。轴承应满足如下基本要求： 能承担一定的载荷，具有一定的强度和刚度。 具有小的摩擦力矩，使回转件转动灵活。 具有一定的支承精度，保证被支承零件的回转精度。 轴承的分类根据轴承中摩擦的性质，可分为滑动轴承和滚动轴承。根据能承受载荷的方向，可分为向心轴承、推力轴承、向心推力轴承。（或称为径向轴承、止推轴承、径向止推轴承）根据润滑状态，滑动轴承可分为：不完全液体润滑滑动轴承。完全液体润滑滑动轴承。 滚动轴承绝大多数都已标准化，故得到广泛的应用。但是在以下场合，则主要使用滑动轴承： 工作转速很高，如汽轮发电机。 要求对轴的支承位置特别精确，如精密磨床。 承受巨大的冲击与振动载荷，如轧钢机。 特重型的载荷，如水轮发电机。 根据装配要求必须制成剖分式的轴承，如曲轴轴承。 在特殊条件下工作的轴承，如军舰推进器的轴承。 径向尺寸受限制时，如多辊轧钢机。 12-2 滑动轴承的典型结构 径向滑动轴承的结构 特点：结构简单，成本低廉。因磨损而造成的间隙无法调整。只能从沿轴向装入或拆出应用：低速、轻载或间歇性工作的机器中。 对开式径向滑动轴承特 点：结构复杂、可以调整磨损而造成的间隙、安装方便。应用场合：低速、轻载或间歇性工作的机器中。 止推滑动轴承的结构止推滑动轴承由轴承座和止推轴颈组成。常用的轴颈结构形式有： 空心式：轴颈接触面上压力分布较均匀，润滑条件较实心式的改善。单环式：利用轴颈的环形端面止推，结构简单，润滑方便，广泛用于低速、轻载的场合。多环式：不仅能承受较大的轴向载荷，有时还可承受双向轴向载荷。由于各环间载荷分布不均，其单位面积的承载能力比单环式低 50%。 12-3 滑动轴承的失效形式及常用材料 轴承表面的磨粒磨损、刮伤、咬粘（胶合）、疲劳剥落和腐蚀。 滑动轴承还可能出现气蚀、电侵蚀、流体侵蚀和微动磨损等失效形式。 轴承材料是指在轴承结构中直接参与摩擦部分的材料，如轴瓦和轴承衬的材料。轴承材料性能应满足以下要求：减摩性：材料副具有较低的摩擦系数。 耐磨性：材料的抗磨性能，通常以磨损率表示。 抗咬粘性：材料的耐热性与抗粘附性。 摩擦顺应性：材料通过表层弹塑性变形来补偿轴承滑动表面初始配合不良的能力。 嵌入性：材料容纳硬质颗粒嵌入，从而减轻轴承滑动表面发生刮伤或磨粒磨损的性能。 磨合性：轴瓦与轴颈表面经短期轻载运行后，形成相互吻合的表面形状和粗糙度的能力（或性质） 此外还应有足够的强度和抗腐蚀能力、良好的导热性、工艺性和经济性。 12-4 滑动轴承轴瓦结构 column0 column1 column2 按构造 整体式 需从轴端安装和拆卸，可修复性差。 分类 对开式 可以直接从轴的中部安装和拆卸，可修复。 按尺寸 薄壁 节省材料，但刚度不足，故对轴承座孔的加工精度要求高。 分类 厚壁 具有足够的强度和刚度，可降低对轴承座孔的加工精度要求。 按材料 单材料 强度足够的材料可以直接作成轴瓦，如黄铜，灰铸铁。 分类 多材料 轴瓦衬强度不足，故采用多材料制作轴瓦。 按加工 铸造 铸造工艺性好，单件、大批生产均可，适用于厚壁轴瓦。 分类 轧制 只适用于薄壁轴瓦，具有很高的生产率。 12-5 滑动轴承润滑剂的选择一、润滑脂及其选择 无流动性，可在滑动表面形成一层薄膜。二、润滑油及其选择 有良好的流动性，可形成动压、静压或边膜界润滑膜。三、固体润滑剂及其选择 可在滑动表面形成固体膜。 12-6 不完全液体润滑滑动轴承的设计计算一、失效形式与设计准则 因采用润滑脂、油绳或滴油润滑，故无法形成完全的承载油膜，工作状态为边界润滑或混合摩擦润滑。 保证边界膜不破裂。 12-7 液体动力润滑径向滑动轴承的设计计算 12-8 其它形式滑动轴承简介 13 滚动轴承 13-1 概述 13-2 滚动轴承的主要类型和代号 按滚动体的不同分类：球轴承、滚子轴承； 按可承受的外载荷分类：向心轴承、推力轴承、向心推力轴承； 13-3 滚动轴承的类型选择 13-4 滚动轴承的工作情况 13-5 滚动轴承尺寸的选择 13-6 轴承装置的设计 14 联轴器 14-0 联轴器和离合器概述联轴器和离合器是机械装置中常用的部件，它们主要用于联接轴与轴，以传递运动与转矩，也可用作安全装置。大致有以下类型：联轴器 用于将两轴联接在一起，机器运转时两轴不能分离，只有在机器停车时才可将两轴分离；离合器 在机器运转过程中，可使两轴随时接合或分离的一种装置。它可用来操纵机器传动的断续，以便进行变速或换向；安全联轴器与离合器 机器工作时，若转矩超过规定值，即可自行断开或打滑，以保证机器中的主要零件不因过载而损坏；特殊功用的联轴器与离合器用于某些特殊要求处，如：在一定的回转方向或达到一定转速时，联轴器或离合器即可自动接合或分离等；联轴器和离合器种类繁多，在选用标准件或自行设计时应考虑：传递转矩大小、转速高低、扭转刚度变化、体积大小、缓冲吸振能力等因素。 14-1 联轴器的种类和特性 14-2 联轴器的选择 14-3 离合器二、对离合器的基本要求 分离、接合迅速，平稳无冲击，分离彻底，动作准确可靠；结构简单，重量轻，惯性小，外形尺寸小，工作安全，效率高；接合元件耐磨性好，使用寿命长，散热条件好；操纵方便省力，制造容易，调整维修方便。 三、离合器的选用 嵌入式离合器的结构简单，外形尺寸较小，两轴间的联接无相对运动，一般适用于低速接合，转矩不大的场合；摩擦式离合器可在任何转速下实现两轴的接合或分离；接合过程平稳，冲击振动较小；可有过载保护作用。但尺寸较大，在接合或分离过程中要产生滑动摩擦，故发热量大，磨损也较大。 电磁摩擦离合器可实现远距离操纵，动作迅速，没有不平衡的轴向力，因而在数控机床等机械中获得了广泛的应用。 14-4 安全联轴器及安全离合器 14-5 特殊功用及特殊结构的联轴器及离合器 15 轴 15-1 轴的概述 15-2 轴的结构设计 15-3 轴的计算 16 弹簧 16-1 弹簧概述 16-2 圆柱螺旋弹簧的结构、制造、材料及许用应力 16-3 圆柱螺旋拉压弹簧的设计计算 16-4 圆柱螺旋扭转弹簧的设计计算 流体力学没找到资料，后续再看看。 互换性和测量技术 这门课学的很浅。主要是学完对公差的理解更加深刻，查找数据也更加熟练。 第二章 光滑圆柱结合的公差与配合分清基轴制、基孔制。其实就是基于标准件，因为标准件的尺寸一般比较精确。 第三章 测量技术基础量块 第四章 几何公差及检测 第五章 表面粗糙度 第六章 光滑工件尺寸的检测 第七章 滚动轴承与孔、轴结合的互换性 第八章 尺寸链 第九章 圆锥结合的互换性 第十章 螺纹结合的互换性 第十一章 键和花键的互换性 第十二章 圆柱齿轮传动的互换性 机械制造技术基础第二章 切削成形运动的组成；主运动、进给运动的定义与加工中的意义。 切削用量 3 要素 PG29. 三要素的概念、物理意义，计算与换算方法。切削层参数——切削层厚度、宽度和切削层横截面积 刀具的主要刀面 Pg30 图刀具的角度 PG32 图。 刀具材料应具有的性能 Pg33-34常用刀具材料：高速钢、硬质合金、陶瓷刀具、金刚石刀具、立方氮化硼刀具的性能特点 与应用领域。（每一种都要看过哦） 高速切削的特点 切削变形区的特点、默钱特方程的物理意义。 切削的类型，与产生的原因。 积屑瘤与鳞刺产生的原因及控制方法。 影响切削力的因素。 切削热的分布特点、影响因素。 刀具磨损的原因、刀具磨损的阶段划分。 金属材料的切削加工性能。 切削液的作用。 硬态切削、干式切削、加热辅助切削、低温切削等特殊加工方法的技术特点、应用背景。 15、外圆加工刀具、孔加工刀具、铣刀、复合刀具的特点、应用场合。 第三章 车床的组成、车床传动系统原理与路线 铣床、钻床、镗床、刨床、磨床、齿轮加工机械的工作原理与特点。 数控机床的加工原理、数控机床的数控伺服驱动系统的主要类型及特点。 高速机床进给系统的结构特点。 夹具的作用与构成 六点定位原理、几种定位状态（完全、欠、不完全、过） 7. 典型定位元件的工作原理、自由度约束关系。 定位误差计算（必考） 常见夹紧机构的工作原理、特点。 典型钻夹具、车床夹具的定位、夹具方案。 第四章 机械零件加工质量复习要点 加工精度、加工误差的定义 工艺系统的原始误差 误差敏感方向 机床误差对加工精度的影响 工艺系统受力变形对加工精度的影响 工艺系统热变形对加工精度的影响 加工过程中应力的产生与控制 误差复映 分布图法计算误差分布 点图法的特点 机械加工表面质量对零件使用性能的影响 磨削烧伤对零件表面性能的影响 常用的光整加工方法的特点。 第五章 机械加工及装配工艺规程设计 工序、装夹、工位、工步、走刀的定义与相互关系 生产纲领的概念，与生产类型的关系 工艺规程的概念，工艺规程的类型、工艺规程的作用 4. 零件结构工艺性分析 表5-9 毛坯选择需考虑的因素 粗基准、精基准选择的原则 划分加工阶段的原因 选择加工方法时考虑的因素 加工工序安排的原则 热处理工序安排的原则 工艺尺寸链计算 保证装配精度的方法选择 数控技术及装备设计那会已经在准备考研了，说实话已经不记得学过什么了。但是有笔记 持续更新 ing。。。","tags":["⚙️机械工程"],"categories":["💻Code"]},{"title":"欲善其事 先利其器","path":"/posts/aqu6r6/","content":"好软推荐（记录） 大部分 Windows 软件来自吾爱破解论坛 压缩包较大，需要请留言。侵删！ 前方大量图片来袭!!! Windows2345 图片浏览器（绿色版）虽然 2345 是出了名的流氓软件，但不得不说，看图软件是很好用的。 Photoshop CC 精简版绿色，启动快，常用功能齐全。 Premiere Pro 2020绿色，启动快，常用功能齐全。 Advanced Renamer批量重命名工具 AIAD 64硬件检测工具 AutoCAD2007远古 CAD 版本，兼容性好! B 站视频下载工具简单方便，支持多线程下载。 Caplos键盘大小写显示工具，适用于无线键盘没有指示灯的用户，支持改键。 使用 RK61 时找到的软件。 Captura开源视频录制软件 支持多种录制方式 CCleaner著名系统清理软件，绿色版。 CoreTempCPU 检测软件，支持 32、64 位系统。 笔记本温度有点高唉，继续 Draw.io点击访问 Everything非常方便的搜索工具 Explorer++多标签文件管理器 冰点下载某文档下载器（大部分功能已经失效，留念） Folder Painter文件夹染色工具 Groupy软件多标签管理 Imagine图片压缩工具 MacroCreatorAHK 语言版按键精灵!!! NotePad++超强记事本工具 PDF-XChange Editor Pluspdf 编辑，查看，转换工具。功能齐全。 PotPlayer强大的视频播放器 ReNamer批量重命名工具 Rolan方便的软件面板 SpaceSniffer直观存储管理软件 ScreenToGif录屏转 gif，gif 编辑。 Sidebar硬件监控工具 Snipaste强大的截图、贴图工具。 TaskbarX任务栏透明，居中工具 Termius全平台终端管理软件 TrafficMonitor硬件监控软件，可以显示在任务栏。 Uninstall Tool‘软’如其名，软件卸载工具。 Watermark Image Pro‘软’如其名，图片加水印软件。支持批量，功能强大。 windows10 manager‘软’如其名，win10 系统管理工具 XMind强大的思维导图软件。 格式工厂格式转换大师 鼠标图标编辑器 Fontmin详情见这里 这个是桌面版软件 小说下载器 AutoOff自动关机软件 知网研学文献管理 ChromeBitwarden免费密码管理器 Infinity 新标签页 pro‘软’如其名 万能复制‘软’如其名 AdGuard 广告拦截器‘软’如其名","tags":["📦software"]},{"title":"三根杆","path":"/posts/e556/","content":"初机械手臂（英语：robotic arm）是具有模仿人类手臂功能并可完成各种作业的自动控制设备，这种机器人系统有多关节连结并节允许在平面或三度空间进行运动或使用线性位移移动。 本文的主题是平面三轴机械臂。 启首先来学习一下单轴的，如下图： （系统画图画的） 将物理问题转化为数学问题，建立坐标系： 杆长取r很容易就能得到端点坐标为rcosα,rscinα 是不是很简单，那接下来看两个杆。 中如图所示 继续将物理问题转化为数学问题，建立坐标系： 这里我作了两条辅助线用来辅助理解 图中α，β为绝对角度（也就是相对于x轴的角度），θ1，2，是相对角度（相对于上一段的角度）他的值可能为正也可能为负值，这样我们就能得到α，β与θ的表达式α=θ1，β=θ1+θ2 杆长依旧取r，为了便于说明这里三根杆的长度都取r这里我们很容易就能得到最右端坐标的表达式为：rcosα+rcosβ,rscinα+rsinβ 同理我们可以得到三杆的表达式α=θ1，β=θ1+θ2，γ=θ1+θ2+θ3和rcosα+rcosβ+rcosγ,rscinα+rsinβ+rsinγ 到这里你肯定觉得这好简单，为什么要写一篇文章讲这个？ 上述思路皆为正运动学（正运动学可以大致理解为已知三根杆的长度和角度，求端点坐标）。既然有正运动学，就会有逆运动学（逆运动学可以理解为已知三杆长度和端点坐标，求相关角度）。而在实际运用中，逆运动学往往更多，比如抓取物体。 潮咱们还是从简单的开始 杆长r，端点坐标为x,y，很容易就能得到α角度arccos(r/x),arcsin(r/y) 接下来看两杆 依旧看这幅图，很容易就能想到余弦定理求角度，这没问题，但你可能会遇到一个问题，如图 你得到的结果可能是两个，这个时候就需要添加条件排除掉其中一个，或者根据条件选取最合适的一个，比如说让相对角度尽可能小，这样可以减少电机转动的圈数。 两杆就开始有多解，那三杆呢，肯定会有更多解，这个时候就要根据项目的具体情况去添加限制条件，下面拿具体项目来讲讲。 题目：使用摄像头进行识别并抓取物块放到指定的位置 这里是三个杆，就要想办法增加条件限制解的个数，比如物体的姿态，机械爪需要从哪个角度抓取等等条件。 我这里增加的就是物体姿态角，通过姿态角将三杆问题转化为两杆，再增加相对角度之和最小的条件得到最终结果。 如图所示： 下面详细介绍具体过程和代码实现（MFC &amp; C++） 求解根据坐标和姿态计算角度 移动到合适的抓取姿态依次转动三根杆到合适的角度（也可以同时转动） 抓取进行抓取 在这三个过程中还要通过正运动学计算并绘制爪子另外，计算机的坐标原点和xy轴都在左上角，并不是中心点，需要进行坐标系变换，这里不再详细讲述。 源码仓库GitHub - wxydejoy&#x2F;DrawPath: 三杆 机械臂 这里就不对代码进行介绍了，内容很多，核心部分以及思路已经在上述内容中讲过，欢迎指正。 终思路其实不是很难，难的是其中的细节，敲错一点或者有理解不清楚的结果就会完全不一样。 平面三杆已经有点复杂了，那如果是空间三杆呢？如何计算？ 引機械手臂 - 维基百科，自由的百科全书","tags":["⚙️Machine","🦾平面三杆"],"categories":["💻Code"]},{"title":"三种常用表达式","path":"/posts/iir0g4/","content":"Regex正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本教程，加上应用的时候进行一定的参考，掌握正则表达式不是问题。 许多程序设计语言都支持利用正则表达式进行字符串操作。 保留匹配内容为了保留某部分，通常情况下我们在正则表达式中使用()将我们要保留的内容括住。如下，我们要保留的是中间的数字部分，在替换时使用$1将括号的内容表达出来。$1可以认为是一个变量，代表着()中的内容。 非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f \\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f \\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘ ’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’ ’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 &#123; 标记限定符表达式的开始。要匹配 {，请使用 {。 &#96; &#96; 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 &#123;n&#125; n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 &#123;n,&#125; n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 &#123;n,m&#125; m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 以下正则表达式匹配一个正整数，[1-9]设置第一个数字不是 0，[0-9]* 表示任意多个数字： 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 CornCron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义： 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * &#x2F; 分（Minutes） 0~59的整数 , - * &#x2F; 小时（Hours） 0~23的整数 , - * &#x2F; 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? &#x2F; L W C 月份（Month） 1~12的整数或者 JAN-DEC , - * &#x2F; 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1&#x3D;SUN） , - * ? &#x2F; L C # 年(可选，留空)（Year） 1970~2099 , - * &#x2F; 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： （1）：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）&#x2F;：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5&#x2F;20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 Cidr CIDR Block 地址范围 IP地址数 10.0.0.0&#x2F;8 10.0.0.0 – 10.255.255.255 16,777,216 172.16.0.0&#x2F;12 172.16.0.0 – 172.31.255.255 1,048,576 192.168.0.0&#x2F;16 192.168.0.0 – 192.168.255.255 65,536 比如腾讯云的防火墙就可以根据自己的ip设置 参考资料菜鸟教程 博客园 cidr","tags":["💻Regex","💻Corn","💻CIDR"]},{"title":"upyun","path":"/posts/3f4daa0d/","content":"启前段时间折腾存储空间，折腾一圈还是又拍云最香，免费。但是自己不小心把一个文件夹删了，想要找回，却没有回收站这个功能，很遗憾，它就这么没了。 所以想找个办法备份图床，另外在 Github 逛到了 upyun-sdk 所以就拿来写写。 将又拍云存储的数据下载到本地，并且上传到一个新的存储空间内。 为保证数据完整，禁止删除任意文件。 支持同步 中写这个脚本的最终目的不是省钱（图床一共也没几个钱），而是锻炼自己！ 有目的的学习效率更高！ 通过这个脚本，学习到了一些python的知识 类的定义 （定义了一个myupyun的子类） 类的继承 （myupyun类继承了 upyun-py 中的UpYun类，并且添加了一些新的代码） 递归函数 （又拍云并未提供列举所有目录的接口，自己用递归编写了文件遍历函数） 多级文件夹 （os.open 有时并不能创建文件夹，os.mkdir 只能创建一级文件夹，创建多级文件夹要用 os.mkdirs 另外还认识到一些不足之处来日补上 函数有些凌乱 并发下载 进度条使用不完善 数据库 潮讲完自己的，下面来讲将给读者的（没错就是屏幕前的你！），分享一下使用方法（0 基础）。 环境要求 python3+你喜欢的编辑器 克隆仓库 在你喜欢的地方打开powershell or git bash 这里更建议放服务器里面，当然 Windows 也行 git clone https://github.com/wxydejoy/upyun-backup-server.git 安装依赖 123python -m venv venv # 创建虚拟环境pip install -r requirements.txt 配置参数 打开main.py按照提示填入合适的参数 12345678910111213141516# 只下载和上传，不删除，也就是说不需要删除权限# 源仓库配置st1_name = &quot;&quot;st1_operator = &quot;&quot;st1_password = &quot;&quot;# 目标仓库配置st2_name = &quot;&quot;st2_operator = &quot;&quot;st2_password = &quot;&quot;st2_link = &quot;&quot;# 本地配置local_dir = &quot;local/&quot; # 本地相对路径 RUN 运行 main.py 即可 终这个备份当然可以自动 服务器宝塔：添加定时任务定时运行脚本即可，注意运行路径非宝塔：自行百度添加服务器定时任务 Windows打开系统搜索，搜任务计划程序 点击创建基本任务，按照引导创建即可（友情提示：任务计划程序很好用，思路放开）","tags":["😄Upyun"]},{"title":"HEXO & Fontmin","path":"/posts/79e22e25/","content":"初想要自定义字体吗？字体太大？担心字体拖慢加载速度？快来使用 gulp-fontmin！字体缩小 5 倍不是梦！ 字体一直一来都是静态博客中比较大的文件，尤其是特殊的字体能达到 10Mb 以上，为了提高网页加载速度必须对他动手，之前尝试过字蛛，但已年久失修，现有Fontmin以及gulp-fontmin（其实也好多年了，问题不大），所以调试一下，写篇教程，然后美化一下自己的博客。 启首先需要找到你喜欢的字体，这里不再讨论。 安装依赖（时间有点长是正常情况） 123npm install --global gulp-cli #全局安装gulp指令集npm install gulp --save #安装gulp插件npm install --save-dev gulp-fontmin 预gulp安装完成后运行gulp -v检查版本 123$ gulp -vCLI version: 2.3.0Local version: 4.0.2 中首先在博客根目录新建gulpfile.js 复制以下代码并按照注释修改 123456789101112131415161718192021222324252627282930var gulp = require(&quot;gulp&quot;);var fontmin = require(&quot;gulp-fontmin&quot;);function minifyFont(text, cb) &#123; gulp .src(&quot;source/font/*.ttf&quot;) //原字体所在目录 .pipe( fontmin(&#123; text: text, &#125;) ) .pipe(gulp.dest(&quot;source/fontdest/&quot;)) //压缩后的输出目录 .on(&quot;end&quot;, cb);&#125;gulp.task(&quot;mini-font&quot;, (cb) =&gt; &#123; var buffers = []; gulp .src([&quot;./.deploy_git/**/*.html&quot;]) //HTML文件所在目录请根据自身情况修改 .on(&quot;data&quot;, function (file) &#123; buffers.push(file.contents); &#125;) .on(&quot;end&quot;, function () &#123; var text = Buffer.concat(buffers).toString(&quot;utf-8&quot;); minifyFont(text, cb); &#125;);&#125;);gulp.task(&quot;default&quot;, gulp.parallel(&quot;mini-font&quot;)); 潮引入字体 12345@font-face &#123; font-family: &quot;lxk&quot;; /* 字体名自定义即可 */ src: url(&quot;/fontdest/李旭科书法1.4.ttf&quot;); /* 字体文件路径 */ font-display: swap;&#125; Butterfly 请参照店长自定义字体教程 终最终效果 注：字体越大压缩效果越好 从此可以肆无忌惮的使用自定义字体了","tags":["🌼HEXO","✏️Font","📑Compose"]},{"title":"Threejs 导入模型","path":"/posts/e90952d5/","content":"效果展示 关于ThreejsThree.js是基于原生WebGL封装运行的三维引擎，在所有WebGL引擎中，Three.js是国内文资料最多、使用最广泛的三维引擎。 Iframe1&lt;iframe id=&quot;modelFrame&quot; src=&quot;https://ts.undf.top/3d/bysj.html&quot; width=&quot;100%&quot; height=&quot;75%&quot; style = &quot;border-radius: 10px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 为了方便引入，采用iframe框架，可以有效减少引入处的代码长度。 源码仓库点我 仓库内3d文件夹下面即是所有源代码。如果不需要自定义修改，建议复制整个文件夹到你的目录内，如果需要自定义模型和样式，请参照下面的关键代码解释 关键代码如果需要更改js文件的位置需要修改 html 文件里面的位置和 stl.js 文件内的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// 如果需要修改文件位置，记得修改这里的路径import * as THREE from &#x27;./build/three.module.js&#x27;;import Stats from &#x27;./build/stats.js&#x27;;import &#123; STLLoader &#125; from &#x27;./build/stl.js&#x27;; let container, stats; let camera, cameraTarget, scene, renderer; init(); animate(); function init() &#123; container = document.createElement( &#x27;div&#x27; ); document.body.appendChild( container ); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 30 ); camera.position.set( 0, 0.85, 0 ); //相机位置 cameraTarget = new THREE.Vector3( 0, - 0.25, 0 ); scene = new THREE.Scene(); scene.background = new THREE.Color( 0x72645b ); scene.fog = new THREE.Fog( 0x72645b, 2, 15 ); // Ground // const plane = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( &#123; color: 0x999999, specular: 0x101010 &#125; ) ); plane.rotation.x = - Math.PI / 2; plane.position.y = - 0.5; scene.add( plane ); plane.receiveShadow = true; const loader = new STLLoader(); // Binary files。即 二进制 stl 文件 const material = new THREE.MeshPhongMaterial( &#123; color: 0xAAAAAA, specular: 0x111111, shininess: 200 &#125; ); loader.load( &#x27;./model/bysj.stl&#x27;, function ( geometry ) &#123; const mesh = new THREE.Mesh( geometry, material ); //模型参数 mesh.position.set( 0, - 0.18, - 0.1 ); mesh.rotation.set( - Math.PI / 2, 0, 0 ); mesh.scale.set( 0.008, 0.008, 0.008 ); mesh.castShadow = true; mesh.receiveShadow = true; scene.add( mesh ); &#125; ); scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) ); addShadowedLight( 1, 1, 1, 0xffffff, 1.35 ); addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 ); // renderer renderer = new THREE.WebGLRenderer( &#123; antialias: true &#125; ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.outputEncoding = THREE.sRGBEncoding; renderer.shadowMap.enabled = true; container.appendChild( renderer.domElement ); // stats stats = new Stats(); container.appendChild( stats.dom ); // window.addEventListener( &#x27;resize&#x27;, onWindowResize ); &#125; function addShadowedLight( x, y, z, color, intensity ) &#123; const directionalLight = new THREE.DirectionalLight( color, intensity ); directionalLight.position.set( x, y, z ); scene.add( directionalLight ); directionalLight.castShadow = true; const d = 1; directionalLight.shadow.camera.left = - d; directionalLight.shadow.camera.right = d; directionalLight.shadow.camera.top = d; directionalLight.shadow.camera.bottom = - d; directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 4; directionalLight.shadow.bias = - 0.002; &#125; function onWindowResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); &#125; function animate() &#123; requestAnimationFrame( animate ); render(); stats.update(); &#125; function render() &#123; const timer = Date.now() * 0.0005; camera.position.x = Math.cos( timer ) * 3; camera.position.z = Math.sin( timer ) * 3; camera.lookAt( cameraTarget ); renderer.render( scene, camera ); &#125;","tags":["📦Threejs"],"categories":["💻Code"]},{"title":"从零开始个人主页","path":"/posts/8730864/","content":"初目前我的个人主页是在 threejs 开源项目的基础上自己修改而成，但主页文件过于庞大（加载缓慢），且在部分平台无法完全展示，而且恰逢寒假，时间充足，所以准备一边学习 HTML+CSS+JS，一边写个人主页，有目的的学习会让人更有动力。 启其实我前段时间就写了，但是写出来的很烂，能用但不好用。 而且也嵌入了 threejs，非常庞大，所以这次从头开始，做一个极其简洁的主页。 预初步计划图示如下 手机端 电脑端 感觉有点空空荡荡的，到时候背景搞得花一点。 中设置所有内容居中 设置文字颜色，大小 设置背景等 设置图标，超链接 潮调整间隔padding,调整整体布局 移动端适配 通过 javascript 判断并跳转 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; try&#123; var urlhash=window.location.hash; if(!urlhash.match(&quot;fromapp&quot;))&#123; if((navigator.userAgent.match(/(iPhone|iPod|Android|ios|iPad)/i)))&#123; window.location=&#x27;/mobile/index.html&#x27; &#125; &#125; &#125; catch(err)&#123;&#125;&lt;/script&gt; 终如图 不得不说，前端还是蛮难的，主要是内容非常多。 这次就这样简简单单告一段落，回头再加东西。","tags":["😎Page"],"categories":["💻Code"]},{"title":"图书馆奇遇记","path":"/posts/85b39a47/","content":"今天来聊聊在图书馆遇到的各种自由职业者。 WIFI起名员（点赞）主要特点：Wi-Fi名字起的非常不错 比如：连热点看大学生 coffee的工业制法 花间一壶酒 野指针001 黄金脆皮鸡 等等 猜猜哪个是我的热点名？（提示：小米9） 12.5日更新 有个Wi-Fi名叫连到我就让你嘿嘿嘿，名字很好玩对吧，我就试了试密码，先后试了试88888888,12345678,123456789,1234567890,让我没想到的是竟然蒙对了，密码就是最后一个。笑死。 噪音制造器主要特点：擅长制造各种噪音 品茶大师主要特点：摇头晃脑 品茶出声（⚠️是品茶的声音，不是正常人喝水的声音） 狗粮生产机确实羡慕小情侣，但咱也不是没谈过，你正常谈也没什么问题，别影响其他人嘛 主要特点：聊天 卿卿我我 窗外的乌鸦这个不是说某一位同学，是真的乌鸦，有时很吵，有时又还好。 空调不得不说图书馆的空调是真不错，比宿舍强多了。宿舍空调功率太小，吹不到下铺，桌子底下冻得要死，上铺却很热。","tags":["📚Librar"],"categories":["🔖Life"]},{"title":"NPM 图床探究","path":"/posts/50ee91a2/","content":"起因最近在吾爱发帖，苦于福利区不能贴图，要用自己的图床，然后我用了又拍云，一个帖子，一天，3 元。 这个价格有点贵了 hhh，所以想要找个稳定的图床，本来用 jsd + GitHub 但是论坛屏蔽掉了 jsd 好像是因为会传播木马什么的，总之是不安全。 而且写教程还是蛮辛苦的，不想因为图床挂了而不能看，所以想要一个稳定的免费的图床，所以就想到了 npm 经测试 NPM 不会被论坛审核，可以使用 NPM 图床创建及日常使用这里给店长打个广告，我也是通过店长和cyfan才了解到 npm 图床的 npm 图床的使用 NPM 图床的自动化流程如下 12345678910graph TD; Picgo上传多张图片到GitHub --&gt; Windows自动更新npm包版本; Windows自动更新npm包版本--&gt;自动查找替换链接; Windows自动更新npm包版本--&gt; GithubAction自动发包; GithubAction自动发包 --&gt; 图床更新完成; 自动查找替换链接--&gt;push博客仓库; Picgo 上传图片到 GitHub这一步的目的是方便预览，而且为后面查找替换打个基础 而且这一步会遇到 GitHubaction 报错 这不重要 关掉通知 直接无视 GitHub Action 自动推送到 npm这个教程里面有写，不再赘述npm 图床的使用 至于为什么使用 action 发包是因为图床很大，发包很慢 Windows 自动发包利用 shell 脚本，这个脚本放到图床仓库根目录运行即可 12345git pullgit add .git commit -m &#x27; ty &#x27;npm version patchgit push 内容其实很简单，就是简单的 git 命令 批量查找替换`sed` 命令 挺好的~~~12345678910111213141516171819202122232425262728293031323334353637383940414243444546这里是利用shell脚本的查找替换功能比如将`3.txt`中的 `npm.elemecdn.com/wxydeimage` 替换成 `npm.elemecdn.com/wxydeimage@1.0.23` 其中有转义符号`sed -i &#x27;s/cdn.jsdelivr.net\\/gh\\/wxydejoy\\/image/npm.elemecdn.com\\/wxydeimage@1.0.23/g&#x27; 3.txt `加上文件遍历，就变成了这个样子。这个脚本放在博客根目录即可```shell#!/bin/bash#folder=&quot;./test&quot;function readfile ()&#123;#这里`为esc下面的按键符号 for file in `ls $1` do#这里的-d表示是一个directory，即目录/子文件夹 if [ -d $1&quot;/&quot;$file ] then#如果子文件夹则递归 readfile $1&quot;/&quot;$file else#否则就能够读取该文件的地址 echo $1&quot;/&quot;$file#读取该文件的文件名，basename是提取文件名的关键字 sed -i &#x27;s/cdn.jsdelivr.net\\/gh\\/wxydejoy\\/image/npm.elemecdn.com\\/wxydeimage@1.0.23/g&#x27; $folder/$file fi done&#125;#函数定义结束，这里用来运行函数folder=&quot;./source/_post&quot;readfile $folder```其中`wxydejoy image`是GitHub用户名和仓库`wxydeimage`是`npm`包名，`1.0.23` 是版本号写着写着电脑黑屏了，吓死，幸亏是vscode自动保存了，有惊无险## 完全自动化我的目标是只要在提交之前运行一次脚本，无需手动修改版本号==敬请期待==## 后话今天看到npm的图床是想换来着，但是跑了一下速度，还是又拍云香，npm就用来论坛发帖吧，不过这个方案比较适合没有又拍云的同学。�","tags":["💻Hexo"],"categories":["💻Code"]},{"title":"PDF 去除水印教程","path":"/posts/b79413ee/","content":"PS 去水印拿到一个 PDF 你首先要判断一下他是不是源文件， 很显然这个不是，所以无法使用常规手法， 而且这个是纯图片格式，可以选择 PS 去水印，后面遇到其他 PDF 我再更新 效果勉勉强强，本人 PS 技术一般般，方法如下： 将 PDF 转为图片：尽量搞得清楚点，有些软件可能会压缩图片，这里还是推荐 adobe 的，或者 x-change 这些论坛里面都有 随便找一张或者几张 PDF 分页图片导入到 PS，通过调整色阶，对比度，甚至手动抠出 等等方法，去除水印 将 2 中的方法录制为动作（ps 自带录制功能 ALT + F9）实在不行可以百度搜索：ps 录制功能 然后对所有 PDF 分页图片进行批处理（同样是 PS 自带功能 选项卡：文件 – 自动 – 批处理）实在不行可以百度搜索：ps 批处理 将处理好的分页文件合成 PDF 完成 其中最重要的是摸索 PS 工具，将水印去除，这是技术核心。这个就没什么可教的了，百度一下 下一篇更新：pitstop 的使用 Pitstop 的使用方法（偏实用向，新手向）效果图 工具设置首先把 pitstop 的选择器 固定到快捷栏 工具栏 右键 自定义快速工具 找到 Pitstop 选择器 把选择对象和检查器以及动作列表固定上去 案例 1 分块水印分块水印的意识是 水印的这个也算比较复杂的了，我也是第一次遇到，当然这个也可以用 PS 搞，但不建议，因为这个不是纯图片格式的 pdf，也就是说他的每个元素是可以选择的。 首先用选择工具选择你想去除的水印，为了避免广告就拿这个押题来举例吧 右键 显示检查器 ：可以看到它不是文本，不是图片，讲真的我也以为要翻车了，之前没遇到过嘛。 但是注意到了它的颜色比较特别所以摸索了一下 打开动作列表，新建动作 在色彩里面找到选择填充色彩 注意：此时要保持选中水印才能抓取 添加移除所选对象动作 单页测试 测试成功则改成整个文档运行动作，到此完成 案例 2 固定位置水印 且无遮挡 还是老样子，选择器选择，查看属性，不是文本，不是图片，但位置固定（在页眉） 打开动作列表 找到： 选择区域内部或外部的对象 填入数据，注意：锚点数据复制粘贴即可，大小的数据可以稍大一点 单页测试运行即可 PITSTOP 中文过期解决办法打开文件夹：删除除动作列表之外的文件，不行就再替换一下激活文件C:\\Users\\w\\AppData\\Roaming\\Enfocus Prefs Folder refs Folder","tags":["🔖PS","🔖Pitstop"],"categories":["🔖Life"]},{"title":"关于小米的一些个人看法","path":"/posts/744f/","content":"%%% tip home %%%-仅仅是个人看法,不喜勿喷,不想吵架.%%% endtip %%%- 我的手机 在 miui+上面的截图,懒得手机截图了 刷的乌龟官改包,至于为什么不用原版,乌龟有个工具包,挺好用的. 工具包截图 乌龟的好像是开发板改的,基本跟原版差不多吧 目前感觉还不错流畅度 动画比之前是好多了 还不错的感觉 偶尔卡顿 感受不明显续航 我的小米 ⑨ 我换过中电的电池 好像是 3800 左右 一天一两充的样子 ,亮屏玩不了多久 只能说 够用发热 平常不打游戏 打游戏也问题不大 感觉还好 满分 5 分 给个 4 分应该不过分 毕竟是老机器了 而且最近一直有新功能在更新,感觉还不错 网上的言论网上说什么的都有,个人感觉喷子居多 我觉得有些点是被舆论放大很多,其实有些是小问题 至于某些型号发热 比如 火龙 888 这个我觉得大概率是真的 毕竟那么多人喷 也不可能空穴来风 而且 888 也是一头火龙 小米的调校本来就一般 这些都不是我在意的点,重点在下面 近期关键问题小米社区屏蔽关键词 发热 掉帧 等等讲真我刚开始看到这个觉得不可能,小米那么开放,肯定不是真的 但我去搜索 真的被屏蔽了 被网友发现之前 被网友骂了之后 有些词还是被屏蔽,没用 到这里其实也还好吧,为了压制舆论,我也理解,勉强接受 小米直面会耍猴就这个,看过的应该都想喷,果核剥壳也发推送讲这个真的太耍猴了,预告说讲讲近期问题,mix4 什么的,还有粉丝关注的问题巴拉巴拉 结果 放完广告就没了 我刚开始以为是线路出问题了 结果 没了 没了 真耍猴 然后各种推迟 小米你的信用哪去了 内测规则改动虽然我没进入内测区 但我好歹在开发板区里面 来看看规则吧 这不是 强行打工么 真拿米粉当屌丝 结语我之前喜欢魅族,现在依旧喜欢,虽然魅族管理也是瞎搞,但手机颜值和 flyme 真的没得说,从 pro7 的智慧屏开始凉凉,之后就没好过 那天跟室友开玩笑说,魅族从后屏开始凉凉,小米会不会也这样 没想到 一语成谶 就看小米后面的动作了 如果 只是 如果 如果 mix4 让粉丝伤心 那小米真的要走下坡路了 至少数码圈子不行了 就像当年的魅族 慢慢的慢慢的 没了没了 没了 但 如果 mix4 惊艳粉丝 凭一己之力 力压群雄,称霸数码圈 那 小米的未来可期 超越苹果 也不是没有可能 但是 但是 但是 如果 小米用惊艳 mix4 配上 miui 版本 小米的未来 我看不到 至少 无法 超越 苹果 就这 希望 MIX4 能 足够惊艳 小米 未来可期","tags":["📱 小米"],"categories":["🔖Life"]},{"title":"AHK脚本","path":"/posts/a583/","content":"关于ahk语言请百度，这里只是记录常用改键代码。 AHK按键参考表鼠标概述tt\tLButton\t鼠标左键RButton\t鼠标右键MButton\t鼠标中键或滚轮高级\tXButton1\t鼠标的第四个按钮 一般和 Browser_Back 执行相同功能XButton2\t鼠标的第五个按钮 一般和 Browser_Forward 执行相同功能Wheel\tWheelDown\t向下转动鼠标滚轮（向您的方向）WheelUp\t向上转动鼠标滚轮（远离您的方向）WheelLeftWheelRight 向左或向右滚动 需要 Windows Vista 或更高版本 这可以用在某些（但并非所有）带第二个滚轮或支持左右滚动的鼠标热键注意: 字母和数字按键的名称和单个字母或数字相同. 例如: b 表示 “b” 键而 5 表示 “5” 键. CapsLock\t大小写锁定键Space\t空格键Tab\tTab 键Enter (或 Return)\t回车键Escape (或 Esc)\t退出键Backspace (或 BS)\t退格键 ScrollLock\t滚动锁定键Delete (或 Del)\t删除键Insert (或 Ins)\t插入改写切换键Home\tHome 键End\tEnd 键PgUp\t向上翻页键PgDn\t向下翻页键Up\t向上方向键Down\t向下方向键Left\t向左方向键Right\t向右方向键 F1 - F24\t在大多数键盘顶部的 12 个或更多的功能键 按键修饰符\tLWin\t左边的 Windows 徽标键 对应的热键前缀为 &lt;#RWin\t右边的 Windows 徽标键 对应的热键前缀为 &gt;#注意：与 Control&#x2F;Alt&#x2F;Shift 不同，没有一般的&#x2F;中性的”Win”键，因为操作系统不支持 不过含 # 修饰符的热键可以被任何一个 Win 键触发 Control ^ Alt ! Shift\t+LControl（或 LCtrl） &lt;^RControl（或 RCtrl） &gt;^LShift\t左 Shift 键 对应的热键前缀为 &lt;+RShift\t右 Shift 键 对应的热键前缀为 &gt;+LAlt\t左 Alt 键 对应的热键前缀为 &lt;!RAlt\t右 Alt 键 对应的热键前缀为 &gt;! Browser_Back\t后退Browser_Forward\t前进Browser_Refresh\t刷新Browser_Stop\t停止Browser_Search\t搜索Browser_Favorites\t收藏夹Browser_Home\t主页Volume_Mute\t静音Volume_Down\t调低音量Volume_Up\t增加音量Media_Next\t下一首Media_Prev\t上一首Media_Stop\t停止Media_Play_Pause\tPlay&#x2F;PauseLaunch_Mail\t打开默认的电子邮件程序Launch_Media\t打开默认的媒体播放器Launch_App1\t打开我的电脑Launch_App2\t打开计算器注：上面列出的每个按键的功能可以通过修改 Windows 注册表进行替换 这个表格中显示的是在 Windows 系统的大多数版本中每个按键的默认功能特别\tAppsKey\t菜单键 这是调用右键上下文菜单的按键PrintScreen\t捕获屏幕CtrlBreak\t暂停\t暂停键中断\t中断键 由于此键和 Pause 含义相同，所以在热键中请使用 ^CtrlBreak 代替 ^Pause 或^Break帮助\t帮助键 此键可能在大多数键盘上不存在 它通常和 F1 不同.Sleep\t休眠键 注意在一些键盘上的 sleep 键可能不是休眠功能SCnnn\t请在 nnn 中指定按键的扫描码 识别上面没有提到的罕见的按键 请参阅特殊按键了解详情VKnn\t请在 nn 中指定十六进制的虚拟按键码 这种极少用的方法还可以避免某些类型的热键需要安装键盘钩子 例如，后面的热键不使用键盘钩子，但副作用是它会在按下 Home 或 NumpadHome 的其中一个时触发：^VK24::MsgBox You pressed Home or NumpadHome while holding down Control.已知限制：强制使用键盘钩子的 VK 热键，例如 *VK24 或 ~VK24，只会触发其中一个热键，而不会触发两者（例如触发 NumpadHome 但不触发 Home） 关于 VKnn 方法的更多细节，请参阅特殊按键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405;=====================================================================o; Feng Ruohang&#x27;s AHK Script | ; CapsLock Enhancement |;---------------------------------------------------------------------o;Description: |; This Script is wrote by Feng Ruohang via AutoHotKey Script. It |; Provieds an enhancement towards the &quot;Useless Key&quot; CapsLock, and |; turns CapsLock into an useful function Key just like Ctrl and Alt |; by combining CapsLock with almost all other keys in the keyboard. |; |;Summary: |;o----------------------o---------------------------------------------o;|CapsLock; | &#123;ESC&#125; Especially Convient for vim user |;|CaspLock + ` | &#123;CapsLock&#125;CapsLock Switcher as a Substituent|;|CapsLock + hjklwb | Vim-Style Cursor Mover |;|CaspLock + uiop | Convient Home/End PageUp/PageDn |;|CaspLock + nm,. | Convient Delete Controller |;|CapsLock + zxcvay | Windows-Style Editor |;|CapsLock + Direction | Mouse Move |;|CapsLock + Enter | Mouse Click |;|CaspLock + &#123;F1&#125;~&#123;F6&#125; | Media Volume Controller |;|CapsLock + qs | Windows &amp; Tags Control |;|CapsLock + ;&#x27;[] | Convient Key Mapping |;|CaspLock + dfert | Frequently Used Programs (Self Defined) |;|CaspLock + 123456 | Dev-Hotkey for Visual Studio (Self Defined) |;|CapsLock + 67890-= | Shifter as Shift |;-----------------------o---------------------------------------------o;|Use it whatever and wherever you like. Hope it help |;=====================================================================o;=====================================================================o; CapsLock Initializer ;|;---------------------------------------------------------------------oSetCapsLockState, AlwaysOff ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Switcher: ;|;---------------------------------o-----------------------------------o; CapsLock + ` | &#123;CapsLock&#125; ;|;---------------------------------o-----------------------------------oCapsLock &amp; `:: ;|GetKeyState, CapsLockState, CapsLock, T ;|if CapsLockState = D ;| SetCapsLockState, AlwaysOff ;|else ;| SetCapsLockState, AlwaysOn ;|KeyWait, `` ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Escaper: ;|;----------------------------------o----------------------------------o; CapsLock | &#123;ESC&#125; ;|;----------------------------------o----------------------------------oCapsLock::Send, &#123;ESC&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Direction Navigator ;|;-----------------------------------o---------------------------------o; CapsLock + h | Left ;|; CapsLock + j | Down ;|; CapsLock + k | Up ;|; CapsLock + l | Right ;|; Ctrl, Alt Compatible ;|;-----------------------------------o---------------------------------oCapsLock &amp; h:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Left&#125; ;| else ;| Send, +&#123;Left&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Left&#125; ;| else ;| Send, +^&#123;Left&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; j:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Down&#125; ;| else ;| Send, +&#123;Down&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Down&#125; ;| else ;| Send, +^&#123;Down&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; k:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Up&#125; ;| else ;| Send, +&#123;Up&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Up&#125; ;| else ;| Send, +^&#123;Up&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; l:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Right&#125; ;| else ;| Send, +&#123;Right&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Right&#125; ;| else ;| Send, +^&#123;Right&#125; ;| return ;|&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Home/End Navigator ;|;-----------------------------------o---------------------------------o; CapsLock + i | Home ;|; CapsLock + o | End ;|; Ctrl, Alt Compatible ;|;-----------------------------------o---------------------------------oCapsLock &amp; i:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Home&#125; ;| else ;| Send, +&#123;Home&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Home&#125; ;| else ;| Send, +^&#123;Home&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; o:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;End&#125; ;| else ;| Send, +&#123;End&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;End&#125; ;| else ;| Send, +^&#123;End&#125; ;| return ;|&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Page Navigator ;|;-----------------------------------o---------------------------------o; CapsLock + u | PageUp ;|; CapsLock + p | PageDown ;|; Ctrl, Alt Compatible ;|;-----------------------------------o---------------------------------oCapsLock &amp; u:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;PgUp&#125; ;| else ;| Send, +&#123;PgUp&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;PgUp&#125; ;| else ;| Send, +^&#123;PgUp&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; p:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;PgDn&#125; ;| else ;| Send, +&#123;PgDn&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;PgDn&#125; ;| else ;| Send, +^&#123;PgDn&#125; ;| return ;|&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Mouse Controller ;|;-----------------------------------o---------------------------------o; CapsLock + Up | Mouse Up ;|; CapsLock + Down | Mouse Down ;|; CapsLock + Left | Mouse Left ;|; CapsLock + Right | Mouse Right ;|; CapsLock + Enter(Push Release) | Mouse Left Push(Release) ;|;-----------------------------------o---------------------------------oCapsLock &amp; Up:: MouseMove, 0, -10, 0, R ;|CapsLock &amp; Down:: MouseMove, 0, 10, 0, R ;|CapsLock &amp; Left:: MouseMove, -10, 0, 0, R ;|CapsLock &amp; Right:: MouseMove, 10, 0, 0, R ;|;-----------------------------------o ;|CapsLock &amp; Enter:: ;|SendEvent &#123;Blind&#125;&#123;LButton down&#125; ;|KeyWait Enter ;|SendEvent &#123;Blind&#125;&#123;LButton up&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Deletor ;|;-----------------------------------o---------------------------------o; CapsLock + n | Ctrl + Delete (Delete a Word) ;|; CapsLock + m | Delete ;|; CapsLock + , | BackSpace ;|; CapsLock + . | Ctrl + BackSpace ;|;-----------------------------------o---------------------------------oCapsLock &amp; ,:: Send, &#123;Del&#125; ;|CapsLock &amp; .:: Send, ^&#123;Del&#125; ;|CapsLock &amp; m:: Send, &#123;BS&#125; ;|CapsLock &amp; n:: Send, ^&#123;BS&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Editor ;|;-----------------------------------o---------------------------------o; CapsLock + z | Ctrl + z (Cancel) ;|; CapsLock + x | Ctrl + x (Cut) ;|; CapsLock + c | Ctrl + c (Copy) ;|; CapsLock + v | Ctrl + z (Paste) ;|; CapsLock + a | Ctrl + a (Select All) ;|; CapsLock + y | Ctrl + z (Yeild) ;|; CapsLock + w | Ctrl + Right(Move as [vim: w]);|; CapsLock + b | Ctrl + Left (Move as [vim: b]);|;-----------------------------------o---------------------------------oCapsLock &amp; z:: Send, ^z ;|CapsLock &amp; x:: Send, ^x ;|CapsLock &amp; c:: Send, ^c ;|CapsLock &amp; v:: Send, ^v ;|CapsLock &amp; a:: Send, ^a ;|CapsLock &amp; y:: Send, ^y ;|CapsLock &amp; w:: Send, ^&#123;Right&#125; ;|CapsLock &amp; b:: Send, ^&#123;Left&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Media Controller ;|;-----------------------------------o---------------------------------o; CapsLock + F1 | Volume_Mute ;|; CapsLock + F2 | Volume_Down ;|; CapsLock + F3 | Volume_Up ;|; CapsLock + F3 | Media_Play_Pause ;|; CapsLock + F5 | Media_Next ;|; CapsLock + F6 | Media_Stop ;|;-----------------------------------o---------------------------------oCapsLock &amp; F1:: Send, &#123;Volume_Mute&#125; ;|CapsLock &amp; F2:: Send, &#123;Volume_Down&#125; ;|CapsLock &amp; F3:: Send, &#123;Volume_Up&#125; ;|CapsLock &amp; F4:: Send, &#123;Media_Play_Pause&#125; ;|CapsLock &amp; F5:: Send, &#123;Media_Next&#125; ;|CapsLock &amp; F6:: Send, &#123;Media_Stop&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Window Controller ;|;-----------------------------------o---------------------------------o; CapsLock + s | Ctrl + Tab (Swith Tag) ;|; CapsLock + q | Ctrl + W (Close Tag) ;|; (Disabled) Alt + CapsLock + s | AltTab (Switch Windows) ;|; Alt + CapsLock + q | Ctrl + Tab (Close Windows) ;|; CapsLock + g | AppsKey (Menu Key) ;|;-----------------------------------o---------------------------------oCapsLock &amp; s::Send, ^&#123;Tab&#125; ;|;-----------------------------------o ;|CapsLock &amp; q:: ;|if GetKeyState(&quot;alt&quot;) = 0 ;|&#123; ;| Send, ^w ;|&#125; ;|else &#123; ;| Send, !&#123;F4&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; g:: Send, &#123;AppsKey&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Self Defined Area ;|;-----------------------------------o---------------------------------o; CapsLock + d | Alt + d(Dictionary) ;|; CapsLock + f | Alt + f(Search via Everything);|; CapsLock + e | Open Search Engine ;|; CapsLock + r | Open Shell ;|; CapsLock + t | Open Text Editor ;|;-----------------------------------o---------------------------------oCapsLock &amp; d:: Send, !d ;|CapsLock &amp; f:: Send, !f ;|CapsLock &amp; e:: Run http://cn.bing.com/ ;|CapsLock &amp; r:: Run Powershell ;|CapsLock &amp; t:: Run C:\\Program Files (x86)\\Notepad++ otepad++.exe ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Char Mapping ;|;-----------------------------------o---------------------------------o; CapsLock + ; | Enter (Cancel) ;|; CapsLock + &#x27; | = ;|; CapsLock + [ | Back (Visual Studio) ;|; CapsLock + ] | Goto Define (Visual Studio) ;|; CapsLock + / | Comment (Visual Studio) ;|; CapsLock + \\ | Uncomment (Visual Studio) ;|; CapsLock + 1 | Build and Run(Visual Studio) ;|; CapsLock + 2 | Debuging (Visual Studio) ;|; CapsLock + 3 | Step Over (Visual Studio) ;|; CapsLock + 4 | Step In (Visual Studio) ;|; CapsLock + 5 | Stop Debuging(Visual Studio) ;|; CapsLock + 6 | Shift + 6 ^ ;|; CapsLock + 7 | Shift + 7 &amp; ;|; CapsLock + 8 | Shift + 8 * ;|; CapsLock + 9 | Shift + 9 ( ;|; CapsLock + 0 | Shift + 0 ) ;|;-----------------------------------o---------------------------------oCapsLock &amp; `;:: Send, &#123;Enter&#125; ;|CapsLock &amp; &#x27;:: Send, = ;|CapsLock &amp; [:: Send, ^- ;|CapsLock &amp; ]:: Send, &#123;F12&#125; ;|;-----------------------------------o ;|CapsLock &amp; /:: ;|Send, ^e ;|Send, c ;|return ;|;-----------------------------------o ;|CapsLock &amp; \\:: ;|Send, ^e ;|Send, u ;|return ;|;-----------------------------------o ;|CapsLock &amp; 1:: Send,^&#123;F5&#125; ;|CapsLock &amp; 2:: Send,&#123;F5&#125; ;|CapsLock &amp; 3:: Send,&#123;F10&#125; ;|CapsLock &amp; 4:: Send,&#123;F11&#125; ;|CapsLock &amp; 5:: Send,+&#123;F5&#125; ;|;-----------------------------------o ;|CapsLock &amp; 6:: Send,+6 ;|CapsLock &amp; 7:: Send,+7 ;|CapsLock &amp; 8:: Send,+8 ;|CapsLock &amp; 9:: Send,+9 ;|CapsLock &amp; 0:: Send,+0 ;|;---------------------------------------------------------------------o 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217^RButton:: Run D:\\Windows\\Snipaste-2.5.1-Beta-x64\\Snipaste.exe snip#WheelDown:: Send, &#123;Volume_Down&#125;#WheelUp:: Send, &#123;Volume_Up&#125;;~LControl:: ;if ( A_PriorHotkey=A_ThisHotkey &amp;&amp; A_TimeSincePriorHotkey &lt; 400 &amp;&amp; A_TimeSincePriorHotkey &gt; 100) ;If WinExist(&quot;搜索&quot;);WinHide ; 使用前面找到的窗口;If !WinExist(&quot;搜索&quot;) ;else\t;\tsend +!F; returnCapsLock &amp; space:: Send, &#123;Enter&#125; CapsLock &amp; 1:: Send,&#123;Enter&#125; CapsLock &amp; v:: Send, ^!&#123;u&#125;Sleep,2000Send, &#123;right&#125;ReturnPgUp:: Send, ^&#123;c&#125;Send, &#123;TAB&#125;Send, ^&#123;v&#125;Send, &#123;ENTER&#125;Return CapsLock &amp; a:: Send, &#123;Left&#125; CapsLock &amp; s:: Send, &#123;Down&#125;CapsLock &amp; d:: Send, &#123;Right&#125;CapsLock &amp; w:: Send, &#123;Up&#125; CapsLock &amp; r:: Send, &#123;F5&#125; CapsLock &amp; Up:: MouseMove, 0, -10, 0, R CapsLock &amp; Down:: MouseMove, 0, 10, 0, R CapsLock &amp; Left:: MouseMove, -10, 0, 0, R CapsLock &amp; Right:: MouseMove, 10, 0, 0, R CapsLock &amp; RShift:: Send, / CapsLock &amp; x:: Send, &#123;Del&#125; CapsLock &amp; z:: Send, &#123;BS&#125; CapsLock &amp; q:: Send, &#123;PrintScreen&#125; ;CapsLock &amp; 3:: CapsLock &amp; F:: Send, +&#123;;&#125; CapsLock &amp; 4:: Send,&#123;F11&#125; CapsLock &amp; 5:: Run https://www.52pojie.cn/ CapsLock &amp; 6:: Send,+6 CapsLock &amp; 7:: Send,+7 ^&amp;&amp; CapsLock &amp; 8:: Send,+8 CapsLock &amp; 9:: Run D:\\onedrive\\XXQG\\123.ahkSleep, 1500Send, &#123;F3&#125; return CapsLock &amp; 0:: Run D:\\onedrive\\XXQG\\XXQG.ahkSleep, 1500Send, &#123;F2&#125; return ;---------------------------------------------------------------------o CapsLock &amp; c:: Run Powershell CapsLock &amp; t:: Run C:\\WINDOWS\\system32 otepad.exe /* ;-----------------------------------o CapsLock &amp; /:: Send, ^e Send, c return ;-----------------------------------o CapsLock &amp; \\:: Send, ^e Send, u return -----------------------------------o */ ;上下左右 wasd/*CapsLock &amp; a:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Left&#125; else Send, +&#123;Left&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Left&#125; else Send, +^&#123;Left&#125; return &#125; return ;-----------------------------------o CapsLock &amp; s:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Down&#125; else Send, +&#123;Down&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Down&#125; else Send, +^&#123;Down&#125; return &#125; return ;-----------------------------------o CapsLock &amp; w:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Up&#125; else Send, +&#123;Up&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Up&#125; else Send, +^&#123;Up&#125; return &#125; return ;-----------------------------------o CapsLock &amp; d:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Right&#125; else Send, +&#123;Right&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Right&#125; else Send, +^&#123;Right&#125; return &#125; return /*CapsLock &amp; 1:: ;|if GetKeyState(&quot;alt&quot;) = 1 ;|&#123; ;| Send,`#`# return ;|&#125; ;| ;| Send,`#`# return ;| ;|return */SetCapsLockState, AlwaysOff ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Switcher: ;|;---------------------------------o-----------------------------------o; CapsLock + ` | &#123;CapsLock&#125; ;|;---------------------------------o-----------------------------------oCapsLock &amp; `:: ;|GetKeyState, CapsLockState, CapsLock, T ;|if CapsLockState = D ;| SetCapsLockState, AlwaysOff ;|else ;| SetCapsLockState, AlwaysOn ;|KeyWait, `` ;|return */","tags":["⌨️ AHK"],"categories":["💻Code"]},{"title":"看板罗小黑-live2d","path":"/posts/bc41/","content":"最终效果左下角就有 安装插件1npm install --save hexo-helper-live2d --save 主题配置打开站点配置文件，插入 推荐配置 1234567891011121314151617181920212223242526272829live2d: enable: true #开关插件版看板娘 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-luoxiaohei # npm-module package name scale: 1.15 hHeadPos: 0.5 vHeadPos: 0.618 display: position: left #控制看板娘位置left or right width: 300 #控制画布大小 height: 600 #控制画布大小 superSample: 2 hOffset: 20 #水平方向 vOffset: -180 #垂直方向 mobile: show: false # 手机中是否展示，建议关闭，位置不好调整 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 这是我调整好的效果，如果想自定义，请按注释配置 安装罗小黑皮肤1npm install --save live2d-widget-model-luoxiaohei --save 一键三连 记得去给 up 主一键三连123hexo cleanhexo ghexo s 桌面版仓库zenghongtu&#x2F;PPet: 👻 在你的桌面放一个萌妹子，多一点趣味 😏~（支持 Mac、Win 和 Linux） (github.com) 导入模型即可（模型去 up 主视频下面下载） 猫形态-人形态变换 因为没有能力自建 API，所以只能咯咯咯 相关资料在这里 fghrsh&#x2F;live2d_api: Live2D 看板娘插件 (https://www.fghrsh.net/post/123.html) 上使用的后端 API (github.com) stevenjoezhang&#x2F;live2d-widget: 把萌萌哒的看板娘抱回家 (ノ ≧∇≦)ノ | Live2D widget for web platform (github.com) 如果有大佬建了 api,请踢我一脚（评论区留言） 其他刚才百度，还发现了其他的模型，牛！ 【罗小黑战记】比丢 live 2d+facerig 演示_哔哩哔哩_bilibili 「罗小黑战记」哪吒 live2d 互动壁纸展示,游戏,RPG 游戏,好看视频 (baidu.com) 把罗小黑官方宣传海报动画化！肝爆的 live2d 动态海报制作！_哔哩哔哩_bilibili 不过都没链接，可能得去软件里面扒。 关于 api折腾半天，也没成功，大佬记得踢我一脚。 %%% tip home %%%-感谢 b 站宝藏 up 主我把罗小黑做成了 Live2D 虚拟主播！_哔哩哔哩_bilibili提供的罗小黑 live2d 模型、EYHN&#x2F;hexo-helper-live2d插件、Live2d Widget | Akilar の糖果屋 %%% endtip %%%-","tags":["💻Hexo","🦾live2d"],"categories":["💻Code"]},{"title":"冰球 背景","path":"/posts/c6bd/","content":"%%% tip home %%%- 首先感谢大佬的开源项目 %%% ghcard teachtyler&#x2F;Icosahedron-Geometry %%%- 还有店长的教程糖果屋微调合集 | Akilar の糖果屋 Custom Beautify | Akilar の糖果屋 %%% span red, 未实现：冰球跟随音乐振动 %%%- 希望有大佬来解决这个问题，我这个小菜鸡实在搞不定。 有建议请评论区留言，欢迎！！ 7.27 更新：关闭移动端并根据屏幕大小判断是否引入并开启 %%% endtip %%%- 最终效果 引入 js只针对 butterfly 主题，其他主题请自己根据情况调整 icebg.js 代码在最下面 在_config.butterfly.yml中inject的bottom:插入代码 1-(&lt;script data-pjax src=&quot;你自己icebg.js的地址&quot;&gt;&lt;/script&gt;); 建议修改合适后再通过 jsd 加速插入，因为每个人需求不一样，如果你想要本站一样的效果就改成这样,如果需要自定义请接着看。 当然，建议读者把代码存到自己仓库 如果只需要当背景，而不是头图，到这里就够了，如果想要跟本站一样，参考店长头图透明教程在costom.css文件中加入 1234/* 头图透明 */#page-header&#123; background: transparent!important;&#125; 注意：因为 butterfly 版本迭代，店长教程中的配置手机 PC 页面白天黑夜共四个背景图的第一步请按diff代码块配置。因为我就掉坑了 店长教程点这里Custom Beautify | Akilar の糖果屋,建议配合糖果屋微调合集 | Akilar の糖果屋配置手机 PC 页面白天黑夜共四个背景图食用，效果更佳。 然后 然后就没了，就这，对，就这。 自定义建议有一定基础的朋友进行自定义修改，比如把球改到侧边栏 icebg.js 我放在了source博客根目录，方便调试，读者可以根据情况修改。 1-(&lt;script data-pjax src=&quot;/icebg.js&quot;&gt;&lt;/script&gt;); 自定义只需要修改icebg.js内的代码就可以了，代码还是挺长的，其他的我也不会了，大家看着办吧，有大佬改记得评论区告诉我一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366// document.write(&quot;&lt;script src=&#x27;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&#x27;&gt;&lt;/script&gt;&quot;);var renderer, scene, camera, composer, lights, circle, skelet, particle, planet, planet2, audioArray, user_audio_amp, audio_wireframe = true, primaryColor = null, secondaryColor = null, thirdColor = null, bg_file, move_bg, bass_wireframe;function loadScript(src, callback) &#123; var script = document.createElement(&quot;script&quot;), head = document.getElementsByTagName(&quot;head&quot;)[0]; script.type = &quot;text/javascript&quot;; script.charset = &quot;UTF-8&quot;; script.src = src; if (script.addEventListener) &#123; script.addEventListener( &quot;load&quot;, function () &#123; callback(); &#125;, false ); &#125; else if (script.attachEvent) &#123; script.attachEvent(&quot;onreadystatechange&quot;, function () &#123; var target = window.event.srcElement; if (target.readyState == &quot;loaded&quot;) &#123; callback(); &#125; &#125;); &#125; head.appendChild(script);&#125;function loadlived() &#123; if (document.body.clientWidth &gt; 900) &#123; document.onreadystatechange = function () &#123; if (document.readyState == &quot;complete&quot;) &#123; loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&quot;, function () &#123;&#125; ); loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/three.min.js&quot;, function () &#123; init(); animate(); &#125; ); &#125; &#125;; &#125;&#125;loadlived();// if (document.body.clientWidth &gt; 768) &#123;// init();// animate();// &#125;;// document.write(&quot;&lt;script src=&#x27;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&#x27;&gt;&lt;/script&gt;&quot;);var renderer, scene, camera, composer, lights, circle, skelet, particle, planet, planet2, audioArray, user_audio_amp, audio_wireframe = true, primaryColor = null, secondaryColor = null, thirdColor = null, bg_file, move_bg, bass_wireframe;function loadScript(src, callback) &#123; var script = document.createElement(&quot;script&quot;), head = document.getElementsByTagName(&quot;head&quot;)[0]; script.type = &quot;text/javascript&quot;; script.charset = &quot;UTF-8&quot;; script.src = src; if (script.addEventListener) &#123; script.addEventListener( &quot;load&quot;, function () &#123; callback(); &#125;, false ); &#125; else if (script.attachEvent) &#123; script.attachEvent(&quot;onreadystatechange&quot;, function () &#123; var target = window.event.srcElement; if (target.readyState == &quot;loaded&quot;) &#123; callback(); &#125; &#125;); &#125; head.appendChild(script);&#125;function loadlived() &#123; if (document.body.clientWidth &gt; 900) &#123; document.onreadystatechange = function () &#123; if (document.readyState == &quot;complete&quot;) &#123; loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&quot;, function () &#123;&#125; ); loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/three.min.js&quot;, function () &#123; init(); animate(); &#125; ); &#125; &#125;; &#125;&#125;loadlived();// if (document.body.clientWidth &gt; 768) &#123;// init();// animate();// &#125;;function rgb2hex(rgb) &#123; rgb = rgb.match( /^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i ); return rgb &amp;&amp; rgb.length === 4 ? &quot;&quot; + (&quot;0&quot; + parseInt(rgb[1], 10).toString(16)).slice(-2) + (&quot;0&quot; + parseInt(rgb[2], 10).toString(16)).slice(-2) + (&quot;0&quot; + parseInt(rgb[3], 10).toString(16)).slice(-2) : &quot;&quot;;&#125;function init() &#123; var noise = new SimplexNoise(); renderer = new THREE.WebGLRenderer(&#123; antialias: true, alpha: true &#125;); renderer.setSize(document.body.clientWidth, document.body.clientHeight); // renderer.autoClear = false; // renderer.setClearColor(0x000000, 0.0); document.getElementById(&quot;web_bg&quot;).appendChild(renderer.domElement); scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.z = 400; scene.add(camera); circle = new THREE.Object3D(); skelet = new THREE.Object3D(); particle = new THREE.Object3D(); scene.add(circle); scene.add(skelet); scene.add(particle); var geometry = new THREE.TetrahedronGeometry(2, 0); // random particles var geom = new THREE.IcosahedronGeometry(7, 1); // center planet geom.verticesNeedUpdate = true; var geom2 = new THREE.IcosahedronGeometry(15, 1); // wireframe var material = new THREE.MeshPhongMaterial(&#123; color: 0xffffff, shading: THREE.FlatShading, &#125;); // 碎片数量 for (var i = 0; i &lt; 100; i++) &#123; var mesh = new THREE.Mesh(geometry, material); mesh.position .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5) .normalize(); mesh.position.multiplyScalar(90 + Math.random() * 700); mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2); particle.add(mesh); &#125; var mat = new THREE.MeshPhongMaterial(&#123; color: 0x99cccc, shading: THREE.FlatShading, &#125;); var mat2 = new THREE.MeshPhongMaterial(&#123; color: 0xffffff, wireframe: true, side: THREE.DoubleSide, &#125;); planet = new THREE.Mesh(geom, mat); planet.verticesNeedUpdate = true; planet.scale.x = planet.scale.y = planet.scale.z = 16; circle.add(planet); planet2 = new THREE.Mesh(geom2, mat2); planet2.scale.x = planet2.scale.y = planet2.scale.z = 10; skelet.add(planet2); var ambientLight = new THREE.AmbientLight(0x999999); scene.add(ambientLight); lights = []; lights[0] = new THREE.DirectionalLight(0xffffff, 1); lights[0].position.set(1, 0, 0); lights[1] = new THREE.DirectionalLight(0x01183c, 1); lights[1].position.set(0.75, 1, 0.5); lights[2] = new THREE.DirectionalLight(0x00436f, 1); lights[2].position.set(-0.75, -1, 0.5); scene.add(lights[0]); scene.add(lights[1]); scene.add(lights[2]);&#125;function moveObject(prop, math, num, timer = 0) &#123; if (math === &quot;add&quot;) &#123; prop += num; &#125; if (math === &quot;subtract&quot;) &#123; prop -= num; &#125; if (math === &quot;bounce&quot;) &#123; prop.x += num; prop.y += num; prop.z += num; setTimeout(() =&gt; &#123; prop.x -= num; prop.y -= num; prop.z -= num; &#125;, timer); &#125;&#125;function animate() &#123; requestAnimationFrame(animate); if (audio_wireframe) &#123; var planets = [planet, planet2]; &#125; else &#123; var planets = [planet]; &#125; if (audioArray !== undefined) &#123; // var random = Math.floor(Math.random() * audioArray.length - 100) var amp = 1.1; var user_amp = eval(&quot;1.&quot;.concat(user_audio_amp || &quot;80&quot;)); var bass_user_amp = eval(&quot;0.&quot;.concat(user_audio_amp || &quot;80&quot;)); // var user_amp = 1.99 var baseAmp = eval(&quot;0.&quot;.concat(user_audio_amp)) planet planets.map(function (planet) &#123; planet.geometry.vertices.forEach(function (vertex, i) &#123; var beat = audioArray[i]; var volume = audioArray.reduce(function (a, b) &#123; return a + b; &#125;); if (volume &lt;= 2) &#123; beat = beat * 10; &#125; var offset = planet.geometry.parameters.radius; vertex.normalize(); var distance; if (user_audio_amp === 100) &#123; beat = beat * 2; bass_user_amp = 1; distance = offset + beat * user_amp; // distance = offset + beat &#125; else &#123; beat = beat * user_amp; var time = Date.now(); var noiseX = vertex.x + time * 0.0005; var noiseY = vertex.y + time * 0.0005; var noiseZ = vertex.z + time * 0.0005; var planetNoise = noise.noise3D(noiseX, noiseY, noiseZ); distance = offset + planetNoise * beat; // if (turn_liquid) &#123; // distance = offset + beat + user_amp * planetNoise // turns liquid!? // &#125; // if (distance &gt; 15)&#123; // distance = offset + (beat / 2) * 1.1 // debug(distance) // &#125; &#125; // var bass_amp = (bass_user_amp &lt; 0.3) ? 0.3 : (1 - bass_user_amp) var bass_amp = 1 - bass_user_amp; if (bass_amp &lt;= 0.3) &#123; bass_amp = 0.3; &#125; if (i &lt;= 3 &amp;&amp; beat &gt; bass_amp) &#123; if (audio_wireframe === false &amp;&amp; bass_wireframe) &#123; audio_wireframe = true; setTimeout(function () &#123; audio_wireframe = false; &#125;, 250); &#125; if (move_bg) &#123; particle.rotation.x += Math.random() * 0.0005; particle.rotation.y -= Math.random() * 0.004; circle.rotation.x += 0.002; circle.rotation.y -= 0.004; var timer = (beat * 100) / 0.2; moveObject(skelet.position, &quot;bounce&quot;, 0.05, timer); moveObject(planet.position, &quot;bounce&quot;, 0.05, timer); moveObject(particle.position, &quot;bounce&quot;, 0.05, timer); &#125; &#125; vertex.multiplyScalar(distance &lt;= 0.1 ? 1 : distance); &#125;); planet.geometry.verticesNeedUpdate = true; planet.geometry.normalsNeedUpdate = true; planet.geometry.computeVertexNormals(); planet.geometry.computeFaceNormals(); &#125;); &#125; particle.rotation.x += 0.0; particle.rotation.y -= 0.001; circle.rotation.x -= 0.002; circle.rotation.y -= 0.003; skelet.rotation.x -= 0.001; skelet.rotation.y += 0.002; renderer.clear(); renderer.render(scene, camera);&#125;","tags":["💻Hexo"],"categories":["💻Code"]},{"title":"词云图","path":"/posts/40a1/","content":"微词云 微词云 · 简单强大的文字云艺术生成器 (weiciyun.com) %%% folding green, 共享账号、来自吾爱破解论坛 %%%- 15838146089 wang@6089 %%% endfolding %%%- 图悦图悦-在线词频分析工具-词云图制作软件 (picdata.cn) 优词云能用且免费，但不是很好看，有广告但可以跳过。 优词云|词云|标签云|专业强大的在线词云制作工具|在线标签云制作 (uciyun.com) WordItOut EdWordle比较适用于英文文章，中文可以但不好用。 Create word clouds WordItOut EdWordle WordArt.com很慢，慢到我还没用过 Edit word art - WordArt.com","tags":["🌨️词云图"]},{"title":"使用又拍云加速后的HTTPS访问和DNS设置","path":"/posts/ce44/","content":"%%% tip home %%%-https 折腾好久，就是搞不定，最后是自己配置有问题，所以来写个教程 域名以我自己的为例 wxydejoy.top 注：本教程适用于有一定折腾基础的朋友，主要是裸域名的访问，有建议可以评论。 %%% endtip %%%- 最终效果记得 cmdipconfig /flushdns 记得 cmdipconfig /flushdns 记得 cmdipconfig /flushdns 记得 cmdipconfig /flushdns 怎么样，不错吧 Gitpage 设置其实之前有的就不用修改，只是确认一下 Page 设置这个其实是用来检测你的其他设置有没有问题 CNAME 文件 DNS 解析这里答案不唯一，多种方案都行，推荐设置，此处感谢 @哔(bì)哗(huá) 大佬的帮助 尽量照抄。 原理(不一定对，但能用) DNS 设置 又拍云 CDN 加速CDN 怎么开启这里不讲了，只讲关键配置 服务名称随意 裸域名的 CDN 配置 www 域名的 CDN 配置 建议不得不说我现在 typora 配合 picgo 和又拍云写教程很香，之前 GitHub 图床上传超慢，现在秒上传 可以开个存储仓库用来做图床，很香。 另外设置好 cdn 加速之后，可以打开静态资源加速，很不错。 SSL 证书申请这一步最为关键，我这里是阿里的 ssl 免费证书，哪家都可以，建议在自己购买域名的地方申请，可以一键设置 dns 解析，方便快捷。 到这里就可以点击验证，当然如果是其他地方申请的参照各个服务商的设置。 域名验证成功，域名验证记录在证书签发后再删除，否则会因没有解析记录导致证书签发失败。 这里可以看到证书对www.wxydejoy.top和wxydejoy.top是都可用的，接下来会提到。 签发后等一下可以删掉 别忘了在申请证书那地方下载证书 又拍云的 HTTPS 访问设置然后到又拍云 填入刚才下好的证书（文本格式），全部复制就好，全部复制！！！ %%% tip home %%%-一定要记得两个域名(www 和裸域名)都要打开强制 https，不然 www 是打不开的 %%% endtip %%%- 到这里就结束了 记得把签发验证的 dns 解析删掉，不删也问题不大 检验建议用手机开流量访问测试，电脑延迟还是蛮久的，或者重启(有路由器的重启路由器，尤其是闪讯) 记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns","tags":["💻Hexo"],"categories":["💻Code"]},{"title":"emoji大全","path":"/posts/6bdd/","content":"https://copy.emojiall.com/zh-hans/ 🚩23 🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥emoji 表情😀😃😄😁😆😅🤣😂:)🙃😉:)😇🥰😍🤩😘😗☺️😚😙🥲😋😛😜🤪😝🤑🤗🤭🤫🤔🤐🤨😐😑😶😏😒🙄😬🤥😌😔😪🤤😴😷🤒🤕🤢🤮🤧🥵🥶🥴😵🤯🤠🥳😎🤓🧐😕😟🙁☹️😮😯😲😳🥺😦😧😨😰😥😢😭😱😖😣😞😓😩😫🥱😤😡😠🤬emoji 人物👶🧒👦👧🧑👱👨🧔👨‍🦰👨‍🦱👨‍🦳👨‍🦲👩👩‍🦰🧑‍🦰👩‍🦱🧑‍🦱👩‍🦳🧑‍🦳👩‍🦲🧑‍🦲👱‍♀️👱‍♂️🧓👴👵🙍🙍‍♂️🙍‍♀️🙎🙎‍♂️🙎‍♀️🙅🙅‍♂️🙅‍♀️🙆🙆‍♂️🙆‍♀️💁💁‍♂️💁‍♀️🙋🙋‍♂️🙋‍♀️🧏🧏‍♂️🧏‍♀️🙇🙇‍♂️🙇‍♀️🤦🤦‍♂️🤦‍♀️🤷🤷‍♂️🤷‍♀️🧑‍⚕️👨‍⚕️👩‍⚕️🧑‍🎓👨‍🎓👩‍🎓🧑‍🏫👨‍🏫👩‍🏫🧑‍⚖️👨‍⚖️👩‍⚖️🧑‍🌾👨‍🌾👩‍🌾🧑‍🍳👨‍🍳👩‍🍳🧑‍🔧👨‍🔧👩‍🔧🧑‍🏭👨‍🏭👩‍🏭🧑‍💼👨‍💼👩‍💼🧑‍🔬👨‍🔬👩‍🔬🧑‍💻👨‍💻👩‍💻🧑‍🎤👨‍🎤👩‍🎤🧑‍🎨👨‍🎨👩‍🎨🧑‍✈️👨‍✈️👩‍✈️🧑‍🚀👨‍🚀👩‍🚀🧑‍🚒👨‍🚒👩‍🚒👮👮‍♂️👮‍♀️🕵️🕵️‍♂️🕵️‍♀️💂💂‍♂️💂‍♀️🥷👷👷‍♂️👷‍♀️🤴👸👳👳‍♂️👳‍♀️👲🧕🤵🤵‍♂️🤵‍♀️👰👰‍♂️👰‍♀️🤰🤱👩‍🍼👨‍🍼🧑‍🍼👼🎅🤶🧑‍🎄🦸🦸‍♂️🦸‍♀️🦹🦹‍♂️🦹‍♀️🧙🧙‍♂️🧙‍♀️🧚🧚‍♂️🧚‍♀️🧛🧛‍♂️🧛‍♀️🧜🧜‍♂️🧜‍♀️🧝🧝‍♂️🧝‍♀️🧞🧞‍♂️🧞‍♀️🧟🧟‍♂️🧟‍♀️💆💆‍♂️💆‍♀️💇💇‍♂️💇‍♀️🚶🚶‍♂️🚶‍♀️🧍🧍‍♂️🧍‍♀️🧎🧎‍♂️🧎‍♀️🧑‍🦯👨‍🦯👩‍🦯🧑‍🦼👨‍🦼👩‍🦼🧑‍🦽👨‍🦽👩‍🦽🏃🏃‍♂️🏃‍♀️💃🕺🕴️👯👯‍♂️👯‍♀️🧖🧖‍♂️🧖‍♀️🧘🧑‍🤝‍🧑👭👫👬💏👩‍❤️‍💋‍👨👨‍❤️‍💋‍👨👩‍❤️‍💋‍👩💑👩‍❤️‍👨👨‍❤️‍👨👩‍❤️‍👩👪👨‍👩‍👦👨‍👩‍👧👨‍👩‍👧‍👦👨‍👩‍👦‍👦👨‍👩‍👧‍👧👨‍👨‍👦👨‍👨‍👧👨‍👨‍👧‍👦👨‍👨‍👦‍👦👨‍👨‍👧‍👧👩‍👩‍👦👩‍👩‍👧👩‍👩‍👧‍👦👩‍👩‍👦‍👦👩‍👩‍👧‍👧👨‍👦👨‍👦‍👦👨‍👧👨‍👧‍👦👨‍👧‍👧👩‍👦👩‍👦‍👦👩‍👧👩‍👧‍👦👩‍👧‍👧🗣️👤👥🫂emoji 手势👋🤚🖐️✋🖖👌🤌🤏✌️🤞🤟🤘🤙👈👉👆🖕👇☝️👍👎✊👊🤛🤜👏🙌👐🤲🤝🙏✍️💅🤳💪emoji 日常👣👀👁️👄💋👂🦻👃👅🧠🦷🦴💪🦾🦿🦵🦶👓🕶️🥽🥼🦺👔👕👖🧣🧤🧥🧦👗👘🥻🩱🩲🩳👙👚👛👜👝🎒👞👟🥾🥿👠👡🩰👢👑👒🎩🎓🧢⛑️💄💅💍💼🌂☂️💈🛀🛌💥💫💦💨emoji 手机📱📲📶📳📴☎📞📟📠🤳emoji 公共♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈emoji 动物🙈🙉🙊💥💫💦💨🐵🐒🦍🦧🐶🐕🦮🐕‍🦺🐩🐺🦊🦝🐱🐈🐈‍⬛🦁🐯🐅🐆🐴🐎🦄🦓🦌🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🦙🦒🐘🦏🦛🐭🐁🐀🐹🐰🐇🐿️🦔🦇🐻🐻‍❄️🐨🐼🦥🦦🦨🦘🦡🐾🦃🐔🐓🐣🐤🐥🐦🐧🕊️🦅🦆🦢🦉🦩🦚🦜🐸🐊🐢🦎🐍🐲🐉🦕🦖🐳🐋🐬🐟🐠🐡🦈🐙🐚🐌🦋🐛🐜🐝🐞🦗🕷️🕸️🦂🦟🦠🦀🦞🦐🦑emoji 植物💐🌸💮🏵️🌹🥀🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿☘️🍀🍁🍂🍃emoji 自然🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀️🌝🌞⭐🌟🌠☁️⛅⛈️🌤️🌥️🌦️🌧️🌨️🌩️🌪️🌫️🌬️🌈☂️☔⚡❄️☃️⛄☄️🔥💧🌊emoji 饮食🍇🍈🍉🍊🍋🍌🍍🥭🍎🍏🍐🍑🍒🍓🥝🍅🥥🥑🍆🥔🥕🌽🌶️🥒🥬🥦🧄🧅🍄🥜🌰🍞🥐🥖🫓🥨🥯🥞🧇🧀🍖🍗🥩🥓🍔🍟🍕🌭🥪🌮🌯🥙🧆🥚🍳🥘🍲🥣🥗🍿🧈🧂🥫🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🥮🍡🥟🥠🥡🦪🍦🍧🍨🍩🍪🎂🍰🧁🥧🍫🍬🍭🍮🍯🍼🥛☕🍵🍶🍾🍷🍸🍹🍺🍻🥂🥃🥤🧋🧃🧉🧊🥢🍽️🍴🥄emoji 文体🧗🧗‍♂️🧗‍♀️🤺🏇⛷️🏂🏌️🏌️‍♂️🏌️‍♀️🏄🏄‍♂️🏄‍♀️🚣🚣‍♂️🚣‍♀️🏊🏊‍♂️🏊‍♀️⛹️⛹️‍♂️⛹️‍♀️🏋️🏋️‍♂️🏋️‍♀️🚴🚴‍♂️🚴‍♀️🚵🚵‍♂️🚵‍♀️🤸🤸‍♂️🤸‍♀️🤼🤼‍♂️🤼‍♀️🤽🤽‍♂️🤽‍♀️🤾🤾‍♂️🤾‍♀️🤹🤹‍♂️🤹‍♀️🧘🧘‍♂️🧘‍♀️🎪🛹🛼🛶🎗️🎟️🎫🎖️🏆🏅🥇🥈🥉⚽⚾🥎🏀🏐🏈🏉🎾🥏🎳🏏🏑🏒🥍🏓🏸🥊🥋🥅⛳⛸️🎣🎽🎿🛷🥌🎯🎱🎮🎰🎲🧩♟️🎭🎨🧵🧶🎼🎤🎧🎷🪗🎸🎹🎺🎻🥁🎬🏹emoji 恐怖😈👿👹👺💀☠👻👽👾💣emoji 旅游👣🎠🎡🎢🚣🏔️⛰️🌋🗻🏕️🏖️🏜️🏝️🏞️🏟️🏛️🏗️🏘️🏚️🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🕌🛕🕍⛩🕋⛲⛺🌁🌃🏙️🌄🌅🌆🌇🌉🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🛻🚚🚛🚜🏎️🏍️🛵🛺🚲🛴🚏🛣️🛤️⛽🚨🚥🚦🚧⚓⛵🚤🛳️⛴️🛥️🚢✈️🛩️🛫🛬🪂💺🚁🚟🚠🚡🛰️🚀🛸🪐🌠🌌⛱️🎆🎇🎑💴💵💶💷🗿🛂🛃🛄🛅🧭emoji 物品💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨emoji 标志♠️♥️♦️♣️🃏🀄🎴🔇🔈🔉🔊📢📣📯🔔🔕🎵🎶💹🛗🏧🚮🚰♿🚹🚺🚻🚼🚾⚠️🚸⛔🚫🚳🚭🚯🚱🚷📵🔞☢️☣️⬆️↗️➡️↘️⬇️↙️⬅️↖️↕️↔️↩️↪️⤴️⤵️🔃🔄🔙🔚🔛🔜🔝🛐⚛️🕉️✡️☸️☯️✝️☦️☪️☮️🕎🔯♈♉♊♋♌♍♎♏♐♑♒♓⛎🔀🔁🔂▶️⏩⏭️⏯️◀️⏪⏮️🔼⏫🔽⏬⏸️⏹️⏺️⏏️🎦🔅🔆📶📳📴♀️♂️✖️➕➖➗♾️‼️⁉️❓❔❕❗〰️💱💲⚕️♻️⚜️🔱📛🔰⭕✅☑️✔️❌❎➰➿ 〽️✳️✴️❇️©️®️™️#️⃣*️⃣0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟🔠🔡🔢🔣🔤🅰️🆎🅱️🆑🆒🆓ℹ️🆔Ⓜ️🆕🆖🅾️🆗🅿️🆘🆙🆚🈁🈂️🈷️🈶🈯 🉐 🈹🈚🈲 🉑 🈸🈴🈳 ㊗️㊙️ 🈺🈵🔴🟠🟡🟢🔵🟣🟤⚫⚪🟥🟧🟨🟩🟦🟪🟫⬛⬜◼️◻️◾◽▪️▫️🔶🔷🔸🔹🔺🔻💠🔘🔳🔲🏁🚩🎌🏴🏳️🏳️‍🌈🏳️‍⚧️🏴‍☠️emoji 生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖emoji 星座♈♉♊♋♌♍♎♏♐♑♒♓⛎emoji 钟表🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰emoji 心形💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣emoji 花草💐🌸💮🏵️🌹🥀🌺🌻🌼🌷🌱🌿☘️🍀emoji 树叶🌿☘️🍀🍁🍂🍃emoji 月亮🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝emoji 水果🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🥝emoji 钱币💴💵💶💷💰💸💳emoji 交通🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀emoji 建筑🏟️🏛️🏗️🛖🏘️🏚️🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🕌🛕🕍⛩️🕋⛲⛺🌁🌃🏙️🌄🌅🌆🌇🌉emoji 办公📱📲☎️📞📟📠🔋🔌💻🖥️🖨️⌨️🖱️🖲️💽💾💿📀🧮🎥🎞️📽️📺📷📸📹📼🔍🔎🕯️💡🔦🏮🪔📔📕📖📗📘📙📚📓📒📃📜📄📰🗞️📑🔖🏷️💰🪙💴💵💶💷💸💳🧾✉️📧📨📩📤📥📦📫📪📬📭📮🗳️✏️✒️🖋️🖊️🖌️🖍️📝📁📂🗂️📅📆🗒️🗓️📇📈📉📊📋📌📍📎🖇️📏📐✂️🗃️🗄️🗑️🔒🔓🔏🔐🔑🗝️emoji 箭头⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝","categories":["💻Code"]},{"title":"AKKO3068说明书","path":"/posts/cd88/","content":"","tags":["⌨️键盘"]},{"title":"建站的\"心路历程\"","path":"/posts/fa1d/","content":"在听讲座，有点无聊，所以把昨天的感想写一写 太难了，踩过的坑都忘记了，这。。。。。。。 初衷建设这个网站的目的是为了记录自己学习过程、学习笔记，以便在未来能够复习、反思、回味。 另外这还是一个可以释放压力，可以倾述的平台没人会看我叨叨的，甚至还可以看看自己收藏的电影 起因这学期做了一个项目[课程设计]，是视觉识别和机械臂的综合，所以就想存到 GitHub 上面，偶遇到了 HEXO，第一个主题是 Keep，也实现了自动部署，后面换了Butterfly也就是现在的主题，非常不错 搭建、域名购买、域名解析搭建是参考的知乎找的教程，但还是踩了很多，这里不再赘述，推荐店长教程。 主题选择主题选择有很多，萝卜青菜各有所爱，这里就不讲了 主题魔改魔改必须推店长，yyds，教程直接去店里翻，不会做就去加群。 讲一讲我自己的魔改吧，首先我是不喜欢侧边栏的，虽然我开了，但是只是为了能有个目录，方便翻阅。魔改内容还是蛮多的，想到什么就讲什么吧！ butterfly 主题内置的就不再赘述了(pwa 快把我折磨死了) 先讲动效吧！ 加载动画是我自己魔改的，应该不会放出源码很简单的 动效(就是那些会动的)，置顶轮播，分类，标签外挂(文章里面比较好玩的东西)这些都是店长或者冰老师的插件点这 什么时候有空把源码放上来，需要请评论，没人会看的吧 服务器搭建、备案在国内建站，肯定是要备案的，还得买服务器一点都不合理，没办法，买三个月备份，肝!教程？教程是什么？ 百度一下，你就知道! 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 看教程要仔细，有些教程不全，那就去百度，或者干脆换一篇教程!耐心!仔细!认真![滑稽][菜狗]","tags":["📖Life"]},{"title":"Ubuntu常用命令及软件","path":"/posts/3qcul6d/","content":"Ubuntu常用命令系统自带12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# 关机sudo shutdown -h now# 我常用 shutdown now# 重启reboot# 查看当前路径pwd# 查看当前路径下的文件ls# 查看当前路径下的文件，包括隐藏文件ls -a# 查看当前路径下的文件，包括隐藏文件，详细信息ls -al# 列出文件的内容cat# 创建文件夹mkdir# 切换到目录cd# 删除文件rm# 删除文件夹及其子文件夹rm -rf# 移动或者重命名文件mv# 创建文件touch # 查找某个文件find find /home/ -name notes.txt# 进程查找ps -ef | grep python# 解压tar -zxvf xxx.tar.gz# 压缩tar -zcvf # 权限更改chmod# 注意 .ssh 文件夹权限为 700 rsa 文件权限为 600 chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsachmod 644 ~/.ssh/id_rsa.pub chmod 600 ~/.ssh/authorized_keys# 查看端口占用netstat -tunlp | grep 8080# 查看端口占用lsof -i:8080# 查看文件夹大小du -sh# 查看文件夹大小du -h --max-depth=1 v4l2-ctl1234567891011121314# 安装sudo apt-get install v4l-utils# 查看摄像头信息v4l2-ctl --list-devices# 查看摄像头支持的格式v4l2-ctl --list-formats-ext# 查看摄像头支持的分辨率v4l2-ctl --list-formats-ext --device=/dev/video0 常用脚本12345678910111213141516171819202122232425262728# 换源bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh)# ROS 安装 鱼香ROS # 一键安装:ROS(支持ROS和ROS2,树莓派Jetson) 贡献@小鱼 # 一键安装:VsCode(支持amd64和arm64) 贡献@小鱼 # 一键安装:github桌面版(小鱼常用的github客户端) 贡献@小鱼 # 一键安装:nodejs开发环境(通过nodejs可以预览小鱼官网噢 贡献@小鱼 # 一键配置:rosdep(小鱼的rosdepc,又快又好用) 贡献@小鱼 # 一键配置:ROS环境(快速更新ROS环境设置,自动生成环境选择) 贡献@小鱼 # 一键配置:系统源(更换系统源,支持全版本Ubuntu系统) 贡献@小鱼 # 一键安装:Docker(支持amd64和arm64) 贡献@alyssa # 一键安装:cartographer 贡献@小鱼&amp;Catalpa # 一键安装:微信客户端 贡献@小鱼wget http://fishros.com/install -O fishros &amp;&amp; . fishros# 一键更新 GitHub Hostsed -i &quot;/# GitHub520 Host Start/Q&quot; /etc/hosts &amp;&amp; curl https://raw.hellogithub.com/hosts &gt;&gt; /etc/hosts 常用软件旭日x3PI常用命令https://developer.horizon.ai/api/v1/fileData/doc/cn/common_doc_cn/xj3_board_command.html 12345678910hrut_boardid # 查看板子ID 相关hrut_bpuprofile # bpu 相关 hrut_mac # 查看mac地址 设置mac地址hrut_somstatus # 查看板子状态 温度 频率hrut_ddr # 设置 DDR Qos","tags":["Ubuntu"],"categories":["💻Code"]},{"title":"py tkinter 学习笔记","path":"/posts/e778/","content":"Python gui 设计之 Tkinter 学习笔记前言其实我之前有用过 QT 写 gui 比如这样 找这玩意花了一小会，很久之前的视觉作业，整体来说还是很方便的，但是 QT 打包起来会很大，不知道是因为 QT，还是因为 opencv，估计是后者，但是我还是想学一下这个 tkinter，至少了解一下，恰好在图书馆又看到了这本书 还有 csdn 的一个博主就下面这个的学习笔记，可以复制！！！所以我来了，有空 fork 一下，防止丢失。 注：本文代码部分来自敲代码的小风 这本书我之前想自学 Python 的时候看过电子版虽然看的不多，感觉还行作者洪锦魁 所以我来学习啦！！！！！！！ 第一章 这两行缺一不可，不知道为什么书上就写了一个，注释掉了另一个 红黄绿真是亮瞎眼，不知道还有没有其他颜色（可以使用 RGB，随便试试） 1234567891011121314151617181920212223242526272829303132333435363738&#x27;&#x27;&#x27;设置窗口的属性&#x27;&#x27;&#x27;from tkinter import *# import tkinterroot = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称root = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称root.title(&quot;!!!&quot;) # 窗口的标题root.geometry(&quot;300x160&quot;) # 窗口的大小root.configure(bg=&#x27;yellow&#x27;) # 窗口的背景颜色screenWidth = root.winfo_screenwidth() # 屏幕宽度screenHeight = root.winfo_screenheight() # 屏幕高度# print(&quot;# 屏幕宽度&quot;,screenWidth) # 屏幕宽度 1536# print(&quot;# 屏幕高度&quot;,screenHeight) # 屏幕高度 864root.iconbitmap(&quot;snake.ico&quot;) # 正常显示# root.iconphoto(False, PhotoImage(file=&#x27;1.png&#x27;)) # 可以正常显示png图片# root.iconphoto(False, PhotoImage(file=&#x27;1.jpg&#x27;)) # 程序报错： _tkinter.TclError: couldn&#x27;t recognize data in image file &quot;1.jpg&quot;w = 300 # 窗口宽h = 160 # 窗口高x = (screenWidth - w)/2 # 窗口左上角x轴位置y = (screenHeight - h)/2 # 窗口左上角y轴位置root.geometry(&quot;%dx%d+%d+%d&quot; % (w,h,x,y)) # 表示距离屏幕左上角(400,200)# +x表示窗口左侧距离屏幕左侧距离, -x表示窗口右侧距离屏幕右侧的距离# +y与-y的含义类似，窗口上侧(下侧)距离屏幕上侧(下侧)的距离root.mainloop() # 让程序继续运行，同时进入等待与处理窗口事件，放在程序最后一行 先去存一下文档，fork 一下 因为各种事耽误了 10 分钟，咕咕咕，有空改改caplos 明天今天展示一下我的 ansys 技能，可能已经忘干净了，[点这里](轴的简单 ANSYS 分析 | WXY_JOY (wxydejoy.top)) 第二章噔噔噔！！ 12345678910111213from tkinter import *root = Tk()root.title(&quot;ch2_1&quot;)label = Label(root,text=&quot;我喜欢使用tkinter！！！&quot;)label.pack() # 包装与定位组件print(type(label)) # &lt;class &#x27;tkinter.Label&#x27;&gt;#也可以用一行 #label = Label(root,text=&quot;我喜欢使用tkinter！！！&quot;).pack()&lt;class &#x27;NoneType&#x27;&gt;可能会引起后续错误#Label(root,text=&quot;我喜欢使用tkinter！！！&quot;).pack() &lt;class &#x27;type&#x27;&gt;所以最好还是分开#当然如果后面用不着了那就随便root.mainloop() 大概看了看，太困了 来了来了，按照目录学有点没动力，那就先找点事情，有目的的学 比如 给之前的那个 markdown 改格式的代码加个界面，go 1234567891011f = open(&#x27;main.txt&#x27;)lines = f.readlines()f.close()print(lines)for i in range(len(lines)): #lines[i] = &quot;![](&quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) + &#x27;)&#x27; + &#x27; &#x27; #lines[i] = &quot;- ![&quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) + &quot;](&quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) + &#x27;)&#x27; +&#x27; &#x27; lines[i] = &quot;- &quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) +&#x27; &#x27;f = open(&#x27;main.txt&#x27;,&#x27;w&#x27;)f.writelines(lines) 就是这个，一个很简单的代码 先改图标 不知道为什么就是改不成 最后搬来了珍藏的图标 首先需要几个文本 目标界面 到点了，改天再说来了来了，昨天睡觉，趁今天不怎么想学习写一会 这里要用到前几章的知识 Label, Button,Entry,还有窗口管理员 先来 Label 12345678label=Label(root,text=&quot;前缀&quot;,fg=&quot;black&quot;,bg=&quot;#FFEDDF&quot;)label.pack(anchor=N,side=LEFT,padx=10,pady=10)label=Label(root,text=&quot;后缀&quot;,fg=&quot;black&quot;,bg=&quot;#FFEDDF&quot;)label.pack(anchor=N,side=LEFT,padx=50,pady=10)label=Label(root,text=&quot;自动序号&quot;,fg=&quot;black&quot;,bg=&quot;#FFEDDF&quot;)label.pack(anchor=N,side=LEFT,padx=0,pady=10)label=Label(root,text=&quot;-wxy&quot;,fg=&quot;blue&quot;,bg=&quot;#FFEDDF&quot;)label.pack(side=BOTTOM,padx=10,pady=10) 其实有点不很懂，但先这样 然后加入按钮和文本框 到这里，界面基本完成 下面才是重点 1234567def get_url(): urlformer = former.get() urllatter = latter.get() url = main.get(1.0,END) md = urlformer + url.replace(&#x27; &#x27;,&#x27;&#x27;) + urllatter main.delete(1.0,END) main.insert(END,md) 不是很熟悉这些函数，所以搞得有点慢，这书也不好用，东西不给全，还是靠百度 多行 自动排序 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# import tkinterfrom tkinter import *root = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称root.title(&quot;url-md&quot;)root.config(bg=&#x27;#FFEDDF&#x27;)root.iconbitmap(&quot;hhh.ico&quot;) # 不知道为什么，png和bmp无法显示，或许是我图片问题，但就先这样吧def mwindow(): screenWidth = root.winfo_screenwidth() # 屏幕宽度 screenHeight = root.winfo_screenheight() # 屏幕高度 w = 300 # 窗口宽 h = 160 # 窗口高 x = (screenWidth - w) / 2 # 窗口左上角x轴位置 y = (screenHeight - h) / 2 # 窗口左上角y轴位置 root.geometry(&quot;%dx%d+%d+%d&quot; % (w, h, x, y)) # 表示距离屏幕左上角(400,200) # +x表示窗口左侧距离屏幕左侧距离, -x表示窗口右侧距离屏幕右侧的距离 # +y与-y的含义类似，窗口上侧(下侧)距离屏幕上侧(下侧)的距离 # 练习改函数def windowset(): # label = Label(root,text=&quot;前缀&quot;) # label.pack() label = Label(root, text=&quot;前缀&quot;, fg=&quot;black&quot;, bg=&quot;#FFEDDF&quot;) label.pack(anchor=N, side=LEFT, padx=10, pady=10) label = Label(root, text=&quot;后缀&quot;, fg=&quot;black&quot;, bg=&quot;#FFEDDF&quot;) label.pack(anchor=N, side=LEFT, padx=50, pady=10) label = Label(root, text=&quot;自动序号&quot;, fg=&quot;black&quot;, bg=&quot;#FFEDDF&quot;) label.pack(anchor=N, side=LEFT, padx=0, pady=10) label = Label(root, text=&quot;-wxy&quot;, fg=&quot;blue&quot;, bg=&quot;#FFEDDF&quot;) label.pack(side=BOTTOM, padx=10, pady=10) btn = Button(root, padx=0, pady=0, bd=2,relief=GROOVE, bg=&quot;white&quot;, text=&quot;转换&quot;, command=get_url) # btn.pack(side=BOTTOM,padx=10,pady=10) btn.place(x=130, y=120) global former, latter, main,var former = Entry(root,width=6,bd=2,relief=GROOVE) latter = Entry(root,width=6,bd=2,relief=GROOVE) main = Text(root,width=6,bd=2,relief=GROOVE) former.place(x=45,y=10) latter.place(x=133, y=10) main.place(x=50,y=40,width=200,height=60) var =IntVar() select = Checkbutton(root,bg=&quot;#FFEDDF&quot;,variable=var) select.place(x=230,y=8) root.mainloop() # 让程序继续运行，同时进入等待与处理窗口事件，放在程序最后一行1def get_url(): urlformer = former.get() urllatter = latter.get() url = main.get(1.0,END) if url[-2] == &#x27; &#x27;: url = url[0:-1] # 这里有点迷 md = &#x27;&#x27; if var.get() == 0: md = urlformer + url.replace(&#x27; &#x27;, urllatter + &#x27; &#x27; + urlformer) l = len(urlformer) main.delete(1.0, END) main.insert(END, md[0:-l]) else: md = urlformer + url.replace(&#x27; &#x27;, urllatter + &#x27; &#x27; + urlformer) ran = md.count(&#x27;$&#x27;) for i in range(ran): md = md.replace(&#x27;$&#x27;,str(i),1) l = len(urlformer) main.delete(1.0, END) main.insert(END, md[0:-l])mwindow()windowset() 完成 123完成","tags":["📄Python","💻Gui","💻Tkinter"],"categories":["💻Code"]},{"title":"你并不是一无所有","path":"/posts/289b/","content":"","categories":["🔖Life"]},{"title":"python + QT + 📄 Opencv 学习笔记","path":"/posts/d364/","content":"部分功能展示这是视觉识别课程做的一个小软件 主要功能：通过 opencv 模块识别物体中心坐标，计算物体姿态角度，计算叶子面积和形心，支持文件上传识别以及摄像头采集。 目前已开源，GitHub 仓库here 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390import sysimport cv2import mathimport numpy as npfrom PyQt5 import QtCore, QtGui, QtWidgetsfrom PyQt5.QtCore import *from PyQt5.QtGui import *from PyQt5.QtWidgets import QFileDialog, QMainWindowfrom untitled import Ui_MainWindowfrom PyQt5 import QtCore, QtGui, QtWidgets#UIclass Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(&quot;MainWindow&quot;) MainWindow.resize(1125, 595) self.centralwidget = QtWidgets.QWidget(MainWindow) self.centralwidget.setObjectName(&quot;centralwidget&quot;) self.labelCamera = QtWidgets.QLabel(self.centralwidget) self.labelCamera.setGeometry(QtCore.QRect(0, 0, 200, 200)) self.labelCamera.setObjectName(&quot;labelCamera&quot;) self.labelCapture = QtWidgets.QLabel(self.centralwidget) self.labelCapture.setGeometry(QtCore.QRect(200, 0, 400, 400)) self.labelCapture.setObjectName(&quot;labelCapture&quot;) self.btnOpenCamera = QtWidgets.QPushButton(self.centralwidget) self.btnOpenCamera.setGeometry(QtCore.QRect(80, 490, 75, 23)) self.btnOpenCamera.setObjectName(&quot;btnOpenCamera&quot;) self.btnCapture = QtWidgets.QPushButton(self.centralwidget) self.btnCapture.setGeometry(QtCore.QRect(200, 490, 75, 23)) self.btnCapture.setObjectName(&quot;btnCapture&quot;) self.btnReadImage= QtWidgets.QPushButton(self.centralwidget) self.btnReadImage.setGeometry(QtCore.QRect(330, 490, 75, 23)) self.btnReadImage.setObjectName(&quot;btnReadImage &quot;&quot;&quot;) self.btnGray = QtWidgets.QPushButton(self.centralwidget) self.btnGray.setGeometry(QtCore.QRect(460, 490, 75, 23)) self.btnGray.setObjectName(&quot;btnGray&quot;) self.btnThreshold = QtWidgets.QPushButton(self.centralwidget) self.btnThreshold.setGeometry(QtCore.QRect(570, 490, 75, 23)) self.btnThreshold.setObjectName(&quot;btnThreshold&quot;) self.labelResult = QtWidgets.QLabel(self.centralwidget) self.labelResult.setGeometry(QtCore.QRect(600, 0, 400, 400)) self.labelResult.setObjectName(&quot;labelResult&quot;) self.btnCalculate = QtWidgets.QPushButton(self.centralwidget) self.btnCalculate.setGeometry(QtCore.QRect(680, 490, 75, 23)) self.btnCalculate.setObjectName(&quot;btnCalculate&quot;) self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget) self.textBrowser.setGeometry(QtCore.QRect(20, 420, 131, 31)) self.textBrowser.setObjectName(&quot;textBrowser&quot;) self.btnRectangle = QtWidgets.QPushButton(self.centralwidget) self.btnRectangle.setGeometry(QtCore.QRect(870, 490, 75, 23)) self.btnRectangle.setObjectName(&quot;btnRectangle&quot;) self.btnDenoise = QtWidgets.QPushButton(self.centralwidget) self.btnDenoise.setGeometry(QtCore.QRect(770, 490, 75, 23)) self.btnDenoise.setObjectName(&quot;btnDenoise&quot;) self.lineEdit = QtWidgets.QLineEdit(self.centralwidget) self.lineEdit.setGeometry(QtCore.QRect(20, 380, 113, 20)) self.lineEdit.setObjectName(&quot;lineEdit&quot;) MainWindow.setCentralWidget(self.centralwidget) self.statusbar = QtWidgets.QStatusBar(MainWindow) self.statusbar.setObjectName(&quot;statusbar&quot;) MainWindow.setStatusBar(self.statusbar) self.retranslateUi(MainWindow) self.btnOpenCamera.clicked.connect(MainWindow.btnOpenCamera_Clicked) self.btnCapture.clicked.connect(MainWindow.btnCapture_Clicked) self.btnReadImage.clicked.connect(MainWindow.btnReadImage_Clicked) self.btnGray.clicked.connect(MainWindow.btnGray_Clicked) self.btnThreshold.clicked.connect(MainWindow.btnThreshold_Clicked) self.btnCalculate.clicked.connect(MainWindow.btnCalculate_Clicked) self.btnDenoise.clicked.connect(MainWindow.btnDenoise_Clicked) self.btnRectangle.clicked.connect(MainWindow.btnRectangle_Clicked) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;)) self.labelCamera.setText(_translate(&quot;MainWindow&quot;, &quot;摄像头&quot;)) self.labelCapture.setText(_translate(&quot;MainWindow&quot;, &quot;捕获图&quot;)) self.btnOpenCamera.setText(_translate(&quot;MainWindow&quot;, &quot;摄像头&quot;)) self.btnCapture.setText(_translate(&quot;MainWindow&quot;, &quot;捕获图片&quot;)) self.btnReadImage.setText(_translate(&quot;MainWindow&quot;, &quot;打开图片&quot;)) self.btnGray.setText(_translate(&quot;MainWindow&quot;, &quot;灰度化&quot;)) self.btnThreshold.setText(_translate(&quot;MainWindow&quot;, &quot;阈值分割&quot;)) self.labelResult.setText(_translate(&quot;MainWindow&quot;, &quot;结果图&quot;)) self.btnCalculate.setText(_translate(&quot;MainWindow&quot;, &quot;绿叶形心&quot;)) self.btnRectangle.setText(_translate(&quot;MainWindow&quot;, &quot;计算面积&quot;)) self.btnDenoise.setText(_translate(&quot;MainWindow&quot;, &quot;方块角度&quot;))class PyQtMainEntry(QMainWindow, Ui_MainWindow): def __init__(self): super().__init__() self.setupUi(self) self.camera = cv2.VideoCapture(0) self.is_camera_opened = False # 摄像头有没有打开标记 # 定时器：30ms捕获一帧 self._timer = QtCore.QTimer(self) self._timer.timeout.connect(self._queryFrame) self._timer.setInterval(30) def btnOpenCamera_Clicked(self): &#x27;&#x27;&#x27; 打开和关闭摄像头 &#x27;&#x27;&#x27; self.is_camera_opened = ~self.is_camera_opened if self.is_camera_opened: self.btnOpenCamera.setText(&quot;关闭摄像头&quot;) self._timer.start() else: self.btnOpenCamera.setText(&quot;打开摄像头&quot;) self._timer.stop() def btnCapture_Clicked(self): &#x27;&#x27;&#x27; 捕获图片 &#x27;&#x27;&#x27; # 摄像头未打开，不执行任何操作 if not self.is_camera_opened: return self.captured = self.frame # 后面这几行代码几乎都一样，可以尝试封装成一个函数 rows, cols, channels = self.captured.shape bytesPerLine = channels * cols # Qt显示图片时，需要先转换成QImgage类型 QImg = QImage(self.captured.data, cols, rows, bytesPerLine, QImage.Format_RGB888) self.labelCapture.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelCapture.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnReadImage_Clicked(self): &#x27;&#x27;&#x27; 从本地读取图片 文件路径不能有中文 &#x27;&#x27;&#x27; # 打开文件选取对话框 filename, _ = QFileDialog.getOpenFileName(self, &#x27;打开图片&#x27;) if filename: self.captured = cv2.imread(str(filename)) self.frame = cv2.imread(str(filename)) # OpenCV图像以BGR通道存储，显示时需要从BGR转到RGB self.captured = cv2.cvtColor(self.captured, cv2.COLOR_BGR2RGB) rows, cols, channels = self.captured.shape bytesPerLine = channels * cols QImg = QImage(self.captured.data, cols, rows, bytesPerLine, QImage.Format_RGB888) self.labelCapture.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelCapture.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnGray_Clicked(self): &#x27;&#x27;&#x27; 灰度化 &#x27;&#x27;&#x27; # 如果没有捕获图片，则不执行操作 if not hasattr(self, &quot;captured&quot;): return self.cpatured = cv2.cvtColor(self.captured, cv2.COLOR_RGB2GRAY) rows, columns = self.cpatured.shape bytesPerLine = columns # 灰度图是单通道，所以需要用Format_Indexed8 QImg = QImage(self.cpatured.data, columns, rows, bytesPerLine, QImage.Format_Indexed8) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnThreshold_Clicked(self): &#x27;&#x27;&#x27; Otsu自动阈值分割 &#x27;&#x27;&#x27; #self.textBrowser.setText(&quot;dadad&quot;) if not hasattr(self, &quot;captured&quot;): return _, self.cpatured = cv2.threshold( self.cpatured, 0, 250, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) rows, columns = self.cpatured.shape bytesPerLine = columns # 阈值分割图也是单通道，也需要用Format_Indexed8 QImg = QImage(self.cpatured.data, columns, rows, bytesPerLine, QImage.Format_Indexed8) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) #self.wxy.setText(&quot;%d&quot;, 11) def btnRectangle_Clicked(self): img = self.frame m=0 n=0 for i in range(1, img.shape[0]): for j in range(1, img.shape[1]): # b = 2*img.item(i, j, 1) - img.item(i, j, 0) - img.item(i, j, 2) a = 5 if (img.item(i, j, 0) &gt; 40) and (img.item(i, j,0) &lt; 70 ) and (img.item(i, j, 1) &gt; 40) and (img.item(i, j,1) &lt; 70 ) and (img.item(i, j, 2) &gt; 40) and (img.item(i, j,2) &lt; 70 ) : for k in range(0, 3): img.itemset((i, j, k), 0) n = n + 1 if (img.item(i, j, 1) - img.item(i, j, 0) &gt; a) and (img.item(i, j, 1) - img.item(i, j, 2) &gt; a): for k in range(0, 3): img.itemset((i, j, k), 0) m = m + 1 else: for k in range(0, 3): img.itemset((i, j, k), 255) s = m/n*25 self.lineEdit.setText(&quot;%s&quot; % s ) img = cv2.blur(img, (3, 3)) img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) img = cv2.medianBlur(img, 5) img = cv2.blur(img, (3, 3)) ret, img = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) img = cv2.bilateralFilter(img, 5, 75, 75) img = cv2.medianBlur(img, 5) img = cv2.Canny(img, 100, 200) img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) self.frame = img img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnDenoise_Clicked(self): img = self.frame img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) a = 0 b = 0 for i in range(1, len(contours)): cnt = contours[i] M = cv2.moments(cnt) c = int(M[&#x27;m00&#x27;]) if c &gt; a: a = c b = i cv2.drawContours(img, contours, b, (0, 0, 255), 3) cnt = contours[b] M = cv2.moments(cnt) cx = int(M[&#x27;m10&#x27;] / M[&#x27;m00&#x27;]) cy = int(M[&#x27;m01&#x27;] / M[&#x27;m00&#x27;]) cv2.circle(img, (cx, cy), 2, (0, 255, 0), -1) (x, y), (MA, ma), angle = cv2.fitEllipse(cnt) leftmost = tuple(cnt[cnt[:, :, 0].argmin()][0]) rightmost = tuple(cnt[cnt[:, :, 0].argmax()][0]) topmost = tuple(cnt[cnt[:, :, 1].argmin()][0]) bottommost = tuple(cnt[cnt[:, :, 1].argmax()][0]) cv2.circle(img, (leftmost[0], leftmost[1]), 2, (0, 255, 0), -1) cv2.circle(img, (rightmost[0], rightmost[1]), 2, (0, 255, 0), -1) dy = rightmost[1]-leftmost[1] dx = rightmost[0]-leftmost[0] temp = math.sqrt(dx * dx + dy * dy) angle_cos = dx / temp; angle = math.acos(angle_cos) * 180 / 3.14 if dy &lt; 0: angle = -angle self.lineEdit.setText(&quot;%s&quot; % angle) img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) &#x27;&#x27;&#x27; a = 1 img = self.frame img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) #a = self.lineEdit.text() #self.textBrowser.setText(a) lower_blue = np.array([110,50,50]) upper_blue = np.array([130,255,255]) img = cv2.inRange(img, lower_blue, upper_blue) #self.textBrowser.setText(&quot;%d,%d,a&quot; % a/1000 % a) #a = self.textBrowser.text() # 提取颜色 #img = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # ret,thresh = cv.threshold(gray,255,255,60) # ret,thresh1 = cv.threshold(gray,127,255,cv.THRESH_BINARY) img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) #den = cv2.fastNlMeansDenoisingColor(img, None, 10, 10, 7, 21) #img_rows, img_cols, channels = denoise.shape #bytesPerLine = channels * img_cols #QImg = QImage(denoise.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) #self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( # self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) &#x27;&#x27;&#x27; @QtCore.pyqtSlot() def _queryFrame(self): &#x27;&#x27;&#x27; 循环捕获图片 &#x27;&#x27;&#x27; ret, self.frame = self.camera.read() img_rows, img_cols, channels = self.frame.shape bytesPerLine = channels * img_cols cv2.cvtColor(self.frame, cv2.COLOR_BGR2RGB, self.frame) QImg = QImage(self.frame.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelCamera.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelCamera.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnCalculate_Clicked(self): img = self.frame m = 0 for i in range(1, img.shape[0]): for j in range(1, img.shape[1]): # b = 2*img.item(i, j, 1) - img.item(i, j, 0) - img.item(i, j, 2) a = 5 #绿色bgr if (img.item(i, j, 1) - img.item(i, j, 0) &gt; a) and (img.item(i, j, 1) - img.item(i, j, 2) &gt; a): for k in range(0, 3): img.itemset((i, j, k), 0) m = m + 1 else: for k in range(0, 3): img.itemset((i, j, k), 255) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) #a = max(contours) area = [] a = 0 b = 0 for i in range(1,len(contours)): cnt = contours[i] M = cv2.moments(cnt) c = int(M[&#x27;m00&#x27;]) if c &gt; a: a = c b = i cv2.drawContours(img, contours, b, (0, 0, 255), 3) cnt = contours[b] M = cv2.moments(cnt) cx = int(M[&#x27;m10&#x27;] / M[&#x27;m00&#x27;]) cy = int(M[&#x27;m01&#x27;] / M[&#x27;m00&#x27;]) cv2.circle(img,(cx,cy), 2, (0,255,0), -1) (x, y), (MA, ma), angle = cv2.fitEllipse(cnt) self.lineEdit.setText(&quot;%s&quot; % angle) img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))if __name__ == &quot;__main__&quot;: app = QtWidgets.QApplication(sys.argv) window = PyQtMainEntry() window.show() sys.exit(app.exec_())","tags":["⌨️Qt","📄Python","📄Opencv"],"categories":["💻Code"]},{"title":"Fluent Search","path":"/posts/d0da/","content":"ttddww 顶顶顶 zai%%% tip home %%%-可能是第一次正儿八经的的测一款软件，说是测，其实是把官网翻译一下，然后再讲讲自己的使用感受。很多内容都是搬运自官网。侵删！ 另外，虽然这个软件有github，但只是用来反馈问题，闭源，但免费。 另外，无中文。Ces %%% endtip %%%- %%% p center logo large, Fluent Search %%%- With Fluent Search, you can search for running apps, browser tabs, in-app content, files and more. Available for Windows 10&#x2F;11 only.不会吧不会吧，不会有人还没换win10吧 微软商店链接点这 Fluent 搜索功能指南使用 Fluent Search，您可以立即搜索计算机上可用的各种资源并访问它们。Fluent Search 有很多功能，在本指南中，我们将介绍一些主要功能。 进程搜索听起来，进程搜索可让您轻松找到计算机上的任何活动进程。 进程是具有窗口的活动应用程序，您可以通过搜索窗口标题或进程名称来找到它。 此外，Fluent Search 可以在进程内找到应用内元素，例如选项卡、按钮和超链接，以立即访问它们。 屏幕搜索有些人发现使用鼠标会降低工作效率，尤其是在编程等非常面向键盘的工作中。 如果您是这些人中的一员，Fluent Search 可以满足您的需求。屏幕搜索功能可让您使用键盘轻松控制计算机。 搜索标签如上所述，Fluent Search 会搜索您计算机中的各种资源，包括但不限于 - 文件、应用程序、进程、书签、历史结果等。 为了帮助您轻松获得最相关的结果，Fluent Search 提供了一项名为”搜索标签”的功能。 Fluent Search 中的每个结果可能包含多个描述此结果的标签，使用这些标签您可以轻松过滤您的搜索以找到最相关的结果。 网络搜索是否需要立即搜索网络而无需打开浏览器并创建新标签？ 然后你明白了，使用 Fluent Search，你可以轻松地在你最喜欢的搜索引擎中进行搜索。 自定义Fluent Search 的构建考虑到了现代设计，但最重要的是能够让您自定义它。 你喜欢简约风格吗？您想在屏幕上获得尽可能多的信息吗？Fluent Search 助您一臂之力。您可以根据需要轻松缩放搜索窗口并更改其外观。 导航简单性是 Fluent Search 非常重要的方面。 在提供丰富的搜索结果的同时尽量保持简单是 Fluent Search 的一个持续挑战。 我的介绍最小外观 外观是那种磨砂透明玻璃的感觉，非常不错。 设置界面 写不动了，再说吧�","tags":["💻Software"],"categories":["💻Software"]},{"title":"404","path":"/404.html","content":"您访问的页面已经丢失访问原站访问镜像站"},{"path":"/css/font.css","content":"@font-face{ font-family:'lxk' ; /* 字体名自定义即可 */ src:url('/fontdest/李旭科书法1.4.ttf'); /* 字体文件路径 */ font-display : swap; } body{ font-family: 'lxk'; }"},{"path":"/css/mtime.css","content":".mtime-movie_card { font-family: 'Montserrat', helvetica, arial, sans-serif; font-size: 14px; font-weight: 400; font-weight: 400; position: relative; display: block; width: 100%; box-sizing: border-box; margin: 30px auto; overflow: hidden; border-radius: 10px; transition: all 0.4s; box-shadow: 0px 0px 120px -25px rgba(0, 0, 0, 0.5); } .mtime-movie_card:hover { -webkit-transform: scale(1.02); transform: scale(1.02); box-shadow: 0px 0px 80px -25px rgba(0, 0, 0, 0.5); transition: all 0.4s; } .mtime-movie_card .mtime-info_section { position: relative; width: 100%; height: 100%; background-blend-mode: multiply; z-index: 2; border-radius: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header { position: relative; padding: 25px; height: 40%; } .mtime-movie_card .mtime-info_section .mtime-movie_header h1 { color: black; font-weight: 400; margin: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header h4 { color: #555; font-weight: 400; margin: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header .mtime-minutes { display: inline-block; margin-top: 5px; color: #555; padding: 5px; border-radius: 5px; border: 1px solid rgba(0, 0, 0, 0.05); } .mtime-movie_card .mtime-info_section .mtime-movie_header .mtime-type { display: inline-block; color: #959595; margin-left: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header .mtime-locandina { position: relative; float: left; margin-right: 20px; height: 170px; box-shadow: 0 0 20px -10px rgba(0, 0, 0, 0.5); } .mtime-name{ font-size: 25px; font-weight: 600; } .mtime-movie_card .mtime-info_section .mtime-movie_desc { padding: 0 25px 15px 25px; height: 100%; } .mtime-movie_card .mtime-info_section .mtime-movie_desc .mtime-text { color: #545454; } .mtime-movie_card .mtime-blur_back { position: absolute; top: 0; z-index: 1; height: 100%; right: 0; background-size: cover; border-radius: 11px; } @media screen and (min-width: 768px) { .mtime-movie_header { width: 65%; } .mtime-movie_desc { width: 50%; } .mtime-info_section { background: linear-gradient(to right, #e5e6e6 50%, transparent 80%); } .mtime-blur_back { width: 50%; background-position: -100% 10% !important; } } @media screen and (max-width: 768px) { .mtime-movie_card { width: 95%; margin: 70px auto; min-height: 350px; height: auto; } .mtime-blur_back { width: 100%; background-position: 50% 50% !important; } .mtime-movie_header { width: 100%; margin-top: 50px; } .mtime-movie_desc { padding: 0 5% !important; width: 90%; } .mtime-info_section { background: linear-gradient(to top, #e5e6e6 50%, transparent 100%); display: inline-grid; } }"},{"path":"/css/my.css","content":"/* 微博边框 */ #start>aside>div>div.widgets>widget.widget-wrapper.timeline>div.widget-body.fs14>div>div>div.body>a { border: none; } /* 微博点赞 */ #start>aside>div>div.widgets>widget.widget-wrapper.timeline>div.widget-body.fs14>div>div>div.body>div.footer { display: none; } .widget-wrapper.timeline .tag-plugin.timeline .timenode .body .justified-gallery .body { display: none; } /* 图片圆角 */ .tag-plugin.timeline[api] .body a img { border-radius: 10px; } #main > div.post-list.post > a > div > div > div{ display: none; }"},{"title":"Filecodebox","path":"/file/index.html","content":"Filecodebox网上采集的一些站点,临时使用,不定期更新,配合js脚本进行验证 js脚本:验证网站列表是否可用,并输出可用的网站列表 这是一个用来检测网址是否可访问的 JavaScript 代码片段：这是一个用来检测网址是否可访问的 JavaScript 代码片段： 检测 const urls = ['https://www.googddle.com', 'https://www.baidddu.com', 'https://www.giddthub.com']; const proxyUrl = 'https://green-dew-5e83.wxydejoy.workers.dev/'; async function checkUrl(url) { try { const response = await fetch(proxyUrl + url); return response.ok; } catch (error) { return false; } } async function checkUrls() { const resultDiv = document.getElementById('result'); resultDiv.innerHTML = '正在检测，请稍候...'; const results = await Promise.all(urls.map(url => checkUrl(url))); const table = '网址状态' + results.map((result, index) => `${urls[index]}${result ? '可访问' : '不可访问'}`).join('') + ''; resultDiv.innerHTML = table; }"},{"path":"/file/x.html","content":"Website Checker Website Checker Check function checkWebsite(url) { return new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload = () => { if (xhr.status === 200) { resolve(true); } else { resolve(false); } }; xhr.onerror = () => reject(new Error('Failed to load website.')); xhr.send(); }); } async function checkWebsiteWithProxy(url) { const proxyUrl = 'https://green-dew-5e83.wxydejoy.workers.dev/'; const apiUrl = proxyUrl + url; try { const response = await fetch(apiUrl); if (response.ok) { return true; } else { return false; } } catch (error) { throw new Error('Failed to load website.'); } } // 使用示例 checkWebsiteWithProxy('https://www.ulaz.cn/') .then((result) => { if (result) { console.log('Website is accessible.'); } else { console.log('Website is not accessible.'); } }) .catch((error) => console.error(error)); const urlInput = document.getElementById('url-input'); const checkButton = document.getElementById('check-button'); const resultText = document.getElementById('result-text'); checkButton.addEventListener('click', () => { const url = urlInput.value; checkWebsitew(url) .then((result) => { if (result) { resultText.innerText = 'Website is accessible.'; } else { resultText.innerText = 'Website is not accessible.'; } }) .catch((error) => console.error(error)); });"},{"path":"/file/x.js","content":"// 验证网址是否可以访问 function isUrlAvailable(url) { var xhr = new XMLHttpRequest(); xhr.open('HEAD', url, false); xhr.send(); return xhr.status == 200; } // 如果网站可以访问,文字背景变绿 function checkUrl() { var url = document.getElementById(\"url\").value; if (isUrlAvailable(url)) { document.getElementById(\"url\").style.backgroundColor = \"green\"; } else { document.getElementById(\"url\").style.backgroundColor = \"red\"; } } // 对列表中的网址进行验证 function checkUrls() { // 获取网址列表 var result = \"\"; for (var i = 0; i < urls.length; i++) { if (isUrlAvailable(urls[i])) { result += urls[i] + \" is available\"; } else { result += urls[i] + \" is not available\"; } } document.getElementById(\"result\").value = result; }"},{"path":"/fontdest/MiSans-Regular.css","content":"@font-face { font-family: \"MiSans\"; src: url(\"MiSans-Regular.eot\"); /* IE9 */ src: url(\"MiSans-Regular.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */ url(\"MiSans-Regular.woff2\") format(\"woff2\"), /* chrome 36+, firefox 39+,iOS 10+, Android 67+ */ url(\"MiSans-Regular.woff\") format(\"woff\"), /* chrome, firefox */ url(\"MiSans-Regular.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url(\"MiSans-Regular.svg#MiSans\") format(\"svg\"); /* iOS 4.1- */ font-style: normal; font-weight: normal; }"},{"title":"friend","path":"/friend/index.html","content":"申请要求：文章数量大于 10 篇 &amp;&amp; 建站时间大于 6 个月 1234- name: 沐印小站; url: https://undf.top; avatar: https://c.undf.top/icon/android-chrome-144x144.png; desc: 时间不在于你拥有多少，而在于你如何使用! 葱苓sama思宁HEREEurkon贰猹的小窝Android杜老师说VianXin's BlogL1nSn0w’s Blog木木木木木圣奇宝枣UyoAhz"},{"title":"life","path":"/life/index.html","content":"9.1 whj 显示器 1080-&gt;2k-&gt;1080 2022.9 下载地址 new"},{"title":"淘宝购物车生成word","path":"/life/淘宝购物车生成word.html","content":"效果预览 前置条件 你的浏览器安装了油猴插件 准备好我写的小软件 下载地址密码:9if6 使用步骤 打开软件 单击小软件中的油猴脚本按钮，会打开一个浏览器窗口 在弹出的浏览器窗口中单击安装此脚本进行安装，此时会弹出窗口再次点击安装 打开淘宝购物车页面 勾选需要购买的商品 单击浏览器右上角Get Cart Info按钮，数据会自动写入到剪切板 回到小软件，单击获取剪切板内容按钮，即可在程序所在目录生成word文件 大概率会遇到无法获取到图片（淘宝反爬虫）,请手动补充"},{"title":"more","path":"/more/index.html","content":"动态周记 fetch('https://cdn.undf.top/weekly/weekly.md') .then(response => response.text()) .then(data => { var element = document.getElementById(\"myUniqueID\"); data = data.replace(/### (.*$)/gim, '$1'); data = data.replace(/## (.*$)/gim, '$1'); data = data.replace(/# (.*$)/gim, '$1'); // --- data = data.replace(/---/g, ''); // 将 --- 替换为 element.innerHTML = data; });"},{"title":"Movies","path":"/movies/index.html","content":"周一 从红月开始周二 吞噬星空-炼气十万年周三周四 神印王座-近战法师周五 完美世界-恶魔法则周六 炼气十万年-大王饶命周日 仙王"},{"title":"server","path":"/server/index.html","content":""},{"title":"Toys","path":"/toys/index.html","content":"这些年来做的小玩具、小项目，也是一个回忆录。 又拍云数据备份 将又拍云存储的数据下载到本地，并且上传到一个新的存储空间内。 为保证数据完整，禁止删除任意文件。 支持同步 upyun 详情见站内文章 NPM自动化工具 Feature npm 图床自动化 自动更新npm包版本 自动获取最新npm包版本并替换文件中的jsd链接 自动推送图床仓库 只需配置一次 配置文件config.ini可修改 后续有时间再去加功能 自动喷淋系统上位机2021.11 MFC 视频里的程序就是我写的啦 当然还要感谢指导老师的帮助。 还有我画的PCB，很丑，能用就行系列~~~能不能用也不好说~~~。 自动布线，比较杂乱。 折腾服务器2021.11 双11买了三年服务器 这两个项目我只是搭建并没有进行任何修改。 code - server线上编辑器（可以跑程序的） qq机器人玩一下，很开心 学什么？MFC 2021.9写的，解决选择困难症 代码很简单，但很实用。 下载链接 2.0 是在1.0的基础上增加更多内容，但因为后来用不上就没有继续开发 2021.10 吃什么，学什么 这是一个网页，也是为了解决选择困难症 第二个个人网站2021.9也就是现在这个了，换了域名，改了主题。 简单 大方 我的主页2021.8 主页 很显然，不是我原创，是在巨人的肩膀上自己修改的。做了移动端适配，虽然还有bug但问题不大 url - md2021.7 python tkinter 文本 小工具 发在了52 还被列成置顶，也是没想到，非常开心。 52 仓库 快乐星球2021.3-2021.8 搭建的第一个网站&#x2F;博客 5.0 5.0 就是分站的样子啦！ 4.0 开始搞玻璃效果，确实好看。背景也不错。 而且还折腾出来了自动打开侧边栏效果。 挺费劲的 3.0 这个版本应该是比较好看的，而且也很简洁 动效该在的也在，这好像是7月底的版本 还有罗小黑，安装方法见这篇文章 2.0 开始自己折腾加载动画，还有冰球背景 1.02021.3-2021.7 发布的第一个release 那会刚开始折腾，网站还是很简洁的。 平面三轴机械臂视觉识别课程设计 视觉识别部分 平面机械臂模拟 2021.5 Feature： 根据坐标及姿态计算物块位置和合适的抓取角度 通过opencv模块进行视觉识别，计算物块的四个端点及其偏转角度 通过计算对应颜色像素点的数量计算叶片面积 支持摄像头拍摄图片和文件导入 DIY2021.3 自己比较满意的作品 图片没了。。。 大概就是把一个平面无线充电改成立式的，支持横竖放置 原材料： 小米平面无线充电器 一次性筷子 502"},{"title":"闲言碎语","path":"/xy/index.html","content":"留言 window.onload = function () { var xhr = new XMLHttpRequest(); xhr.open(\"get\", \"https://api.undf.top/api/xysy/api/getdata/\", true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) { var data = xhr.responseText; var dataObj = JSON.parse(data); var htmlStr = \"\"; for (var i = 0; i < dataObj.length; i++) { if ( dataObj[i].value.indexOf(\"http\") != -1 && (dataObj[i].value.indexOf(\".png\") != -1 || dataObj[i].value.indexOf(\".jpg\") != -1) ) { htmlStr += \"\" + dataObj[i].time + \"\"; } else { htmlStr += \"\" + dataObj[i].time + \"\" + dataObj[i].value + \"\"; } } document.getElementById(\"comments-list\").innerHTML = htmlStr; } } } hace 20 minutos 加载中请稍后..."},{"title":"闲言碎语","path":"/xy/indexx.html","content":"Click Me /* 设置全局样式 */ * { box-sizing: border-box; margin: 0; padding: 0; } /* 设置居中样式 */ .container { display: flex; justify-content: center; align-items: center; height: 30vh; background-image: url(\"https://img.undf.top/rand/3.png!max\"); background-size: cover; background-position: center; border-radius: 15px; } /* 设置表单样式 */ .form { display: flex; flex-direction: column; align-items: center; background-color: rgba(255, 255, 255, 0.8); width: 40%; padding: 20px; border-radius: 5px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); } /* 设置输入框样式 */ .form input[type=\"textt\"] { padding: 10px; width: 100%; margin-bottom: 10px; border-radius: 5px; border: none; background-color: #fff; box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1); } /* 设置按钮样式 */ .form button { padding: 10px 20px; background-color: #2196f3; color: #fff; border-radius: 5px; border: none; cursor: pointer; font-size: 16px; } /* 设置响应式样式 */ @media only screen and (max-width: 600px) { .form { width: 90%; } } // 监听按钮的点击事件 // 获取输入框的内容 // 根据输入的内容发送请求 // 获取响应 // 显示响 // 1. 监听按钮的点击事件 var button = document.querySelector('button'); button.addEventListener('click', function () { // 2. 获取输入框的内容 var input = document.querySelector('input'); var name = input.value; // 3. 根据输入的内容发送请求 var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://api.undf.top/api/xysy/api/postdata/?v=' + name); xhr.send(); // 4. 获取响应 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status === 200) { // 5. 显示响应 var response = xhr.responseText; alert(response); //跳转到首页 window.location.href = \"https://c.undf.top/xy/\"; console.log(response); } } } });"}]