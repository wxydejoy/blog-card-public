[{"title":"毕业论文撰写日记","date":"2021-11-16T21:20:55.000Z","url":"/posts/61770a12/","categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"题目确定机床拨叉零件铝合金压铸模具设计及机加工工装夹具设计 任务： 重新绘制该零件图，按需要适当调整技术要求。 压铸模设计；简化零件结构，去除不便于压铸成型的结构（这部分结构让后续机加工方式成型），并对后续需要机加工的结构放加工余量，绘制此时的压铸胚体零件图。 在UG软件中进行三维建模，并通过UG的moldwizard模具设计模块进行分型，完成其压铸模设计，在flow3d中完成压铸流动CAE分析。 分析讨论由压铸完成的精密毛坯件的后续加工工艺，明确其加工工序；对需要机加工的部分结构，选择典型结构设计机加工夹具，并在三维软件中完成该夹具设计。 零件图出图和装配图出图，完成毕业设计论文。 三维建模闲话2021.11.16 安装好了两个软件 一开始没断网安装UG折腾了半天。 什么时候能用上正版软件 什么时候能用上国产软件 什么时候能用上国产正版软件 caxa 既然可以 那么这些也一定可以 只是时间问题 加油！！！ 今天就用UG简简单单建个模型。 没有想象中的简单，UG不熟悉 现在是11.17 继续 图像稍微模糊点，问题不大，毕竟cdn不是无限的 二维图纸 UG导出的 改天再画细节 –11.17 闲话刚搞了个随机图片api 真好玩 今天身生病了，就在寝室搞搞毕业设计吧！ 画图纸 补充一点点细节完工 又有点冷了，收拾一下，睡觉了。 2021.11.21 外文论文翻译要求 2W 打印字符 闲话今天费劲巴拉的找了两篇字符在3w左右的文章，通过office先自动翻译，然后再自己阅读进行详细的修改。 咋感觉给自己找了个坑 但是考虑到后面还要在文章中引用，就这两篇吧。 问题不大。 2021.11.22 文献综述开题报告压铸模具设计流动分析"},{"title":"图书馆奇遇记","date":"2021-11-13T20:04:05.000Z","url":"/posts/85b39a47/","categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"今天来聊聊在图书馆遇到的各种自由职业者。 WIFI起名员（点赞）主要特点：Wi-Fi名字起的非常不错 比如：连热点看大学生 coffee的工业制法 花间一壶酒 野指针001 黄金脆皮鸡等等 猜猜哪个是我的热点名？（提示：小米9） 噪音制造器主要特点：擅长制造各种噪音 品茶大师主要特点：摇头晃脑 品茶出声（⚠️是品茶的声音，不是正常人喝水的声音） 狗粮生产机确实羡慕小情侣，但咱也不是没谈过，你正常谈也没什么问题，别影响其他人嘛 主要特点：聊天 卿卿我我 窗外的乌鸦这个不是说某一位同学，是真的乌鸦，有时很吵，有时又还好。 空调不得不说图书馆的空调是真不错，比宿舍强多了。宿舍空调功率太小，吹不到下铺，桌子底下冻得要死，上铺却很热。"},{"title":"NPM 图床探究","date":"2021-11-07T15:20:55.000Z","url":"/posts/50ee91a2/","tags":[["💻 Hexo","/tags/%F0%9F%92%BB-Hexo/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"起因最近在吾爱发帖，苦于福利区不能贴图，要用自己的图床，然后我用了又拍云，一个帖子，一天，3元。 这个价格有点贵了hhh，所以想要找个稳定的图床，本来用jsd + GitHub 但是论坛屏蔽掉了 jsd 好像是因为会传播木马什么的，总之是不安全。 而且写教程还是蛮辛苦的，不想因为图床挂了而不能看，所以想要一个稳定的免费的图床，所以就想到了npm 经测试 NPM 不会被论坛审核，可以使用，如图 NPM 图床创建及日常使用这里给店长打个广告，我也是通过店长和cyfan才了解到npm图床的 npm图床的使用 NPM 图床的自动化流程如下 Picgo上传图片到GitHub这一步的目的是方便预览，而且为后面查找替换打个基础 而且这一步会遇到GitHubaction 报错 这不重要 关掉通知 直接无视 GitHub Action 自动推送到npm这个教程里面有写，不再赘述npm图床的使用 至于为什么使用action发包是因为图床很大，发包很慢 Windows 自动发包利用shell脚本，这个脚本放到图床仓库根目录运行即可 内容其实很简单，就是简单的git命令 批量查找替换~~~求人不如求己，cyfan没看见就自己写，百度了一下 sed 命令 挺好的~~~这里是利用shell脚本的查找替换功能比如将3.txt中的 unpkg.zhimg.com/wxydeimage@1.0.43 替换成 unpkg.zhimg.com/wxydeimage@1.0.23 其中有转义符号 sed -i &#39;s/cdn.jsdelivr.net\\/gh\\/wxydejoy\\/image/unpkg.zhimg.com\\/wxydeimage@1.0.23/g&#39; 3.txt 加上文件遍历，就变成了这个样子。这个脚本放在博客根目录即可 其中wxydejoy image是GitHub用户名和仓库wxydeimage是npm包名，1.0.23 是版本号 写着写着电脑黑屏了，吓死，幸亏是vscode自动保存了，有惊无险 完全自动化我的目标是只要在提交之前运行一次脚本，无需手动修改版本号 ==敬请期待== 后话今天看到npm的图床是想换来着，但是跑了一下速度，还是又拍云香，npm就用来论坛发帖吧，不过这个方案比较适合没有又拍云的同学。�"},{"title":"唠唠叨叨","date":"2021-11-06T08:05:00.000Z","url":"/posts/c16ab6dc/","tags":[["🌄","/tags/%F0%9F%8C%84/"]],"categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"好久没写文章了，其实我挺不会写作文的，高中好像40分的作文我一般也就33，大概班里平均分的水平，而且这还是字写的好的情况，写的不好，一般都是要被班主任拉去练字的（高一好像练了一学期的样子，后面就好点了）。 刚想搞个词云图的封面，发现自己博客变成了不安全（如图） 盲猜是又拍云的锅，让我看看 又拍云没问题 阿里云也没问题 ？？？ 无痕也不管用 让我瞅瞅GitHub GitHub也没事 好像是又拍云http2的原因，算了，能用就行 还是去搞词云图吧! 就这样封面就好了 一会看比赛，但我现在好困啊 （哈欠） 现在是19:32 洗把脸去吧，脸上油腻腻的（妥妥的油腻大叔） 然后去超市搞点啤酒快乐水 哈皮一下，明天又要回图书馆上班了（学习） 最近水群不快乐，那就不水了。 还不如去论坛发发帖，至少还有积分可以领。 说实话，论坛撒撒币还是很快乐的，但最近换了论坛的头像搞成-100cb，很难。 什么时候想起来再说吧 京东薅羊毛还是蛮快乐的，电池+瓜子+袋子，好几样。 说起快乐，好像没什么值得快乐的事情，每天都很平淡，质朴，这就是生活吧！ 最近的快乐都是很快的，一瞬间，快到你感受不到，真感觉自己抑郁了，颓。 这两天在寝室呆了两天，心情没变好不说，还变得更差了，本来休息就是想调整一下心态，结果搞成这样，写下来应该会好很多。 比如现在。 今晚写一个hexo新手工具。 买了快乐水，rio 走到楼下，变成了这样. 还是蛮解压的，然后顺手就给整理废品的宿管大叔。 好了来写个python小项目：hexo 新手初始化程序（带GUI）自用 环境准备用pycharm 通过python自带的tkinter 写，原因呢是因为之前用过：点我. 为了避免逼逼叨叨，自用，爱用不用 8点了 打开b站放到副屏 今天刚收拾完，还能看 功能既然是自用，那刚开始安装那一套先不搞，先搞搞平常最常用的命令。 hexo clean generate deploy 界面EDG 牛逼"},{"title":"PDF 去除水印教程","date":"2021-11-04T07:36:15.000Z","url":"/posts/b79413ee/","tags":[["PS","/tags/PS/"],["Pitstop","/tags/Pitstop/"]],"categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"PS 去水印拿到一个PDF你首先要判断一下他是不是源文件， 很显然这个不是，所以无法使用常规手法， 而且这个是纯图片格式，可以选择PS去水印，后面遇到其他PDF我再更新 效果勉勉强强，本人PS技术一般般，方法如下： 将PDF转为图片：尽量搞得清楚点，有些软件可能会压缩图片，这里还是推荐adobe的，或者x-change 这些论坛里面都有 随便找一张或者几张PDF分页图片导入到PS，通过调整色阶，对比度，甚至手动抠出 等等方法，去除水印 将2中的方法录制为动作（ps自带录制功能ALT + F9）实在不行可以百度搜索：ps录制功能 然后对所有PDF分页图片进行批处理（同样是PS自带功能 选项卡：文件 – 自动 – 批处理）实在不行可以百度搜索：ps批处理 将处理好的分页文件合成PDF 完成 其中最重要的是摸索PS工具，将水印去除，这是技术核心。这个就没什么可教的了，百度一下 下一篇更新：pitstop的使用 Pitstop 的使用方法（偏实用向，新手向）效果图 工具设置首先把pitstop的选择器 固定到快捷栏 工具栏 右键 自定义快速工具 找到Pitstop 选择器 把选择对象和检查器以及动作列表固定上去 案例 1 分块水印分块水印的意识是 水印的这个也算比较复杂的了，我也是第一次遇到，当然这个也可以用PS搞，但不建议，因为这个不是纯图片格式的pdf，也就是说他的每个元素是可以选择的。 首先用选择工具选择你想去除的水印，为了避免广告就拿这个押题来举例吧 右键 显示检查器 ：可以看到它不是文本，不是图片，讲真的我也以为要翻车了，之前没遇到过嘛。 但是注意到了它的颜色比较特别所以摸索了一下 打开动作列表，新建动作 在色彩里面找到选择填充色彩 注意：此时要保持选中水印才能抓取 添加移除所选对象动作 单页测试 测试成功则改成整个文档运行动作，到此完成 案例 2 固定位置水印 且无遮挡 还是老样子，选择器选择，查看属性，不是文本，不是图片，但位置固定（在页眉） 打开动作列表 找到： 选择区域内部或外部的对象 填入数据，注意：锚点数据复制粘贴即可，大小的数据可以稍大一点 单页测试运行即可 PITSTOP 中文过期解决办法打开文件夹：删除除动作列表之外的文件，不行就再替换一下激活文件C:\\Users\\w\\AppData\\Roaming\\Enfocus Prefs Folder refs Folder"},{"title":"博主近况","date":"2021-11-02T08:05:00.000Z","url":"/posts/95233eee/","tags":[["🌄","/tags/%F0%9F%8C%84/"]],"categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"目前正在备战考研 目标本校，难度一般，不过我的目标是400分（去年复试线是327），满分500。 目标专业 02(机械（航天工程、船舶工程、机器人工程）) 1(全日制) 综合性比较强的专业。 就这样"},{"title":"胡思乱想和那些未来要填的坑","date":"2021-08-18T07:36:15.000Z","url":"/posts/e32/","categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"我是一个偶尔胡思乱想的人，偶尔有一些好点子还是很不错的。 胡思乱想感情是很宝贵的东西，但也是很廉价的东西–庆余年 除了吃喝拉撒这种生物本能，世上没有什么天经地义的事情，那些都是古往今来圣贤哲学家构建出来的。–徐涛 形而上学，不行下学中国的部分软弱男明星可能是国外的阴谋 填坑%% checkbox fluent search 软件介绍%%%% checkbox 学学js%% %% checkbox 正则表达式%% 想写的文章80分万岁"},{"title":"关于小米的一些个人看法","date":"2021-08-05T13:05:00.000Z","url":"/posts/744f/","tags":[["📱 小米","/tags/%F0%9F%93%B1-%E5%B0%8F%E7%B1%B3/"]],"categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"%%% tip home %%%-仅仅是个人看法,不喜勿喷,不想吵架.%%% endtip %%%- 我的手机 在miui+上面的截图,懒得手机截图了 刷的乌龟官改包,至于为什么不用原版,乌龟有个工具包,挺好用的. 工具包截图 乌龟的好像是开发板改的,基本跟原版差不多吧 目前感觉还不错流畅度 动画比之前是好多了 还不错的感觉 偶尔卡顿 感受不明显续航 我的小米⑨ 我换过中电的电池 好像是3800左右 一天一两充的样子 ,亮屏玩不了多久 只能说 够用发热 平常不打游戏 打游戏也问题不大 感觉还好 满分5分 给个4分应该不过分 毕竟是老机器了 而且最近一直有新功能在更新,感觉还不错 网上的言论网上说什么的都有,个人感觉喷子居多 我觉得有些点是被舆论放大很多,其实有些是小问题 至于某些型号发热 比如 火龙888 这个我觉得大概率是真的 毕竟那么多人喷 也不可能空穴来风 而且888也是一头火龙 小米的调校本来就一般 这些都不是我在意的点,重点在下面 近期关键问题小米社区屏蔽关键词 发热 掉帧 等等讲真我刚开始看到这个觉得不可能,小米那么开放,肯定不是真的 但我去搜索 真的被屏蔽了 被网友发现之前 被网友骂了之后 有些词还是被屏蔽,没用 到这里其实也还好吧,为了压制舆论,我也理解,勉强接受 小米直面会耍猴就这个,看过的应该都想喷,果核剥壳也发推送讲这个真的太耍猴了,预告说讲讲近期问题,mix4什么的,还有粉丝关注的问题巴拉巴拉 结果 放完广告就没了 我刚开始以为是线路出问题了 结果 没了 没了 真耍猴 然后各种推迟 小米你的信用哪去了 内测规则改动虽然我没进入内测区 但我好歹在开发板区里面 来看看规则吧 这不是 强行打工么 真拿米粉当屌丝 结语我之前喜欢魅族,现在依旧喜欢,虽然魅族管理也是瞎搞,但手机颜值和flyme真的没得说,从pro7的智慧屏开始凉凉,之后就没好过 那天跟室友开玩笑说,魅族从后屏开始凉凉,小米会不会也这样 没想到 一语成谶 就看小米后面的动作了 如果 只是 如果 如果mix4让粉丝伤心 那小米真的要走下坡路了 至少数码圈子不行了 就像当年的魅族 慢慢的慢慢的 没了没了 没了 但 如果 mix4 惊艳粉丝 凭一己之力 力压群雄,称霸数码圈 那 小米的未来可期 超越苹果 也不是没有可能 但是 但是 但是 如果 小米用惊艳 mix4 配上 miui 版本 小米的未来 我看不到 至少 无法 超越 苹果 就这 希望 MIX4 能 足够惊艳 小米 未来可期"},{"title":"AHK脚本","date":"2021-07-28T20:00:05.000Z","url":"/posts/a583/","tags":[["⌨️ AHK","/tags/%E2%8C%A8%EF%B8%8F-AHK/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"关于ahk语言请百度，这里只是记录常用改键代码。 AHK按键参考表鼠标概述ttLButton 鼠标左键RButton 鼠标右键MButton 鼠标中键或滚轮高级XButton1 鼠标的第四个按钮 一般和 Browser_Back 执行相同功能XButton2 鼠标的第五个按钮 一般和 Browser_Forward 执行相同功能WheelWheelDown 向下转动鼠标滚轮（向您的方向）WheelUp 向上转动鼠标滚轮（远离您的方向）WheelLeftWheelRight 向左或向右滚动 需要 Windows Vista 或更高版本 这可以用在某些（但并非所有）带第二个滚轮或支持左右滚动的鼠标热键注意: 字母和数字按键的名称和单个字母或数字相同. 例如: b 表示 “b” 键而 5 表示 “5” 键. CapsLock 大小写锁定键Space 空格键Tab Tab 键Enter (或 Return) 回车键Escape (或 Esc) 退出键Backspace (或 BS) 退格键 ScrollLock 滚动锁定键Delete (或 Del) 删除键Insert (或 Ins) 插入改写切换键Home Home 键End End 键PgUp 向上翻页键PgDn 向下翻页键Up 向上方向键Down 向下方向键Left 向左方向键Right 向右方向键 F1 - F24 在大多数键盘顶部的 12 个或更多的功能键 按键修饰符LWin 左边的 Windows 徽标键 对应的热键前缀为 &lt;#RWin 右边的 Windows 徽标键 对应的热键前缀为 &gt;#注意：与 Control/Alt/Shift 不同，没有一般的/中性的“Win”键，因为操作系统不支持 不过含 # 修饰符的热键可以被任何一个 Win 键触发 Control ^ Alt ! Shift +LControl（或 LCtrl） &lt;^RControl（或 RCtrl） &gt;^LShift 左 Shift 键 对应的热键前缀为 &lt;+RShift 右 Shift 键 对应的热键前缀为 &gt;+LAlt 左 Alt 键 对应的热键前缀为 &lt;!RAlt 右 Alt 键 对应的热键前缀为 &gt;! Browser_Back 后退Browser_Forward 前进Browser_Refresh 刷新Browser_Stop 停止Browser_Search 搜索Browser_Favorites 收藏夹Browser_Home 主页Volume_Mute 静音Volume_Down 调低音量Volume_Up 增加音量Media_Next 下一首Media_Prev 上一首Media_Stop 停止Media_Play_Pause Play/PauseLaunch_Mail 打开默认的电子邮件程序Launch_Media 打开默认的媒体播放器Launch_App1 打开我的电脑Launch_App2 打开计算器注：上面列出的每个按键的功能可以通过修改 Windows 注册表进行替换 这个表格中显示的是在 Windows 系统的大多数版本中每个按键的默认功能特别AppsKey 菜单键 这是调用右键上下文菜单的按键PrintScreen 捕获屏幕CtrlBreak暂停 暂停键中断 中断键 由于此键和 Pause 含义相同，所以在热键中请使用 ^CtrlBreak 代替 ^Pause 或^Break帮助 帮助键 此键可能在大多数键盘上不存在 它通常和 F1 不同.Sleep 休眠键 注意在一些键盘上的 sleep 键可能不是休眠功能SCnnn 请在 nnn 中指定按键的扫描码 识别上面没有提到的罕见的按键 请参阅特殊按键了解详情VKnn 请在 nn 中指定十六进制的虚拟按键码 这种极少用的方法还可以避免某些类型的热键需要安装键盘钩子 例如，后面的热键不使用键盘钩子，但副作用是它会在按下 Home 或 NumpadHome 的其中一个时触发：^VK24::MsgBox You pressed Home or NumpadHome while holding down Control.已知限制：强制使用键盘钩子的 VK 热键，例如 *VK24 或 ~VK24，只会触发其中一个热键，而不会触发两者（例如触发 NumpadHome 但不触发 Home） 关于 VKnn 方法的更多细节，请参阅特殊按键 "},{"title":"看板罗小黑-live2d","date":"2021-07-24T15:20:55.000Z","url":"/posts/bc41/","tags":[["💻 Hexo","/tags/%F0%9F%92%BB-Hexo/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"最终效果 左下角就有 安装插件 主题配置打开站点配置文件，插入 推荐配置 这是我调整好的效果，如果想自定义，请按注释配置 安装罗小黑皮肤 一键三连 记得去给up主一键三连 桌面版仓库zenghongtu/PPet: 👻在你的桌面放一个萌妹子，多一点趣味😏~（支持Mac、Win和Linux） (github.com) 导入模型即可（模型去up主视频下面下载） 猫形态-人形态变换 因为没有能力自建API，所以只能咯咯咯 相关资料在这里 fghrsh/live2d_api: Live2D 看板娘插件 () 上使用的后端 API (github.com) stevenjoezhang/live2d-widget: 把萌萌哒的看板娘抱回家 (ノ≧∇≦)ノ | Live2D widget for web platform (github.com) 如果有大佬建了api,请踢我一脚（评论区留言） 其他刚才百度，还发现了其他的模型，牛！ 【罗小黑战记】比丢live 2d+facerig演示_哔哩哔哩_bilibili 「罗小黑战记」哪吒live2d互动壁纸展示,游戏,RPG游戏,好看视频 (baidu.com) 把罗小黑官方宣传海报动画化！肝爆的live2d动态海报制作！_哔哩哔哩_bilibili 不过都没链接，可能得去软件里面扒。 关于api折腾半天，也没成功，大佬记得踢我一脚。 %%% tip home %%%-感谢b站宝藏up主我把罗小黑做成了Live2D虚拟主播！_哔哩哔哩_bilibili提供的罗小黑live2d模型、EYHN/hexo-helper-live2d插件、Live2d Widget | Akilar の糖果屋 %%% endtip %%%-"},{"title":"冰球 背景","date":"2021-07-21T15:20:55.000Z","url":"/posts/c6bd/","tags":[["💻 Hexo","/tags/%F0%9F%92%BB-Hexo/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"%%% tip home %%%- 首先感谢大佬的开源项目 %%% ghcard teachtyler/Icosahedron-Geometry %%%- 还有店长的教程糖果屋微调合集 | Akilarの糖果屋 Custom Beautify | Akilarの糖果屋 %%% span red, 未实现：冰球跟随音乐振动 %%%- 希望有大佬来解决这个问题，我这个小菜鸡实在搞不定。 有建议请评论区留言，欢迎！！ 7.27更新：关闭移动端并根据屏幕大小判断是否引入并开启 %%% endtip %%%- 最终效果 引入js只针对butterfly主题，其他主题请自己根据情况调整 icebg.js代码在最下面 在_config.butterfly.yml中inject的bottom:插入代码 建议修改合适后再通过jsd加速插入，因为每个人需求不一样，如果你想要本站一样的效果就改成这样,如果需要自定义请接着看。 当然，建议读者把代码存到自己仓库 如果只需要当背景，而不是头图，到这里就够了，如果想要跟本站一样，参考店长头图透明教程在costom.css文件中加入 注意：因为butterfly版本迭代，店长教程中的配置手机 PC 页面白天黑夜共四个背景图的第一步请按diff代码块配置。因为我就掉坑了 店长教程点这里Custom Beautify | Akilarの糖果屋,建议配合糖果屋微调合集 | Akilarの糖果屋配置手机 PC 页面白天黑夜共四个背景图食用，效果更佳。 然后 然后就没了，就这，对，就这。 自定义建议有一定基础的朋友进行自定义修改，比如把球改到侧边栏 icebg.js我放在了source博客根目录，方便调试，读者可以根据情况修改。 自定义只需要修改icebg.js内的代码就可以了，代码还是挺长的，其他的我也不会了，大家看着办吧，有大佬改记得评论区告诉我一下。 "},{"title":"词云图","date":"2021-07-18T21:20:55.000Z","url":"/posts/40a1/","tags":[["test","/tags/test/"]],"categories":[[" ",""]],"content":"微词云 微词云 · 简单强大的文字云艺术生成器 (weiciyun.com) %%% folding green, 共享账号、来自吾爱破解论坛 %%%- 15838146089 wang@6089 %%% endfolding %%%- 图悦图悦-在线词频分析工具-词云图制作软件 (picdata.cn) 优词云能用且免费，但不是很好看，有广告但可以跳过。 优词云|词云|标签云|专业强大的在线词云制作工具|在线标签云制作 (uciyun.com) WordItOut EdWordle比较适用于英文文章，中文可以但不好用。 Create word clouds – WordItOut EdWordle WordArt.com很慢，慢到我还没用过 Edit word art - WordArt.com"},{"title":"创业讲座","date":"2021-07-18T21:20:55.000Z","url":"/posts/1598/","categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"讲座笔记 创业的前提 个人观点1.物质基础，说白了就是要有钱。2.可以承受创业失败，或者一定程度上的失败，毕竟大部分创业是有可能失败的，不能赌上自己的全部身家，就像我们之前教股票的老师讲的一样:不能拿自己吃饭的钱去炒股。3.然后就是接下来要讲的有老师讲的，也有个人观点，混杂。 产品擅长与其说是擅长，不如说是优点，或者是解决了什么痛点。一个产品要有足够的竞争力，这是一个团队或者一个企业的核心，也是创业前提中很重要的一点。 趋势产品就像人一样，人不会选择在没有前途的行业发展，产品也不能在没有前景的行业内发展，如果行业整体发展力不足，再好的产品也无济于事，除非你的产品可以改变这种现状。 蓝海蓝海:就是行业市场还很广，同行业公司有但不多。红海:行业市场内部竞争大，内卷严重，巨头争霸。那肯定不能在红海，个人感觉红海也可以理解为血流成河的海。 大众大众不如说是受众产品的受众要广，让100个人各拿1块钱，总是比让1个人拿100块要容易的多，当然这话不能说绝对，但一般是这样，而且你要有找到100个人的能力，现在腾讯和网易的游戏就很好的论证了这句话，懂得都懂。 创新这个点跟上面的擅长类似，其实都是讲要有足够的竞争力，创新是必要条件，但不是充分条件，毕竟不是所有创新都是有意义的。 兴趣创业肯定要做自己感兴趣的事情，这没什么好讲的，虽然创业是为了钱，但也不能只为了钱。 团队创业初期团队很重要，当然如果选择单干也没问题，一个良好的团队要有分工，有管理，还有最重要的信任。关键字:信任，互补，匹配，稳定 资金这个前面讲了，不再细说，讲一个老师提到的点，签合同注意惩罚条款，对赌协议之类的。启动资金要足够，这个前面讲到了接受投资不能太多，要明确需要多少，掌握公式主权。关键字:启动，少量，及时，投入 销售要有好的销售渠道，这个讲的不多，但也很重要人脉要广:例如讲座老师的5个微信号，每个5000人客服最好自己把握，企业与客户之间加强沟通成本控住，成本也是核心竞争力之一机密保住，保不住公司就没了，就是这么现实。扩张:要有远见，买商标要买全关键词:人脉，客服，成本，机密，扩张"},{"title":"使用又拍云加速后的HTTPS访问和DNS设置","date":"2021-07-16T15:20:55.000Z","url":"/posts/ce44/","tags":[["💻 Hexo","/tags/%F0%9F%92%BB-Hexo/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"%%% tip home %%%-https折腾好久，就是搞不定，最后是自己配置有问题，所以来写个教程 域名以我自己的为例 wxydejoy.top 注：本教程适用于有一定折腾基础的朋友，主要是裸域名的访问，有建议可以评论。 %%% endtip %%%- 最终效果记得cmdipconfig /flushdns 记得cmdipconfig /flushdns 记得cmdipconfig /flushdns 记得cmdipconfig /flushdns 怎么样，不错吧 Gitpage设置其实之前有的就不用修改，只是确认一下 Page设置这个其实是用来检测你的其他设置有没有问题 CNAME文件 DNS解析这里答案不唯一，多种方案都行，推荐设置，此处感谢 @哔(bì)哗(huá) 大佬的帮助 尽量照抄。 原理(不一定对，但能用) DNS设置 又拍云CDN加速CDN怎么开启这里不讲了，只讲关键配置 服务名称随意 裸域名的CDN配置 www域名的CDN配置 建议不得不说我现在typora配合picgo和又拍云写教程很香，之前GitHub图床上传超慢，现在秒上传 可以开个存储仓库用来做图床，很香。 另外设置好cdn加速之后，可以打开静态资源加速，很不错。 SSL证书申请这一步最为关键，我这里是阿里的ssl免费证书，哪家都可以，建议在自己购买域名的地方申请，可以一键设置dns解析，方便快捷。 到这里就可以点击验证，当然如果是其他地方申请的参照各个服务商的设置。 域名验证成功，域名验证记录在证书签发后再删除，否则会因没有解析记录导致证书签发失败。 这里可以看到证书对www.wxydejoy.top和wxydejoy.top是都可用的，接下来会提到。 签发后等一下可以删掉 别忘了在申请证书那地方下载证书 又拍云的HTTPS访问设置然后到又拍云 填入刚才下好的证书（文本格式），全部复制就好，全部复制！！！ %%% tip home %%%-一定要记得两个域名(www和裸域名)都要打开强制https，不然www是打不开的 %%% endtip %%%- 到这里就结束了 记得把签发验证的dns解析删掉，不删也问题不大 检验建议用手机开流量访问测试，电脑延迟还是蛮久的，或者重启(有路由器的重启路由器，尤其是闪讯) 记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns记得cmdipconfig /flushdns"},{"title":"emoji大全","date":"2021-07-02T21:20:55.000Z","url":"/posts/6bdd/","tags":[["🙃 HPP","/tags/%F0%9F%99%83-HPP/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":" 🚩23 🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥emoji表情😀😃😄😁😆😅🤣😂🙂🙃😉😊😇🥰😍🤩😘😗☺️😚😙🥲😋😛😜🤪😝🤑🤗🤭🤫🤔🤐🤨😐😑😶😏😒🙄😬🤥😌😔😪🤤😴😷🤒🤕🤢🤮🤧🥵🥶🥴😵🤯🤠🥳😎🤓🧐😕😟🙁☹️😮😯😲😳🥺😦😧😨😰😥😢😭😱😖😣😞😓😩😫🥱😤😡😠🤬emoji人物👶🧒👦👧🧑👱👨🧔👨‍🦰👨‍🦱👨‍🦳👨‍🦲👩👩‍🦰🧑‍🦰👩‍🦱🧑‍🦱👩‍🦳🧑‍🦳👩‍🦲🧑‍🦲👱‍♀️👱‍♂️🧓👴👵🙍🙍‍♂️🙍‍♀️🙎🙎‍♂️🙎‍♀️🙅🙅‍♂️🙅‍♀️🙆🙆‍♂️🙆‍♀️💁💁‍♂️💁‍♀️🙋🙋‍♂️🙋‍♀️🧏🧏‍♂️🧏‍♀️🙇🙇‍♂️🙇‍♀️🤦🤦‍♂️🤦‍♀️🤷🤷‍♂️🤷‍♀️🧑‍⚕️👨‍⚕️👩‍⚕️🧑‍🎓👨‍🎓👩‍🎓🧑‍🏫👨‍🏫👩‍🏫🧑‍⚖️👨‍⚖️👩‍⚖️🧑‍🌾👨‍🌾👩‍🌾🧑‍🍳👨‍🍳👩‍🍳🧑‍🔧👨‍🔧👩‍🔧🧑‍🏭👨‍🏭👩‍🏭🧑‍💼👨‍💼👩‍💼🧑‍🔬👨‍🔬👩‍🔬🧑‍💻👨‍💻👩‍💻🧑‍🎤👨‍🎤👩‍🎤🧑‍🎨👨‍🎨👩‍🎨🧑‍✈️👨‍✈️👩‍✈️🧑‍🚀👨‍🚀👩‍🚀🧑‍🚒👨‍🚒👩‍🚒👮👮‍♂️👮‍♀️🕵️🕵️‍♂️🕵️‍♀️💂💂‍♂️💂‍♀️🥷👷👷‍♂️👷‍♀️🤴👸👳👳‍♂️👳‍♀️👲🧕🤵🤵‍♂️🤵‍♀️👰👰‍♂️👰‍♀️🤰🤱👩‍🍼👨‍🍼🧑‍🍼👼🎅🤶🧑‍🎄🦸🦸‍♂️🦸‍♀️🦹🦹‍♂️🦹‍♀️🧙🧙‍♂️🧙‍♀️🧚🧚‍♂️🧚‍♀️🧛🧛‍♂️🧛‍♀️🧜🧜‍♂️🧜‍♀️🧝🧝‍♂️🧝‍♀️🧞🧞‍♂️🧞‍♀️🧟🧟‍♂️🧟‍♀️💆💆‍♂️💆‍♀️💇💇‍♂️💇‍♀️🚶🚶‍♂️🚶‍♀️🧍🧍‍♂️🧍‍♀️🧎🧎‍♂️🧎‍♀️🧑‍🦯👨‍🦯👩‍🦯🧑‍🦼👨‍🦼👩‍🦼🧑‍🦽👨‍🦽👩‍🦽🏃🏃‍♂️🏃‍♀️💃🕺🕴️👯👯‍♂️👯‍♀️🧖🧖‍♂️🧖‍♀️🧘🧑‍🤝‍🧑👭👫👬💏👩‍❤️‍💋‍👨👨‍❤️‍💋‍👨👩‍❤️‍💋‍👩💑👩‍❤️‍👨👨‍❤️‍👨👩‍❤️‍👩👪👨‍👩‍👦👨‍👩‍👧👨‍👩‍👧‍👦👨‍👩‍👦‍👦👨‍👩‍👧‍👧👨‍👨‍👦👨‍👨‍👧👨‍👨‍👧‍👦👨‍👨‍👦‍👦👨‍👨‍👧‍👧👩‍👩‍👦👩‍👩‍👧👩‍👩‍👧‍👦👩‍👩‍👦‍👦👩‍👩‍👧‍👧👨‍👦👨‍👦‍👦👨‍👧👨‍👧‍👦👨‍👧‍👧👩‍👦👩‍👦‍👦👩‍👧👩‍👧‍👦👩‍👧‍👧🗣️👤👥🫂emoji手势👋🤚🖐️✋🖖👌🤌🤏✌️🤞🤟🤘🤙👈👉👆🖕👇☝️👍👎✊👊🤛🤜👏🙌👐🤲🤝🙏✍️💅🤳💪emoji日常👣👀👁️👄💋👂🦻👃👅🧠🦷🦴💪🦾🦿🦵🦶👓🕶️🥽🥼🦺👔👕👖🧣🧤🧥🧦👗👘🥻🩱🩲🩳👙👚👛👜👝🎒👞👟🥾🥿👠👡🩰👢👑👒🎩🎓🧢⛑️💄💅💍💼🌂☂️💈🛀🛌💥💫💦💨emoji手机📱📲📶📳📴☎📞📟📠🤳emoji公共♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈emoji动物🙈🙉🙊💥💫💦💨🐵🐒🦍🦧🐶🐕🦮🐕‍🦺🐩🐺🦊🦝🐱🐈🐈‍⬛🦁🐯🐅🐆🐴🐎🦄🦓🦌🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🦙🦒🐘🦏🦛🐭🐁🐀🐹🐰🐇🐿️🦔🦇🐻🐻‍❄️🐨🐼🦥🦦🦨🦘🦡🐾🦃🐔🐓🐣🐤🐥🐦🐧🕊️🦅🦆🦢🦉🦩🦚🦜🐸🐊🐢🦎🐍🐲🐉🦕🦖🐳🐋🐬🐟🐠🐡🦈🐙🐚🐌🦋🐛🐜🐝🐞🦗🕷️🕸️🦂🦟🦠🦀🦞🦐🦑emoji植物💐🌸💮🏵️🌹🥀🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿☘️🍀🍁🍂🍃emoji自然🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀️🌝🌞⭐🌟🌠☁️⛅⛈️🌤️🌥️🌦️🌧️🌨️🌩️🌪️🌫️🌬️🌈☂️☔⚡❄️☃️⛄☄️🔥💧🌊emoji饮食🍇🍈🍉🍊🍋🍌🍍🥭🍎🍏🍐🍑🍒🍓🥝🍅🥥🥑🍆🥔🥕🌽🌶️🥒🥬🥦🧄🧅🍄🥜🌰🍞🥐🥖🫓🥨🥯🥞🧇🧀🍖🍗🥩🥓🍔🍟🍕🌭🥪🌮🌯🥙🧆🥚🍳🥘🍲🥣🥗🍿🧈🧂🥫🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🥮🍡🥟🥠🥡🦪🍦🍧🍨🍩🍪🎂🍰🧁🥧🍫🍬🍭🍮🍯🍼🥛☕🍵🍶🍾🍷🍸🍹🍺🍻🥂🥃🥤🧋🧃🧉🧊🥢🍽️🍴🥄emoji文体🧗🧗‍♂️🧗‍♀️🤺🏇⛷️🏂🏌️🏌️‍♂️🏌️‍♀️🏄🏄‍♂️🏄‍♀️🚣🚣‍♂️🚣‍♀️🏊🏊‍♂️🏊‍♀️⛹️⛹️‍♂️⛹️‍♀️🏋️🏋️‍♂️🏋️‍♀️🚴🚴‍♂️🚴‍♀️🚵🚵‍♂️🚵‍♀️🤸🤸‍♂️🤸‍♀️🤼🤼‍♂️🤼‍♀️🤽🤽‍♂️🤽‍♀️🤾🤾‍♂️🤾‍♀️🤹🤹‍♂️🤹‍♀️🧘🧘‍♂️🧘‍♀️🎪🛹🛼🛶🎗️🎟️🎫🎖️🏆🏅🥇🥈🥉⚽⚾🥎🏀🏐🏈🏉🎾🥏🎳🏏🏑🏒🥍🏓🏸🥊🥋🥅⛳⛸️🎣🎽🎿🛷🥌🎯🎱🎮🎰🎲🧩♟️🎭🎨🧵🧶🎼🎤🎧🎷🪗🎸🎹🎺🎻🥁🎬🏹emoji恐怖😈👿👹👺💀☠👻👽👾💣emoji旅游👣🎠🎡🎢🚣🏔️⛰️🌋🗻🏕️🏖️🏜️🏝️🏞️🏟️🏛️🏗️🏘️🏚️🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🕌🛕🕍⛩🕋⛲⛺🌁🌃🏙️🌄🌅🌆🌇🌉🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🛻🚚🚛🚜🏎️🏍️🛵🛺🚲🛴🚏🛣️🛤️⛽🚨🚥🚦🚧⚓⛵🚤🛳️⛴️🛥️🚢✈️🛩️🛫🛬🪂💺🚁🚟🚠🚡🛰️🚀🛸🪐🌠🌌⛱️🎆🎇🎑💴💵💶💷🗿🛂🛃🛄🛅🧭emoji物品💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨emoji标志♠️♥️♦️♣️🃏🀄🎴🔇🔈🔉🔊📢📣📯🔔🔕🎵🎶💹🛗🏧🚮🚰♿🚹🚺🚻🚼🚾⚠️🚸⛔🚫🚳🚭🚯🚱🚷📵🔞☢️☣️⬆️↗️➡️↘️⬇️↙️⬅️↖️↕️↔️↩️↪️⤴️⤵️🔃🔄🔙🔚🔛🔜🔝🛐⚛️🕉️✡️☸️☯️✝️☦️☪️☮️🕎🔯♈♉♊♋♌♍♎♏♐♑♒♓⛎🔀🔁🔂▶️⏩⏭️⏯️◀️⏪⏮️🔼⏫🔽⏬⏸️⏹️⏺️⏏️🎦🔅🔆📶📳📴♀️♂️✖️➕➖➗♾️‼️⁉️❓❔❕❗〰️💱💲⚕️♻️⚜️🔱📛🔰⭕✅☑️✔️❌❎➰➿ 〽️✳️✴️❇️©️®️™️#️⃣*️⃣0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟🔠🔡🔢🔣🔤🅰️🆎🅱️🆑🆒🆓ℹ️🆔Ⓜ️🆕🆖🅾️🆗🅿️🆘🆙🆚🈁🈂️🈷️🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗️㊙️🈺🈵🔴🟠🟡🟢🔵🟣🟤⚫⚪🟥🟧🟨🟩🟦🟪🟫⬛⬜◼️◻️◾◽▪️▫️🔶🔷🔸🔹🔺🔻💠🔘🔳🔲🏁🚩🎌🏴🏳️🏳️‍🌈🏳️‍⚧️🏴‍☠️emoji生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖emoji星座♈♉♊♋♌♍♎♏♐♑♒♓⛎emoji钟表🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰emoji心形💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣emoji花草💐🌸💮🏵️🌹🥀🌺🌻🌼🌷🌱🌿☘️🍀emoji树叶🌿☘️🍀🍁🍂🍃emoji月亮🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝emoji水果🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🥝emoji钱币💴💵💶💷💰💸💳emoji交通🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀emoji建筑🏟️🏛️🏗️🛖🏘️🏚️🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🕌🛕🕍⛩️🕋⛲⛺🌁🌃🏙️🌄🌅🌆🌇🌉emoji办公📱📲☎️📞📟📠🔋🔌💻🖥️🖨️⌨️🖱️🖲️💽💾💿📀🧮🎥🎞️📽️📺📷📸📹📼🔍🔎🕯️💡🔦🏮🪔📔📕📖📗📘📙📚📓📒📃📜📄📰🗞️📑🔖🏷️💰🪙💴💵💶💷💸💳🧾✉️📧📨📩📤📥📦📫📪📬📭📮🗳️✏️✒️🖋️🖊️🖌️🖍️📝📁📂🗂️📅📆🗒️🗓️📇📈📉📊📋📌📍📎🖇️📏📐✂️🗃️🗄️🗑️🔒🔓🔏🔐🔑🗝️emoji箭头⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝"},{"title":"日本🗨 漫画60年","date":"2021-06-19T20:04:05.000Z","url":"/posts/2ef9/","tags":[["🗺️ 漫画","/tags/%F0%9F%97%BA%EF%B8%8F-%E6%BC%AB%E7%94%BB/"]],"categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":" BA%E7%89%A9.png)"},{"title":"芯片 74HC595 笔记","date":"2021-06-16T20:04:05.000Z","url":"/posts/2beb/","tags":[["📟 51单片机","/tags/%F0%9F%93%9F-51%E5%8D%95%E7%89%87%E6%9C%BA/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"芯片简述：74HC595是一个8位串行输入、串并行输出的位移缓存器：并行输出为三态输出。在SCK 的上升沿，串行数据由SER输入到内部的8位位移缓存器，并由QA~QH’输出，在SH_cp（移位寄存器时钟输入）的上升沿输入到移位寄存器中，在ST_cp（存储器时钟输入）的上升沿输入到存储寄存器中去。如果两个时钟连在一起，则移位寄存器总是比存储寄存器早一个脉冲。 8位串行输入/输出或者并行输出移位寄存器，具有高阻关断状态。三态。 芯片主要功能多用为：扩展端口，减小单片机芯片端口的压力。 图中7654321代表位数，学校校园网还是有点问题，github上不去，换个 shcp stcp就像两个看门的老大爷，一个管输入，一个管输出，都是上升沿有效，然后这里就可以写两个函数，参考网上的教程，以及课本（因为电路板连到了wr和rd口，没办法了，只能这样了）首先按照课本上的接线，用rxd和txd口发送 没想到卡在了电路层面，吐了，换个模拟元件就好了 黑色为1 倒叙 取反 倒序，回头写个带界面的小程序画图。今晚就到这，先睡觉�觉"},{"title":"AKKO3068说明书","date":"2021-06-10T21:20:55.000Z","url":"/posts/cd88/","tags":[["键盘⌨️","/tags/%E9%94%AE%E7%9B%98%E2%8C%A8%EF%B8%8F/"]],"categories":[[" ",""]],"content":" 24684.png)"},{"title":"建站的“心路历程”","date":"2021-06-10T21:20:55.000Z","url":"/posts/fa1d/","tags":[["test","/tags/test/"]],"categories":[[" ",""]],"content":"在听讲座，有点无聊，所以把昨天的感想写一写 太难了，踩过的坑都忘记了，这。。。。。。。 初衷建设这个网站的目的是为了记录自己学习过程、学习笔记，以便在未来能够复习、反思、回味。 另外这还是一个可以释放压力，可以倾述的平台没人会看我叨叨的，甚至还可以看看自己收藏的电影 起因这学期做了一个项目[课程设计]，是视觉识别和机械臂的综合，所以就想存到GitHub上面，偶遇到了HEXO，第一个主题是Keep，也实现了自动部署，后面换了Butterfly也就是现在的主题，非常不错 搭建、域名购买、域名解析搭建是参考的知乎找的教程，但还是踩了很多，这里不再赘述，推荐店长教程。 主题选择主题选择有很多，萝卜青菜各有所爱，这里就不讲了 主题魔改魔改必须推店长，yyds，教程直接去店里翻，不会做就去加群。 讲一讲我自己的魔改吧，首先我是不喜欢侧边栏的，虽然我开了，但是只是为了能有个目录，方便翻阅。魔改内容还是蛮多的，想到什么就讲什么吧！ butterfly主题内置的就不再赘述了(pwa快把我折磨死了) 先讲动效吧！ 加载动画是我自己魔改的，应该不会放出源码很简单的 动效(就是那些会动的)，置顶轮播，分类，标签外挂(文章里面比较好玩的东西)这些都是店长或者冰老师的插件点这 什么时候有空把源码放上来，需要请评论，没人会看的吧 服务器搭建、备案在国内建站，肯定是要备案的，还得买服务器一点都不合理，没办法，买三个月备份，肝!教程？教程是什么？ 百度一下，你就知道! 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 看教程要仔细，有些教程不全，那就去百度，或者干脆换一篇教程!耐心!仔细!认真![滑稽][菜狗]"},{"title":"py tkinter 学习笔记","date":"2021-05-25T00:00:00.000Z","url":"/posts/e778/","tags":[["📄 Python","/tags/%F0%9F%93%84-Python/"],["💻 Gui","/tags/%F0%9F%92%BB-Gui/"],["💻 Tkinter","/tags/%F0%9F%92%BB-Tkinter/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"Python gui 设计之 Tkinter 学习笔记前言其实我之前有用过QT写gui 比如这样 找这玩意花了一小会，很久之前的视觉作业，整体来说还是很方便的，但是QT打包起来会很大，不知道是因为QT，还是因为opencv，估计是后者，但是我还是想学一下这个tkinter，至少了解一下，恰好在图书馆又看到了这本书 还有csdn的一个博主就下面这个的学习笔记，可以复制！！！所以我来了，有空fork一下，防止丢失。 注：本文代码部分来自敲代码的小风 这本书我之前想自学 Python 的时候看过电子版虽然看的不多，感觉还行作者洪锦魁 所以我来学习啦！！！！！！！ 第一章 这两行缺一不可，不知道为什么书上就写了一个，注释掉了另一个 红黄绿真是亮瞎眼，不知道还有没有其他颜色（可以使用RGB，随便试试） 先去存一下文档，fork一下 因为各种事耽误了10分钟，咕咕咕，有空改改caplos 明天今天展示一下我的ansys技能，可能已经忘干净了，[点这里](轴的简单ANSYS分析 | WXY_JOY (wxydejoy.top)) 第二章噔噔噔！！ 大概看了看，太困了 来了来了，按照目录学有点没动力，那就先找点事情，有目的的学 比如 给之前的那个markdown改格式的代码加个界面，go 就是这个，一个很简单的代码 先改图标 不知道为什么就是改不成 最后搬来了珍藏的图标 首先需要几个文本 目标界面 到点了，改天再说来了来了，昨天睡觉，趁今天不怎么想学习写一会 这里要用到前几章的知识Label, Button,Entry,还有窗口管理员 先来Label 其实有点不很懂，但先这样 然后加入按钮和文本框 到这里，界面基本完成 下面才是重点 不是很熟悉这些函数，所以搞得有点慢，这书也不好用，东西不给全，还是靠百度 多行 自动排序 源代码 完成 "},{"title":"你并不是一无所有","date":"2021-05-14T21:20:55.000Z","url":"/posts/289b/","categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"134.jpg)"},{"title":"wox listary utools powerjoys功能对比","date":"2021-04-17T16:00:00.000Z","url":"/posts/cd10/","tags":[["🖥️ Software","/tags/%F0%9F%96%A5%EF%B8%8F-Software/"]],"categories":[["🖥️ Software","/categories/%F0%9F%96%A5%EF%B8%8F-Software/"]],"content":" 最近wox一直搜不到我想用的软件(绿色版软件，没安装，我的工具软件都在一个文件夹里面)，而且wox在我日常中也不怎么用，所以想换一个更方便的搜索软件百度了一下，看到这个图👇🏻 因为一直在听讲座，所以有点乱，就酱utools我用过，自从它有会员之后，不能改自己的图标之后我就没再用过它 还有就是这些插件不太适合我(可能是因为我不是个程序员吧)再看wox 图片来自(52破解)(图上是开了everything) 但是不开everything它就是个废物其实还是能用的，但比较鸡肋简单再来看listary 再来看powertoys 高糊预警(有空换) 界面都差不多其实还是有差距的，listary一会回去瞅瞅，wox挺好看的，powertoys也不错，先去试试powertoys它的功能比较多，可以尝试关掉一些功能，减少后台回去先打游戏，这次要专心，不能再坑🕳️了好消息是游戏没🕳️坏消息是我不想睡，好了睡觉去吧对了，最后用的powertoys，凑合吧"},{"title":"python + QT + 📄 Opencv 学习笔记","date":"2021-03-31T21:20:55.000Z","url":"/posts/d364/","tags":[["📄 Python","/tags/%F0%9F%93%84-Python/"],["⌨️ Qt","/tags/%E2%8C%A8%EF%B8%8F-Qt/"],["📄 Opencv","/tags/%F0%9F%93%84-Opencv/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"部分功能展示 这是视觉识别课程做的一个小软件 主要功能：通过opencv模块识别物体中心坐标，计算物体姿态角度，计算叶子面积和形心，支持文件上传识别以及摄像头采集。 目前已开源，GitHub仓库here 源码"},{"title":"很久之前的剪辑","date":"2021-03-31T21:20:55.000Z","url":"/posts/5eb1/","categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":" "},{"title":"Fluent Search","date":"2021-03-31T21:20:55.000Z","url":"/posts/d0da/","tags":[["🖥️ Software","/tags/%F0%9F%96%A5%EF%B8%8F-Software/"]],"categories":[["🖥️ Software","/categories/%F0%9F%96%A5%EF%B8%8F-Software/"]],"content":"%%% tip home %%%-可能是第一次正儿八经的的测一款软件，说是测，其实是把官网翻译一下，然后再讲讲自己的使用感受。很多内容都是搬运自官网。侵删！ 另外，虽然这个软件有github，但只是用来反馈问题，闭源，但免费。 另外，无中文。 %%% endtip %%%- %%% p center logo large, Fluent Search %%%- With Fluent Search, you can search for running apps, browser tabs, in-app content, files and more. Available for Windows 10/11 only.不会吧不会吧，不会有人还没换win10吧 微软商店链接点这 Fluent 搜索功能指南使用 Fluent Search，您可以立即搜索计算机上可用的各种资源并访问它们。Fluent Search 有很多功能，在本指南中，我们将介绍一些主要功能。 进程搜索听起来，进程搜索可让您轻松找到计算机上的任何活动进程。 进程是具有窗口的活动应用程序，您可以通过搜索窗口标题或进程名称来找到它。 此外，Fluent Search 可以在进程内找到应用内元素，例如选项卡、按钮和超链接，以立即访问它们。 屏幕搜索有些人发现使用鼠标会降低工作效率，尤其是在编程等非常面向键盘的工作中。 如果您是这些人中的一员，Fluent Search 可以满足您的需求。屏幕搜索功能可让您使用键盘轻松控制计算机。 搜索标签如上所述，Fluent Search 会搜索您计算机中的各种资源，包括但不限于 - 文件、应用程序、进程、书签、历史结果等。 为了帮助您轻松获得最相关的结果，Fluent Search 提供了一项名为“搜索标签”的功能。 Fluent Search 中的每个结果可能包含多个描述此结果的标签，使用这些标签您可以轻松过滤您的搜索以找到最相关的结果。 网络搜索是否需要立即搜索网络而无需打开浏览器并创建新标签？ 然后你明白了，使用 Fluent Search，你可以轻松地在你最喜欢的搜索引擎中进行搜索。 自定义Fluent Search 的构建考虑到了现代设计，但最重要的是能够让您自定义它。 你喜欢简约风格吗？您想在屏幕上获得尽可能多的信息吗？Fluent Search 助您一臂之力。您可以根据需要轻松缩放搜索窗口并更改其外观。 导航简单性是 Fluent Search 非常重要的方面。 在提供丰富的搜索结果的同时尽量保持简单是 Fluent Search 的一个持续挑战。 我的介绍最小外观 外观是那种磨砂透明玻璃的感觉，非常不错。 设置界面 写不动了，再说吧�"},{"title":"markdown语法说明","date":"2021-03-31T12:05:55.000Z","url":"/posts/4142/","tags":[["📄 Markdown","/tags/%F0%9F%93%84-Markdown/"]],"categories":[["💻 Code","/categories/%F0%9F%92%BB-Code/"]],"content":"Markdown基础教程Markdown主张使用最简单的符号来控制格式，兼顾易读易写特性，让你可以专注在文本创作上。 这篇文章旨在让你通过大约三分钟来快速掌握Markdown的基本用法。 在开始之前，需要特别注意的点 通常，格式控制符号与文本内容需要保留一个空格 段落之间需要空格一行 标题在书写中，标题是最常用的格式，Markdown中，通过在文本前加上 # 即可，同时，根据#的数量可以可以划分为二级标题、三级标题、四级标题…一共六级。 一级标题二级标题三级标题四级标题五级标题六级标题列表列表分为无序列表和有序列表，无序列表在文本前面加上 - 即可： 无序列表一 无序列表二 无序列表三 而有序列表仅需要在文本前面加上 1. 即可： 有序列表一 有序列表二 有序列表三 引用文本经常需要引入一些内容，包括他人的话等等。仅需要在文本前面加上 &gt; 即可： Kio•纯粹写字 文字修饰为了表达的抑扬顿挫，需要使用到粗体、斜体、删减体等来表明重点，其中用一个 * 号包围起来的文字为斜体，用 ** 包围起来的文字为粗体，而使用 ~~ 包围起来的文字为删减体： 斜体 粗体 删减体 段落分隔符通过 — 即可以添加段落分割线： 链接及图片链接和图片可以为文章润色不少，通过 描述 既可以添加链接，而在其前面添加一个 ! 号即为添加图片， 具体为: 百度 表格 英文 解释 备注 Book 书 Hello 你好 World 世界 这样即可自动生成表格，第二行为内容对准格式，第一格表示内容居中，第二格表示居左，第三格表示居右。 插入高亮代码如果你需要插入一些代码，Markdown也可以帮你自动高亮，包括行内高亮和代码块高亮，行内高亮仅需要使用 内容 包围起来即可。 至此，写作中需要用到的控制符已经介绍完毕了，Kio提供的所见即所得Markdown支持和便捷的输入辅助能帮助你快速掌握这一密术 :] "},{"title":"hexo操作介绍","date":"2021-03-31T12:00:55.000Z","url":"/posts/e93e/","tags":[["📁 HEXO","/tags/%F0%9F%93%81-HEXO/"]],"categories":[["🔖 Life","/categories/%F0%9F%94%96-Life/"]],"content":"hexo 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的hexo generate --deployhexo deploy --generate 草稿 模版hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub 变量 描述 layout 布局 title 标题 date 文件建立日期 模版（Scaffold） 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 写作 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上"},{"date":"2021-11-26T13:46:50.317Z","url":"/test%20copy.html","categories":[[" ",""]],"content":" three.js webgl - STL three.js - STL loader test by aleeper. PR2 head from www.ros.org import * as THREE from '/build/three.module.js'; import Stats from '/build/stats.js'; import { STLLoader } from '/build/stl.js'; let container, stats; let camera, cameraTarget, scene, renderer; init(); animate(); function init() { container = document.createElement( 'div' ); document.body.appendChild( container ); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 15 ); camera.position.set( 3, 0.15, 3 ); cameraTarget = new THREE.Vector3( 0, - 0.25, 0 ); scene = new THREE.Scene(); scene.background = new THREE.Color( 0x72645b ); scene.fog = new THREE.Fog( 0x72645b, 2, 15 ); // Ground const plane = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( { color: 0x999999, specular: 0x101010 } ) ); plane.rotation.x = - Math.PI / 2; plane.position.y = - 0.5; scene.add( plane ); plane.receiveShadow = true; // ASCII file const loader = new STLLoader(); // Binary files const material = new THREE.MeshPhongMaterial( { color: 0xAAAAAA, specular: 0x111111, shininess: 200 } ); loader.load( './3.stl', function ( geometry ) { const mesh = new THREE.Mesh( geometry, material ); mesh.position.set( 0, - 0.37, - 0.6 ); mesh.rotation.set( - Math.PI / 2, 0, 0 ); mesh.scale.set( 0.008, 0.008, 0.008 ); mesh.castShadow = true; mesh.receiveShadow = true; scene.add( mesh ); } ); scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) ); addShadowedLight( 1, 1, 1, 0xffffff, 1.35 ); addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 ); // renderer renderer = new THREE.WebGLRenderer( { antialias: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.outputEncoding = THREE.sRGBEncoding; renderer.shadowMap.enabled = true; container.appendChild( renderer.domElement ); // stats stats = new Stats(); container.appendChild( stats.dom ); // window.addEventListener( 'resize', onWindowResize ); } function addShadowedLight( x, y, z, color, intensity ) { const directionalLight = new THREE.DirectionalLight( color, intensity ); directionalLight.position.set( x, y, z ); scene.add( directionalLight ); directionalLight.castShadow = true; const d = 1; directionalLight.shadow.camera.left = - d; directionalLight.shadow.camera.right = d; directionalLight.shadow.camera.top = d; directionalLight.shadow.camera.bottom = - d; directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 4; directionalLight.shadow.bias = - 0.002; } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); } function animate() { requestAnimationFrame( animate ); render(); stats.update(); } function render() { const timer = Date.now() * 0.0005; camera.position.x = Math.cos( timer ) * 3; camera.position.z = Math.sin( timer ) * 3; camera.lookAt( cameraTarget ); renderer.render( scene, camera ); } "},{"title":"About","date":"2021-06-05T19:55:56.000Z","url":"/about/index.html","categories":[[" ",""]],"content":" new GDemo('#demo-teriminal') .openApp('terminal', {minHeight: '600px', windowTitle: '关于我', promptString: '👉'}) .command(`𐬿 人生就像一场戏，因为有缘才相聚。`, {onCompleteDelay: 900}).command(`𐬿 相扶到老不容易，是否更该去珍惜。`, {onCompleteDelay: 900}).command(`𐬿 为了小事发脾气，回头想想又何必。`, {onCompleteDelay: 900}).command(`𐬿 别人生气我不气，气出病来无人替。`, {onCompleteDelay: 900}).command(`𐬿 我若气死谁如意，况且伤神又费力。`, {onCompleteDelay: 900}).command(`𐬿 邻居亲朋不要比，儿孙琐事由他去。`, {onCompleteDelay: 900}).command(`𐬿 吃苦享乐在一起，神仙羡慕好伴侣。`, {onCompleteDelay: 900}).command(`哪人?`, {onCompleteDelay: 900}).command(`𐬿 山东济宁（浩克山东欢迎您）`, {onCompleteDelay: 900}).command(`住哪?`, {onCompleteDelay: 900}).command(`𐬿 浙江杭州（读本科）`, {onCompleteDelay: 900}).command(`专业?`, {onCompleteDelay: 900}).command(`𐬿 机械工程-智能制造`, {onCompleteDelay: 900}).command(`网站?`, {onCompleteDelay: 900}).command(`𐬿 兴趣、记录、倾诉`, {onCompleteDelay: 900}).command(`兴趣?`, {onCompleteDelay: 900}).command(`𐬿 数码`, {onCompleteDelay: 900}).command(`喜欢?`, {onCompleteDelay: 900}).command(`𐬿 罗小黑（不知道请百度）`, {onCompleteDelay: 900}).command(`QQ?`, {onCompleteDelay: 900}).command(`𐬿 1798923421`, {onCompleteDelay: 900}).command(`更多?`, {onCompleteDelay: 900}) .respond(`唉怪！白慌，傍黑告诉你！ （济宁方言）`) .end(); .timeline ul {margin:0;} .timeline ul li {background:#3b3d42;list-style-type:none;position:relative;width:3px;margin-left:0;padding:0.8em 0 2em;} .timeline ul li::after {transform: rotate(45deg);content:'';background-color: #3b3d42;display: block;position: absolute;top: 10px;left: -5px;width: 0.8em;height: 0.8em;outline: 15px solid #fff;} .timeline ul li div {position:relative;top:-13px;left:3em;width:600px;padding:0px 0px 0px;} .timeline ul li p.datatime{color: #fafafa;font-size: 0.75em;font-style: italic;background-color: #3b3d42;display: inline-block;padding:0.25em 1em 0.2em 1em;} .timeline ul li p.datacont{white-space: pre-wrap;margin:0.65em 0 0.3em;} .timeline ul li p.datacont img{display:block;max-height:340px !important;} .timeline ul li p.datacont img[src*=\"emotion\"]{display:inline-block;width:auto;} .timeline ul li p.datafrom{color: #aaa;font-size: 0.75em !important;font-style: italic;} .timeline ul li p{margin:0;font-size:16px;letter-spacing:1px;color: #3b3d42;} button{border-radius:0;} .dark-theme .timeline ul li div p{color:#fafafa;} .dark-theme .timeline ul li div p svg{fill:#fafafa;} .dark-theme .timeline ul li p.datafrom{color: #aaa;} .dark-theme .timeline ul li{background:#3b3d42;} .dark-theme .timeline ul li::after{outline: 15px solid #292a2d;} @media (max-width:860px) { .timeline ul li{margin-left:0;} .timeline ul li div{width:calc(100vw - 75px);left:30px;} } const app = cloudbase.init({ env: \"twikoo-3gls4obna5a0fbeb\", //这里是你的环境id region: \"ap-shanghai\" }) "},{"date":"2021-11-26T13:46:50.297Z","url":"/build/stats.js","categories":[[" ",""]],"content":"var Stats = function () { var mode = 0; var container = document.createElement( 'div' ); container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000'; container.addEventListener( 'click', function ( event ) { event.preventDefault(); showPanel( ++ mode % container.children.length ); }, false ); // function addPanel( panel ) { container.appendChild( panel.dom ); return panel; } function showPanel( id ) { for ( var i = 0; i < container.children.length; i ++ ) { container.children[ i ].style.display = i === id ? 'block' : 'none'; } mode = id; } // var beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0; var fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) ); var msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) ); if ( self.performance && self.performance.memory ) { var memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) ); } showPanel( 0 ); return { REVISION: 16, dom: container, addPanel: addPanel, showPanel: showPanel, begin: function () { beginTime = ( performance || Date ).now(); }, end: function () { frames ++; var time = ( performance || Date ).now(); msPanel.update( time - beginTime, 200 ); if ( time >= prevTime + 1000 ) { fpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 ); prevTime = time; frames = 0; if ( memPanel ) { var memory = performance.memory; memPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 ); } } return time; }, update: function () { beginTime = this.end(); }, // Backwards Compatibility domElement: container, setMode: showPanel }; }; Stats.Panel = function ( name, fg, bg ) { var min = Infinity, max = 0, round = Math.round; var PR = round( window.devicePixelRatio || 1 ); var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR; var canvas = document.createElement( 'canvas' ); canvas.width = WIDTH; canvas.height = HEIGHT; canvas.style.cssText = 'width:80px;height:48px'; var context = canvas.getContext( '2d' ); context.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif'; context.textBaseline = 'top'; context.fillStyle = bg; context.fillRect( 0, 0, WIDTH, HEIGHT ); context.fillStyle = fg; context.fillText( name, TEXT_X, TEXT_Y ); context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT ); context.fillStyle = bg; context.globalAlpha = 0.9; context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT ); return { dom: canvas, update: function ( value, maxValue ) { min = Math.min( min, value ); max = Math.max( max, value ); context.fillStyle = bg; context.globalAlpha = 1; context.fillRect( 0, 0, WIDTH, GRAPH_Y ); context.fillStyle = fg; context.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y ); context.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT ); context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT ); context.fillStyle = bg; context.globalAlpha = 0.9; context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) ); } }; }; export default Stats;"},{"date":"2021-11-26T13:46:50.297Z","url":"/build/stl.js","categories":[[" ",""]],"content":"import { BufferAttribute, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils, Vector3 } from '../../../build/three.module.js'; /** * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs. * * Supports both binary and ASCII encoded files, with automatic detection of type. * * The loader returns a non-indexed buffer geometry. * * Limitations: * Binary decoding supports \"Magics\" color format ((file_format)#Color_in_binary_STL). * There is perhaps some question as to how valid it is to always assume little-endian-ness. * ASCII decoding assumes file is UTF-8. * * Usage: * const loader = new STLLoader(); * loader.load( './models/stl/slotted_disk.stl', function ( geometry ) { * scene.add( new THREE.Mesh( geometry ) ); * }); * * For binary STLs geometry might contain colors for vertices. To use it: * // use the same code to load STL as above * if (geometry.hasColors) { * material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true }); * } else { .... } * const mesh = new THREE.Mesh( geometry, material ); * * For ASCII STLs containing multiple solids, each solid is assigned to a different group. * Groups can be used to assign a different color by defining an array of materials with the same length of * geometry.groups and passing it to the Mesh constructor: * * const mesh = new THREE.Mesh( geometry, material ); * * For example: * * const materials = []; * const nGeometryGroups = geometry.groups.length; * * const colorMap = ...; // Some logic to index colors. * * for (let i = 0; i < nGeometryGroups; i++) { * * const material = new THREE.MeshPhongMaterial({ * color: colorMap[i], * wireframe: false * }); * * } * * materials.push(material); * const mesh = new THREE.Mesh(geometry, materials); */ class STLLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { function isBinary( data ) { const reader = new DataView( data ); const face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 ); const n_faces = reader.getUint32( 80, true ); const expect = 80 + ( 32 / 8 ) + ( n_faces * face_size ); if ( expect === reader.byteLength ) { return true; } // An ASCII STL data must begin with 'solid ' as the first six bytes. // However, ASCII STLs lacking the SPACE after the 'd' are known to be // plentiful. So, check the first 5 bytes for 'solid'. // Several encodings, such as UTF-8, precede the text with up to 5 bytes: //  // Search for \"solid\" to start anywhere after those prefixes. // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd' const solid = [ 115, 111, 108, 105, 100 ]; for ( let off = 0; off < 5; off ++ ) { // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL. if ( matchDataViewAt( solid, reader, off ) ) return false; } // Couldn't find \"solid\" text at the beginning; it is binary STL. return true; } function matchDataViewAt( query, reader, offset ) { // Check if each byte in query matches the corresponding byte from the current offset for ( let i = 0, il = query.length; i < il; i ++ ) { if ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false; } return true; } function parseBinary( data ) { const reader = new DataView( data ); const faces = reader.getUint32( 80, true ); let r, g, b, hasColors = false, colors; let defaultR, defaultG, defaultB, alpha; // process STL header // check for default color in header (\"COLOR=rgba\" sequence). for ( let index = 0; index < 80 - 10; index ++ ) { if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) && ( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) && ( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) { hasColors = true; colors = new Float32Array( faces * 3 * 3 ); defaultR = reader.getUint8( index + 6 ) / 255; defaultG = reader.getUint8( index + 7 ) / 255; defaultB = reader.getUint8( index + 8 ) / 255; alpha = reader.getUint8( index + 9 ) / 255; } } const dataOffset = 84; const faceLength = 12 * 4 + 2; const geometry = new BufferGeometry(); const vertices = new Float32Array( faces * 3 * 3 ); const normals = new Float32Array( faces * 3 * 3 ); for ( let face = 0; face < faces; face ++ ) { const start = dataOffset + face * faceLength; const normalX = reader.getFloat32( start, true ); const normalY = reader.getFloat32( start + 4, true ); const normalZ = reader.getFloat32( start + 8, true ); if ( hasColors ) { const packedColor = reader.getUint16( start + 48, true ); if ( ( packedColor & 0x8000 ) === 0 ) { // facet has its own unique color r = ( packedColor & 0x1F ) / 31; g = ( ( packedColor >> 5 ) & 0x1F ) / 31; b = ( ( packedColor >> 10 ) & 0x1F ) / 31; } else { r = defaultR; g = defaultG; b = defaultB; } } for ( let i = 1; i "},{"title":"categories","date":"2021-10-04T22:21:08.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"friend","date":"2021-10-04T22:21:52.000Z","url":"/friends/index.html","categories":[[" ",""]],"content":" new GDemo('#demo-teriminal') .openApp('terminal', {minHeight: '200px', windowTitle: '我的链接', promptString: '👉'}) .command(`- name: WXY`, {onCompleteDelay: 200}).command(`url: `, {onCompleteDelay: 200}).command(`avatar:  `, {onCompleteDelay: 200}).command(`desc: 时间不在于你拥有多少，而在于你如何使用!`, {onCompleteDelay: 200}) .respond(`none`) .end(); "},{"title":"Movies","date":"2021-06-05T19:55:56.000Z","url":"/movie/index.html","categories":[[" ",""]],"content":"精挑细选，值得推荐的电影，排名不分先后。 白蛇：缘起2019，黄家康95分钟爱情，动画，奇幻晚唐年间，国师发动⺠众⼤量捕蛇。前去刺杀国师的⽩蛇意外失忆，被捕蛇村少年救下。为帮助少⼥找回记忆，两⼈踏上了⼀段冒险旅程。冒险的过程让两⼈感情迅速升温，但少⼥蛇妖的身份也逐渐显露，另⼀边国师与蛇族之间不可避免的⼤战也即将打响，两⼈的爱情将要接受巨⼤考验。 12 白蛇2：青蛇劫起2021，黄家康131分钟动画，动作，奇幻，冒险南宋末年，小白为救许仙水漫金山，终被法海压在雷峰塔下。小青则意外被法海打入诡异的修罗城幻境。几次危机中小青被神秘蒙面少年所救，小青带着出去救出小白的执念历经劫难与成长，同蒙面少年一起寻找离开的办法。 12 肖申克的救赎1994，弗兰克·德拉邦特142分钟剧情20世纪40年代末，小有成就的青年银行家安迪（蒂姆·罗宾斯 饰）因涉嫌杀害妻子及她的情人而锒铛入狱。在这座名为肖申克的监狱内，希望似乎虚无缥缈，终身监禁的惩罚无疑注定了安迪接下来灰暗绝望的人生。未过多久，安迪尝试接近囚犯中颇有声望的瑞德（摩根·弗里曼 饰），请求对方帮自己搞来小锤子。以此为契机，二人逐渐熟稔，安迪也仿佛在鱼龙混杂、罪恶横生、黑白混淆的牢狱中找到属于自己的求生之道。他利用自身的专业知识，帮助监狱管理层逃税、洗黑钱，同时凭借与瑞德的交往在犯人中间也渐渐受到礼遇。表面看来，他已如瑞德那样对那堵高墙从憎恨转变为处之泰然，但是对自由的渴望仍促使他朝着心中的希望和目标前进。而关于其罪行的真相，似乎更使这一切朝前推进了一步……"},{"title":"search","date":"2021-10-04T22:20:44.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2021-10-04T22:20:59.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"Toys","date":"2021-11-15T19:55:56.000Z","url":"/toys/index.html","categories":[[" ",""]],"content":"这些年来做的小玩具、小项目，也是一个回忆录。 NPM自动化工具 Feature npm 图床自动化 自动更新npm包版本 自动获取最新npm包版本并替换文件中的jsd链接 自动推送图床仓库 只需配置一次 配置文件config.ini可修改 后续有时间再去加功能 自动喷淋系统上位机2021.11 MFC 视频里的程序就是我写的啦 当然还要感谢指导老师的帮助。 还有我画的PCB，很丑，能用就行系列~~~能不能用也不好说~~~。 自动布线，比较杂乱。 折腾服务器2021.11 双11买了三年服务器 这两个项目我只是搭建并没有进行任何修改。 code - server线上编辑器（可以跑程序的） qq机器人玩一下，很开心 学什么？MFC 2021.9写的，解决选择困难症 代码很简单，但很实用。 下载链接 2.0 是在1.0的基础上增加更多内容，但因为后来用不上就没有继续开发 2021.10 吃什么，学什么 这是一个网页，也是为了解决选择困难症 第二个个人网站2021.9也就是现在这个了，换了域名，改了主题。 简单 大方 我的主页2021.8 主页 很显然，不是我原创，是在巨人的肩膀上改的。做了移动端适配，虽然还有bug但问题不大 url - md2021.7 python tkinter 文本 小工具 发在了52 还被列成置顶，也是没想到，非常开心。 52 仓库 快乐星球2021.3-2021.8 搭建的第一个网站/博客 5.0 5.0 就是分站的样子啦！ 4.0 开始搞玻璃效果，确实好看。背景也不错。 而且还折腾出来了自动打开侧边栏效果。 挺费劲的 3.0 这个版本应该是比较好看的，而且也很简洁 动效该在的也在，这好像是7月底的版本 还有罗小黑，安装方法见这篇文章 2.0 开始自己折腾加载动画，还有冰球背景 1.02021.3-2021.7 发布的第一个release 那会刚开始折腾，网站还是很简洁的。 平面三轴机械臂2021.5 Feature： 根据坐标及姿态计算物块位置和合适的抓取角度 通过opencv模块进行视觉识别，计算物块的四个端点及其偏转角度 通过计算对应颜色像素点的数量计算叶片面积 支持摄像头拍摄图片和文件导入 DIY2021.3 自己比较满意的作品 原材料： 小米平面无线充电器 一次性筷子 502 "},{"date":"2021-11-26T13:46:50.305Z","url":"/build/three.module.js","categories":[[" ",""]],"content":"/** * @license * Copyright 2010-2021 Three.js Authors * SPDX-License-Identifier: MIT */ const REVISION = '135'; const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }; const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }; const CullFaceNone = 0; const CullFaceBack = 1; const CullFaceFront = 2; const CullFaceFrontBack = 3; const BasicShadowMap = 0; const PCFShadowMap = 1; const PCFSoftShadowMap = 2; const VSMShadowMap = 3; const FrontSide = 0; const BackSide = 1; const DoubleSide = 2; const FlatShading = 1; const SmoothShading = 2; const NoBlending = 0; const NormalBlending = 1; const AdditiveBlending = 2; const SubtractiveBlending = 3; const MultiplyBlending = 4; const CustomBlending = 5; const AddEquation = 100; const SubtractEquation = 101; const ReverseSubtractEquation = 102; const MinEquation = 103; const MaxEquation = 104; const ZeroFactor = 200; const OneFactor = 201; const SrcColorFactor = 202; const OneMinusSrcColorFactor = 203; const SrcAlphaFactor = 204; const OneMinusSrcAlphaFactor = 205; const DstAlphaFactor = 206; const OneMinusDstAlphaFactor = 207; const DstColorFactor = 208; const OneMinusDstColorFactor = 209; const SrcAlphaSaturateFactor = 210; const NeverDepth = 0; const AlwaysDepth = 1; const LessDepth = 2; const LessEqualDepth = 3; const EqualDepth = 4; const GreaterEqualDepth = 5; const GreaterDepth = 6; const NotEqualDepth = 7; const MultiplyOperation = 0; const MixOperation = 1; const AddOperation = 2; const NoToneMapping = 0; const LinearToneMapping = 1; const ReinhardToneMapping = 2; const CineonToneMapping = 3; const ACESFilmicToneMapping = 4; const CustomToneMapping = 5; const UVMapping = 300; const CubeReflectionMapping = 301; const CubeRefractionMapping = 302; const EquirectangularReflectionMapping = 303; const EquirectangularRefractionMapping = 304; const CubeUVReflectionMapping = 306; const CubeUVRefractionMapping = 307; const RepeatWrapping = 1000; const ClampToEdgeWrapping = 1001; const MirroredRepeatWrapping = 1002; const NearestFilter = 1003; const NearestMipmapNearestFilter = 1004; const NearestMipMapNearestFilter = 1004; const NearestMipmapLinearFilter = 1005; const NearestMipMapLinearFilter = 1005; const LinearFilter = 1006; const LinearMipmapNearestFilter = 1007; const LinearMipMapNearestFilter = 1007; const LinearMipmapLinearFilter = 1008; const LinearMipMapLinearFilter = 1008; const UnsignedByteType = 1009; const ByteType = 1010; const ShortType = 1011; const UnsignedShortType = 1012; const IntType = 1013; const UnsignedIntType = 1014; const FloatType = 1015; const HalfFloatType = 1016; const UnsignedShort4444Type = 1017; const UnsignedShort5551Type = 1018; const UnsignedShort565Type = 1019; const UnsignedInt248Type = 1020; const AlphaFormat = 1021; const RGBFormat = 1022; const RGBAFormat = 1023; const LuminanceFormat = 1024; const LuminanceAlphaFormat = 1025; const RGBEFormat = RGBAFormat; const DepthFormat = 1026; const DepthStencilFormat = 1027; const RedFormat = 1028; const RedIntegerFormat = 1029; const RGFormat = 1030; const RGIntegerFormat = 1031; const RGBIntegerFormat = 1032; const RGBAIntegerFormat = 1033; const RGB_S3TC_DXT1_Format = 33776; const RGBA_S3TC_DXT1_Format = 33777; const RGBA_S3TC_DXT3_Format = 33778; const RGBA_S3TC_DXT5_Format = 33779; const RGB_PVRTC_4BPPV1_Format = 35840; const RGB_PVRTC_2BPPV1_Format = 35841; const RGBA_PVRTC_4BPPV1_Format = 35842; const RGBA_PVRTC_2BPPV1_Format = 35843; const RGB_ETC1_Format = 36196; const RGB_ETC2_Format = 37492; const RGBA_ETC2_EAC_Format = 37496; const RGBA_ASTC_4x4_Format = 37808; const RGBA_ASTC_5x4_Format = 37809; const RGBA_ASTC_5x5_Format = 37810; const RGBA_ASTC_6x5_Format = 37811; const RGBA_ASTC_6x6_Format = 37812; const RGBA_ASTC_8x5_Format = 37813; const RGBA_ASTC_8x6_Format = 37814; const RGBA_ASTC_8x8_Format = 37815; const RGBA_ASTC_10x5_Format = 37816; const RGBA_ASTC_10x6_Format = 37817; const RGBA_ASTC_10x8_Format = 37818; const RGBA_ASTC_10x10_Format = 37819; const RGBA_ASTC_12x10_Format = 37820; const RGBA_ASTC_12x12_Format = 37821; const RGBA_BPTC_Format = 36492; const SRGB8_ALPHA8_ASTC_4x4_Format = 37840; const SRGB8_ALPHA8_ASTC_5x4_Format = 37841; const SRGB8_ALPHA8_ASTC_5x5_Format = 37842; const SRGB8_ALPHA8_ASTC_6x5_Format = 37843; const SRGB8_ALPHA8_ASTC_6x6_Format = 37844; const SRGB8_ALPHA8_ASTC_8x5_Format = 37845; const SRGB8_ALPHA8_ASTC_8x6_Format = 37846; const SRGB8_ALPHA8_ASTC_8x8_Format = 37847; const SRGB8_ALPHA8_ASTC_10x5_Format = 37848; const SRGB8_ALPHA8_ASTC_10x6_Format = 37849; const SRGB8_ALPHA8_ASTC_10x8_Format = 37850; const SRGB8_ALPHA8_ASTC_10x10_Format = 37851; const SRGB8_ALPHA8_ASTC_12x10_Format = 37852; const SRGB8_ALPHA8_ASTC_12x12_Format = 37853; const LoopOnce = 2200; const LoopRepeat = 2201; const LoopPingPong = 2202; const InterpolateDiscrete = 2300; const InterpolateLinear = 2301; const InterpolateSmooth = 2302; const ZeroCurvatureEnding = 2400; const ZeroSlopeEnding = 2401; const WrapAroundEnding = 2402; const NormalAnimationBlendMode = 2500; const AdditiveAnimationBlendMode = 2501; const TrianglesDrawMode = 0; const TriangleStripDrawMode = 1; const TriangleFanDrawMode = 2; const LinearEncoding = 3000; const sRGBEncoding = 3001; const GammaEncoding = 3007; const RGBEEncoding = 3002; const RGBM7Encoding = 3004; const RGBM16Encoding = 3005; const RGBDEncoding = 3006; const BasicDepthPacking = 3200; const RGBADepthPacking = 3201; const TangentSpaceNormalMap = 0; const ObjectSpaceNormalMap = 1; const ZeroStencilOp = 0; const KeepStencilOp = 7680; const ReplaceStencilOp = 7681; const IncrementStencilOp = 7682; const DecrementStencilOp = 7683; const IncrementWrapStencilOp = 34055; const DecrementWrapStencilOp = 34056; const InvertStencilOp = 5386; const NeverStencilFunc = 512; const LessStencilFunc = 513; const EqualStencilFunc = 514; const LessEqualStencilFunc = 515; const GreaterStencilFunc = 516; const NotEqualStencilFunc = 517; const GreaterEqualStencilFunc = 518; const AlwaysStencilFunc = 519; const StaticDrawUsage = 35044; const DynamicDrawUsage = 35048; const StreamDrawUsage = 35040; const StaticReadUsage = 35045; const DynamicReadUsage = 35049; const StreamReadUsage = 35041; const StaticCopyUsage = 35046; const DynamicCopyUsage = 35050; const StreamCopyUsage = 35042; const GLSL1 = '100'; const GLSL3 = '300 es'; /** *  */ class EventDispatcher { addEventListener( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; const listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } } hasEventListener( type, listener ) { if ( this._listeners === undefined ) return false; const listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; } removeEventListener( type, listener ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { const index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } } dispatchEvent( event ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; // Make a copy, in case listeners are removed while iterating. const array = listenerArray.slice( 0 ); for ( let i = 0, l = array.length; i < l; i ++ ) { array[ i ].call( this, event ); } event.target = null; } } } const _lut = []; for ( let i = 0; i < 256; i ++ ) { _lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ); } let _seed = 1234567; const DEG2RAD = Math.PI / 180; const RAD2DEG = 180 / Math.PI; //  function generateUUID() { const d0 = Math.random() * 0xffffffff | 0; const d1 = Math.random() * 0xffffffff | 0; const d2 = Math.random() * 0xffffffff | 0; const d3 = Math.random() * 0xffffffff | 0; const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' + _lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' + _lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] + _lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ]; // .toUpperCase() here flattens concatenated strings to save heap memory space. return uuid.toUpperCase(); } function clamp( value, min, max ) { return Math.max( min, Math.min( max, value ) ); } // compute euclidian modulo of m % n //  function euclideanModulo( n, m ) { return ( ( n % m ) + m ) % m; } // Linear mapping from range to range function mapLinear( x, a1, a2, b1, b2 ) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); } //  function inverseLerp( x, y, value ) { if ( x !== y ) { return ( value - x ) / ( y - x ); } else { return 0; } } //  function lerp( x, y, t ) { return ( 1 - t ) * x + t * y; } //  function damp( x, y, lambda, dt ) { return lerp( x, y, 1 - Math.exp( - lambda * dt ) ); } //  function pingpong( x, length = 1 ) { return length - Math.abs( euclideanModulo( x, length * 2 ) - length ); } //  function smoothstep( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * ( 3 - 2 * x ); } function smootherstep( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * x * ( x * ( x * 6 - 15 ) + 10 ); } // Random integer from interval function randInt( low, high ) { return low + Math.floor( Math.random() * ( high - low + 1 ) ); } // Random float from interval function randFloat( low, high ) { return low + Math.random() * ( high - low ); } // Random float from interval function randFloatSpread( range ) { return range * ( 0.5 - Math.random() ); } // Deterministic pseudo-random float in the interval [ 0, 1 ] function seededRandom( s ) { if ( s !== undefined ) _seed = s % 2147483647; // Park-Miller algorithm _seed = _seed * 16807 % 2147483647; return ( _seed - 1 ) / 2147483646; } function degToRad( degrees ) { return degrees * DEG2RAD; } function radToDeg( radians ) { return radians * RAD2DEG; } function isPowerOfTwo( value ) { return ( value & ( value - 1 ) ) === 0 && value !== 0; } function ceilPowerOfTwo( value ) { return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) ); } function floorPowerOfTwo( value ) { return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) ); } function setQuaternionFromProperEuler( q, a, b, c, order ) { // Intrinsic Proper Euler Angles - see  // rotations are applied to the axes in the order specified by 'order' // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c' // angles are in radians const cos = Math.cos; const sin = Math.sin; const c2 = cos( b / 2 ); const s2 = sin( b / 2 ); const c13 = cos( ( a + c ) / 2 ); const s13 = sin( ( a + c ) / 2 ); const c1_3 = cos( ( a - c ) / 2 ); const s1_3 = sin( ( a - c ) / 2 ); const c3_1 = cos( ( c - a ) / 2 ); const s3_1 = sin( ( c - a ) / 2 ); switch ( order ) { case 'XYX': q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 ); break; case 'YZY': q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 ); break; case 'ZXZ': q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 ); break; case 'XZX': q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 ); break; case 'YXY': q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 ); break; case 'ZYZ': q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 ); break; default: console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order ); } } var MathUtils = /*#__PURE__*/Object.freeze({ __proto__: null, DEG2RAD: DEG2RAD, RAD2DEG: RAD2DEG, generateUUID: generateUUID, clamp: clamp, euclideanModulo: euclideanModulo, mapLinear: mapLinear, inverseLerp: inverseLerp, lerp: lerp, damp: damp, pingpong: pingpong, smoothstep: smoothstep, smootherstep: smootherstep, randInt: randInt, randFloat: randFloat, randFloatSpread: randFloatSpread, seededRandom: seededRandom, degToRad: degToRad, radToDeg: radToDeg, isPowerOfTwo: isPowerOfTwo, ceilPowerOfTwo: ceilPowerOfTwo, floorPowerOfTwo: floorPowerOfTwo, setQuaternionFromProperEuler: setQuaternionFromProperEuler }); class Vector2 { constructor( x = 0, y = 0 ) { this.x = x; this.y = y; } get width() { return this.x; } set width( value ) { this.x = value; } get height() { return this.y; } set height( value ) { this.y = value; } set( x, y ) { this.x = x; this.y = y; return this; } setScalar( scalar ) { this.x = scalar; this.y = scalar; return this; } setX( x ) { this.x = x; return this; } setY( y ) { this.y = y; return this; } setComponent( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; } getComponent( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; default: throw new Error( 'index is out of range: ' + index ); } } clone() { return new this.constructor( this.x, this.y ); } copy( v ) { this.x = v.x; this.y = v.y; return this; } add( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; return this; } addScalar( s ) { this.x += s; this.y += s; return this; } addVectors( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; return this; } addScaledVector( v, s ) { this.x += v.x * s; this.y += v.y * s; return this; } sub( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; return this; } subScalar( s ) { this.x -= s; this.y -= s; return this; } subVectors( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; return this; } multiply( v ) { this.x *= v.x; this.y *= v.y; return this; } multiplyScalar( scalar ) { this.x *= scalar; this.y *= scalar; return this; } divide( v ) { this.x /= v.x; this.y /= v.y; return this; } divideScalar( scalar ) { return this.multiplyScalar( 1 / scalar ); } applyMatrix3( m ) { const x = this.x, y = this.y; const e = m.elements; this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ]; this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ]; return this; } min( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); return this; } max( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); return this; } clamp( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); return this; } clampScalar( minVal, maxVal ) { this.x = Math.max( minVal, Math.min( maxVal, this.x ) ); this.y = Math.max( minVal, Math.min( maxVal, this.y ) ); return this; } clampLength( min, max ) { const length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); } floor() { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); return this; } ceil() { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); return this; } round() { this.x = Math.round( this.x ); this.y = Math.round( this.y ); return this; } roundToZero() { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); return this; } negate() { this.x = - this.x; this.y = - this.y; return this; } dot( v ) { return this.x * v.x + this.y * v.y; } cross( v ) { return this.x * v.y - this.y * v.x; } lengthSq() { return this.x * this.x + this.y * this.y; } length() { return Math.sqrt( this.x * this.x + this.y * this.y ); } manhattanLength() { return Math.abs( this.x ) + Math.abs( this.y ); } normalize() { return this.divideScalar( this.length() || 1 ); } angle() { // computes the angle in radians with respect to the positive x-axis const angle = Math.atan2( - this.y, - this.x ) + Math.PI; return angle; } distanceTo( v ) { return Math.sqrt( this.distanceToSquared( v ) ); } distanceToSquared( v ) { const dx = this.x - v.x, dy = this.y - v.y; return dx * dx + dy * dy; } manhattanDistanceTo( v ) { return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ); } setLength( length ) { return this.normalize().multiplyScalar( length ); } lerp( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; return this; } lerpVectors( v1, v2, alpha ) { this.x = v1.x + ( v2.x - v1.x ) * alpha; this.y = v1.y + ( v2.y - v1.y ) * alpha; return this; } equals( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) ); } fromArray( array, offset = 0 ) { this.x = array[ offset ]; this.y = array[ offset + 1 ]; return this; } toArray( array = [], offset = 0 ) { array[ offset ] = this.x; array[ offset + 1 ] = this.y; return array; } fromBufferAttribute( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); return this; } rotateAround( center, angle ) { const c = Math.cos( angle ), s = Math.sin( angle ); const x = this.x - center.x; const y = this.y - center.y; this.x = x * c - y * s + center.x; this.y = x * s + y * c + center.y; return this; } random() { this.x = Math.random(); this.y = Math.random(); return this; } *[ Symbol.iterator ]() { yield this.x; yield this.y; } } Vector2.prototype.isVector2 = true; class Matrix3 { constructor() { this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]; if ( arguments.length > 0 ) { console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' ); } } set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { const te = this.elements; te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31; te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32; te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33; return this; } identity() { this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ); return this; } copy( m ) { const te = this.elements; const me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; return this; } extractBasis( xAxis, yAxis, zAxis ) { xAxis.setFromMatrix3Column( this, 0 ); yAxis.setFromMatrix3Column( this, 1 ); zAxis.setFromMatrix3Column( this, 2 ); return this; } setFromMatrix4( m ) { const me = m.elements; this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] ); return this; } multiply( m ) { return this.multiplyMatrices( this, m ); } premultiply( m ) { return this.multiplyMatrices( m, this ); } multiplyMatrices( a, b ) { const ae = a.elements; const be = b.elements; const te = this.elements; const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ]; const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ]; const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ]; const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ]; const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ]; const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31; te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32; te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31; te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32; te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31; te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32; te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33; return this; } multiplyScalar( s ) { const te = this.elements; te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s; te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s; te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s; return this; } determinant() { const te = this.elements; const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ], d = te[ 3 ], e = te[ 4 ], f = te[ 5 ], g = te[ 6 ], h = te[ 7 ], i = te[ 8 ]; return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g; } invert() { const te = this.elements, n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ], n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13; if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); const detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv; te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv; te[ 3 ] = t12 * detInv; te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv; te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv; te[ 6 ] = t13 * detInv; te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv; te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv; return this; } transpose() { let tmp; const m = this.elements; tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp; tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp; tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp; return this; } getNormalMatrix( matrix4 ) { return this.setFromMatrix4( matrix4 ).invert().transpose(); } transposeIntoArray( r ) { const m = this.elements; r[ 0 ] = m[ 0 ]; r[ 1 ] = m[ 3 ]; r[ 2 ] = m[ 6 ]; r[ 3 ] = m[ 1 ]; r[ 4 ] = m[ 4 ]; r[ 5 ] = m[ 7 ]; r[ 6 ] = m[ 2 ]; r[ 7 ] = m[ 5 ]; r[ 8 ] = m[ 8 ]; return this; } setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) { const c = Math.cos( rotation ); const s = Math.sin( rotation ); this.set( sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0, 0, 1 ); return this; } scale( sx, sy ) { const te = this.elements; te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx; te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy; return this; } rotate( theta ) { const c = Math.cos( theta ); const s = Math.sin( theta ); const te = this.elements; const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ]; const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ]; te[ 0 ] = c * a11 + s * a21; te[ 3 ] = c * a12 + s * a22; te[ 6 ] = c * a13 + s * a23; te[ 1 ] = - s * a11 + c * a21; te[ 4 ] = - s * a12 + c * a22; te[ 7 ] = - s * a13 + c * a23; return this; } translate( tx, ty ) { const te = this.elements; te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ]; te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ]; return this; } equals( matrix ) { const te = this.elements; const me = matrix.elements; for ( let i = 0; i < 9; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; } fromArray( array, offset = 0 ) { for ( let i = 0; i < 9; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; } toArray( array = [], offset = 0 ) { const te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; return array; } clone() { return new this.constructor().fromArray( this.elements ); } } Matrix3.prototype.isMatrix3 = true; function arrayMax( array ) { if ( array.length === 0 ) return - Infinity; let max = array[ 0 ]; for ( let i = 1, l = array.length; i < l; ++ i ) { if ( array[ i ] > max ) max = array[ i ]; } return max; } const TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function getTypedArray( type, buffer ) { return new TYPED_ARRAYS[ type ]( buffer ); } function createElementNS( name ) { return document.createElementNS( '', name ); } /** * cyrb53 hash for string from:  * * Public Domain, @bryc -  * * It is roughly similar to the well-known MurmurHash/xxHash algorithms. It uses a combination * of multiplication and Xorshift to generate the hash, but not as thorough. As a result it's * faster than either would be in JavaScript and significantly simpler to implement. Keep in * mind this is not a secure algorithm, if privacy/security is a concern, this is not for you. * * @param {string} str * @param {number} seed, default 0 * @returns number */ function hashString( str, seed = 0 ) { let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed; for ( let i = 0, ch; i < str.length; i ++ ) { ch = str.charCodeAt( i ); h1 = Math.imul( h1 ^ ch, 2654435761 ); h2 = Math.imul( h2 ^ ch, 1597334677 ); } h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 ) ^ Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 ); h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 ) ^ Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 ); return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 ); } let _canvas; class ImageUtils { static getDataURL( image ) { if ( /^data:/i.test( image.src ) ) { return image.src; } if ( typeof HTMLCanvasElement == 'undefined' ) { return image.src; } let canvas; if ( image instanceof HTMLCanvasElement ) { canvas = image; } else { if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' ); _canvas.width = image.width; _canvas.height = image.height; const context = _canvas.getContext( '2d' ); if ( image instanceof ImageData ) { context.putImageData( image, 0, 0 ); } else { context.drawImage( image, 0, 0, image.width, image.height ); } canvas = _canvas; } if ( canvas.width > 2048 || canvas.height > 2048 ) { console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image ); return canvas.toDataURL( 'image/jpeg', 0.6 ); } else { return canvas.toDataURL( 'image/png' ); } } } let textureId = 0; class Texture extends EventDispatcher { constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) { super(); Object.defineProperty( this, 'id', { value: textureId ++ } ); this.uuid = generateUUID(); this.name = ''; this.image = image; this.mipmaps = []; this.mapping = mapping; this.wrapS = wrapS; this.wrapT = wrapT; this.magFilter = magFilter; this.minFilter = minFilter; this.anisotropy = anisotropy; this.format = format; this.internalFormat = null; this.type = type; this.offset = new Vector2( 0, 0 ); this.repeat = new Vector2( 1, 1 ); this.center = new Vector2( 0, 0 ); this.rotation = 0; this.matrixAutoUpdate = true; this.matrix = new Matrix3(); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see ) // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap. // // Also changing the encoding after already used by a Material will not automatically make the Material // update. You need to explicitly call Material.needsUpdate to trigger it to recompile. this.encoding = encoding; this.userData = {}; this.version = 0; this.onUpdate = null; this.isRenderTargetTexture = false; } updateMatrix() { this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y ); } clone() { return new this.constructor().copy( this ); } copy( source ) { this.name = source.name; this.image = source.image; this.mipmaps = source.mipmaps.slice( 0 ); this.mapping = source.mapping; this.wrapS = source.wrapS; this.wrapT = source.wrapT; this.magFilter = source.magFilter; this.minFilter = source.minFilter; this.anisotropy = source.anisotropy; this.format = source.format; this.internalFormat = source.internalFormat; this.type = source.type; this.offset.copy( source.offset ); this.repeat.copy( source.repeat ); this.center.copy( source.center ); this.rotation = source.rotation; this.matrixAutoUpdate = source.matrixAutoUpdate; this.matrix.copy( source.matrix ); this.generateMipmaps = source.generateMipmaps; this.premultiplyAlpha = source.premultiplyAlpha; this.flipY = source.flipY; this.unpackAlignment = source.unpackAlignment; this.encoding = source.encoding; this.userData = JSON.parse( JSON.stringify( source.userData ) ); return this; } toJSON( meta ) { const isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) { return meta.textures[ this.uuid ]; } const output = { metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( this.image !== undefined ) { // TODO: Move to THREE.Image const image = this.image; if ( image.uuid === undefined ) { image.uuid = generateUUID(); // UGH } if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) { let url; if ( Array.isArray( image ) ) { // process array of images e.g. CubeTexture url = []; for ( let i = 0, l = image.length; i < l; i ++ ) { // check cube texture with data textures if ( image[ i ].isDataTexture ) { url.push( serializeImage( image[ i ].image ) ); } else { url.push( serializeImage( image[ i ] ) ); } } } else { // process single image url = serializeImage( image ); } meta.images[ image.uuid ] = { uuid: image.uuid, url: url }; } output.image = image.uuid; } if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData; if ( ! isRootObject ) { meta.textures[ this.uuid ] = output; } return output; } dispose() { this.dispatchEvent( { type: 'dispose' } ); } transformUv( uv ) { if ( this.mapping !== UVMapping ) return uv; uv.applyMatrix3( this.matrix ); if ( uv.x < 0 || uv.x > 1 ) { switch ( this.wrapS ) { case RepeatWrapping: uv.x = uv.x - Math.floor( uv.x ); break; case ClampToEdgeWrapping: uv.x = uv.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) { uv.x = Math.ceil( uv.x ) - uv.x; } else { uv.x = uv.x - Math.floor( uv.x ); } break; } } if ( uv.y < 0 || uv.y > 1 ) { switch ( this.wrapT ) { case RepeatWrapping: uv.y = uv.y - Math.floor( uv.y ); break; case ClampToEdgeWrapping: uv.y = uv.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) { uv.y = Math.ceil( uv.y ) - uv.y; } else { uv.y = uv.y - Math.floor( uv.y ); } break; } } if ( this.flipY ) { uv.y = 1 - uv.y; } return uv; } set needsUpdate( value ) { if ( value === true ) this.version ++; } } Texture.DEFAULT_IMAGE = undefined; Texture.DEFAULT_MAPPING = UVMapping; Texture.prototype.isTexture = true; function serializeImage( image ) { if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) || ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) || ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) { // default images return ImageUtils.getDataURL( image ); } else { if ( image.data ) { // images of DataTexture return { data: Array.prototype.slice.call( image.data ), width: image.width, height: image.height, type: image.data.constructor.name }; } else { console.warn( 'THREE.Texture: Unable to serialize Texture.' ); return {}; } } } class Vector4 { constructor( x = 0, y = 0, z = 0, w = 1 ) { this.x = x; this.y = y; this.z = z; this.w = w; } get width() { return this.z; } set width( value ) { this.z = value; } get height() { return this.w; } set height( value ) { this.w = value; } set( x, y, z, w ) { this.x = x; this.y = y; this.z = z; this.w = w; return this; } setScalar( scalar ) { this.x = scalar; this.y = scalar; this.z = scalar; this.w = scalar; return this; } setX( x ) { this.x = x; return this; } setY( y ) { this.y = y; return this; } setZ( z ) { this.z = z; return this; } setW( w ) { this.w = w; return this; } setComponent( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; case 3: this.w = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; } getComponent( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error( 'index is out of range: ' + index ); } } clone() { return new this.constructor( this.x, this.y, this.z, this.w ); } copy( v ) { this.x = v.x; this.y = v.y; this.z = v.z; this.w = ( v.w !== undefined ) ? v.w : 1; return this; } add( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; this.z += v.z; this.w += v.w; return this; } addScalar( s ) { this.x += s; this.y += s; this.z += s; this.w += s; return this; } addVectors( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; } addScaledVector( v, s ) { this.x += v.x * s; this.y += v.y * s; this.z += v.z * s; this.w += v.w * s; return this; } sub( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; this.z -= v.z; this.w -= v.w; return this; } subScalar( s ) { this.x -= s; this.y -= s; this.z -= s; this.w -= s; return this; } subVectors( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; } multiply( v ) { this.x *= v.x; this.y *= v.y; this.z *= v.z; this.w *= v.w; return this; } multiplyScalar( scalar ) { this.x *= scalar; this.y *= scalar; this.z *= scalar; this.w *= scalar; return this; } applyMatrix4( m ) { const x = this.x, y = this.y, z = this.z, w = this.w; const e = m.elements; this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w; this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w; this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w; this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w; return this; } divideScalar( scalar ) { return this.multiplyScalar( 1 / scalar ); } setAxisAngleFromQuaternion( q ) { //  // q is assumed to be normalized this.w = 2 * Math.acos( q.w ); const s = Math.sqrt( 1 - q.w * q.w ); if ( s < 0.0001 ) { this.x = 1; this.y = 0; this.z = 0; } else { this.x = q.x / s; this.y = q.y / s; this.z = q.z / s; } return this; } setAxisAngleFromRotationMatrix( m ) { //  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) let angle, x, y, z; // variables for result const epsilon = 0.01, // margin to allow for rounding errors epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ]; if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) { // singularity found // first check for identity matrix which must have +1 for all terms // in leading diagonal and zero in other terms if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) { // this singularity is identity matrix so angle = 0 this.set( 1, 0, 0, 0 ); return this; // zero angle, arbitrary axis } // otherwise this singularity is angle = 180 angle = Math.PI; const xx = ( m11 + 1 ) / 2; const yy = ( m22 + 1 ) / 2; const zz = ( m33 + 1 ) / 2; const xy = ( m12 + m21 ) / 4; const xz = ( m13 + m31 ) / 4; const yz = ( m23 + m32 ) / 4; if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term if ( xx < epsilon ) { x = 0; y = 0.707106781; z = 0.707106781; } else { x = Math.sqrt( xx ); y = xy / x; z = xz / x; } } else if ( yy > zz ) { // m22 is the largest diagonal term if ( yy < epsilon ) { x = 0.707106781; y = 0; z = 0.707106781; } else { y = Math.sqrt( yy ); x = xy / y; z = yz / y; } } else { // m33 is the largest diagonal term so base result on this if ( zz < epsilon ) { x = 0.707106781; y = 0.707106781; z = 0; } else { z = Math.sqrt( zz ); x = xz / z; y = yz / z; } } this.set( x, y, z, angle ); return this; // return 180 deg rotation } // as we have reached here there are no singularities so we can handle normally let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be // caught by singularity test above, but I've left it in just in case this.x = ( m32 - m23 ) / s; this.y = ( m13 - m31 ) / s; this.z = ( m21 - m12 ) / s; this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 ); return this; } min( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); this.z = Math.min( this.z, v.z ); this.w = Math.min( this.w, v.w ); return this; } max( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); this.z = Math.max( this.z, v.z ); this.w = Math.max( this.w, v.w ); return this; } clamp( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); this.z = Math.max( min.z, Math.min( max.z, this.z ) ); this.w = Math.max( min.w, Math.min( max.w, this.w ) ); return this; } clampScalar( minVal, maxVal ) { this.x = Math.max( minVal, Math.min( maxVal, this.x ) ); this.y = Math.max( minVal, Math.min( maxVal, this.y ) ); this.z = Math.max( minVal, Math.min( maxVal, this.z ) ); this.w = Math.max( minVal, Math.min( maxVal, this.w ) ); return this; } clampLength( min, max ) { const length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); } floor() { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); this.z = Math.floor( this.z ); this.w = Math.floor( this.w ); return this; } ceil() { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); this.z = Math.ceil( this.z ); this.w = Math.ceil( this.w ); return this; } round() { this.x = Math.round( this.x ); this.y = Math.round( this.y ); this.z = Math.round( this.z ); this.w = Math.round( this.w ); return this; } roundToZero() { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z ); this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w ); return this; } negate() { this.x = - this.x; this.y = - this.y; this.z = - this.z; this.w = - this.w; return this; } dot( v ) { return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w; } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; } length() { return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); } manhattanLength() { return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w ); } normalize() { return this.divideScalar( this.length() || 1 ); } setLength( length ) { return this.normalize().multiplyScalar( length ); } lerp( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; this.z += ( v.z - this.z ) * alpha; this.w += ( v.w - this.w ) * alpha; return this; } lerpVectors( v1, v2, alpha ) { this.x = v1.x + ( v2.x - v1.x ) * alpha; this.y = v1.y + ( v2.y - v1.y ) * alpha; this.z = v1.z + ( v2.z - v1.z ) * alpha; this.w = v1.w + ( v2.w - v1.w ) * alpha; return this; } equals( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) ); } fromArray( array, offset = 0 ) { this.x = array[ offset ]; this.y = array[ offset + 1 ]; this.z = array[ offset + 2 ]; this.w = array[ offset + 3 ]; return this; } toArray( array = [], offset = 0 ) { array[ offset ] = this.x; array[ offset + 1 ] = this.y; array[ offset + 2 ] = this.z; array[ offset + 3 ] = this.w; return array; } fromBufferAttribute( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); this.z = attribute.getZ( index ); this.w = attribute.getW( index ); return this; } random() { this.x = Math.random(); this.y = Math.random(); this.z = Math.random(); this.w = Math.random(); return this; } *[ Symbol.iterator ]() { yield this.x; yield this.y; yield this.z; yield this.w; } } Vector4.prototype.isVector4 = true; /* In options, we can specify: * Texture parameters for an auto-generated target texture * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers */ class WebGLRenderTarget extends EventDispatcher { constructor( width, height, options = {} ) { super(); this.width = width; this.height = height; this.depth = 1; this.scissor = new Vector4( 0, 0, width, height ); this.scissorTest = false; this.viewport = new Vector4( 0, 0, width, height ); this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding ); this.texture.isRenderTargetTexture = true; this.texture.image = { width: width, height: height, depth: 1 }; this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false; this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null; this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter; this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true; this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false; this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null; } setTexture( texture ) { texture.image = { width: this.width, height: this.height, depth: this.depth }; this.texture = texture; } setSize( width, height, depth = 1 ) { if ( this.width !== width || this.height !== height || this.depth !== depth ) { this.width = width; this.height = height; this.depth = depth; this.texture.image.width = width; this.texture.image.height = height; this.texture.image.depth = depth; this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); } clone() { return new this.constructor().copy( this ); } copy( source ) { this.width = source.width; this.height = source.height; this.depth = source.depth; this.viewport.copy( source.viewport ); this.texture = source.texture.clone(); this.texture.image = { ...this.texture.image }; // See #20328. this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; this.depthTexture = source.depthTexture; return this; } dispose() { this.dispatchEvent( { type: 'dispose' } ); } } WebGLRenderTarget.prototype.isWebGLRenderTarget = true; class WebGLMultipleRenderTargets extends WebGLRenderTarget { constructor( width, height, count ) { super( width, height ); const texture = this.texture; this.texture = []; for ( let i = 0; i < count; i ++ ) { this.texture[ i ] = texture.clone(); } } setSize( width, height, depth = 1 ) { if ( this.width !== width || this.height !== height || this.depth !== depth ) { this.width = width; this.height = height; this.depth = depth; for ( let i = 0, il = this.texture.length; i < il; i ++ ) { this.texture[ i ].image.width = width; this.texture[ i ].image.height = height; this.texture[ i ].image.depth = depth; } this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); return this; } copy( source ) { this.dispose(); this.width = source.width; this.height = source.height; this.depth = source.depth; this.viewport.set( 0, 0, this.width, this.height ); this.scissor.set( 0, 0, this.width, this.height ); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; this.depthTexture = source.depthTexture; this.texture.length = 0; for ( let i = 0, il = source.texture.length; i < il; i ++ ) { this.texture[ i ] = source.texture[ i ].clone(); } return this; } } WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true; class WebGLMultisampleRenderTarget extends WebGLRenderTarget { constructor( width, height, options = {} ) { super( width, height, options ); this.samples = 4; this.ignoreDepthForMultisampleCopy = options.ignoreDepth !== undefined ? options.ignoreDepth : true; this.useRenderToTexture = ( options.useRenderToTexture !== undefined ) ? options.useRenderToTexture : false; this.useRenderbuffer = this.useRenderToTexture === false; } copy( source ) { super.copy.call( this, source ); this.samples = source.samples; this.useRenderToTexture = source.useRenderToTexture; this.useRenderbuffer = source.useRenderbuffer; return this; } } WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true; class Quaternion { constructor( x = 0, y = 0, z = 0, w = 1 ) { this._x = x; this._y = y; this._z = z; this._w = w; } static slerp( qa, qb, qm, t ) { console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' ); return qm.slerpQuaternions( qa, qb, t ); } static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation let x0 = src0[ srcOffset0 + 0 ], y0 = src0[ srcOffset0 + 1 ], z0 = src0[ srcOffset0 + 2 ], w0 = src0[ srcOffset0 + 3 ]; const x1 = src1[ srcOffset1 + 0 ], y1 = src1[ srcOffset1 + 1 ], z1 = src1[ srcOffset1 + 2 ], w1 = src1[ srcOffset1 + 3 ]; if ( t === 0 ) { dst[ dstOffset + 0 ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; return; } if ( t === 1 ) { dst[ dstOffset + 0 ] = x1; dst[ dstOffset + 1 ] = y1; dst[ dstOffset + 2 ] = z1; dst[ dstOffset + 3 ] = w1; return; } if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) { let s = 1 - t; const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = ( cos >= 0 ? 1 : - 1 ), sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems: if ( sqrSin > Number.EPSILON ) { const sin = Math.sqrt( sqrSin ), len = Math.atan2( sin, cos * dir ); s = Math.sin( s * len ) / sin; t = Math.sin( t * len ) / sin; } const tDir = t * dir; x0 = x0 * s + x1 * tDir; y0 = y0 * s + y1 * tDir; z0 = z0 * s + z1 * tDir; w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp: if ( s === 1 - t ) { const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 ); x0 *= f; y0 *= f; z0 *= f; w0 *= f; } } dst[ dstOffset ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; } static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) { const x0 = src0[ srcOffset0 ]; const y0 = src0[ srcOffset0 + 1 ]; const z0 = src0[ srcOffset0 + 2 ]; const w0 = src0[ srcOffset0 + 3 ]; const x1 = src1[ srcOffset1 ]; const y1 = src1[ srcOffset1 + 1 ]; const z1 = src1[ srcOffset1 + 2 ]; const w1 = src1[ srcOffset1 + 3 ]; dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1; dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1; dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1; dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1; return dst; } get x() { return this._x; } set x( value ) { this._x = value; this._onChangeCallback(); } get y() { return this._y; } set y( value ) { this._y = value; this._onChangeCallback(); } get z() { return this._z; } set z( value ) { this._z = value; this._onChangeCallback(); } get w() { return this._w; } set w( value ) { this._w = value; this._onChangeCallback(); } set( x, y, z, w ) { this._x = x; this._y = y; this._z = z; this._w = w; this._onChangeCallback(); return this; } clone() { return new this.constructor( this._x, this._y, this._z, this._w ); } copy( quaternion ) { this._x = quaternion.x; this._y = quaternion.y; this._z = quaternion.z; this._w = quaternion.w; this._onChangeCallback(); return this; } setFromEuler( euler, update ) { if ( ! ( euler && euler.isEuler ) ) { throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' ); } const x = euler._x, y = euler._y, z = euler._z, order = euler._order; //  // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/ // content/SpinCalc.m const cos = Math.cos; const sin = Math.sin; const c1 = cos( x / 2 ); const c2 = cos( y / 2 ); const c3 = cos( z / 2 ); const s1 = sin( x / 2 ); const s2 = sin( y / 2 ); const s3 = sin( z / 2 ); switch ( order ) { case 'XYZ': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'YXZ': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; case 'ZXY': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'ZYX': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; case 'YZX': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'XZY': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; default: console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order ); } if ( update !== false ) this._onChangeCallback(); return this; } setFromAxisAngle( axis, angle ) { //  // assumes axis is normalized const halfAngle = angle / 2, s = Math.sin( halfAngle ); this._x = axis.x * s; this._y = axis.y * s; this._z = axis.z * s; this._w = Math.cos( halfAngle ); this._onChangeCallback(); return this; } setFromRotationMatrix( m ) { //  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) const te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ], trace = m11 + m22 + m33; if ( trace > 0 ) { const s = 0.5 / Math.sqrt( trace + 1.0 ); this._w = 0.25 / s; this._x = ( m32 - m23 ) * s; this._y = ( m13 - m31 ) * s; this._z = ( m21 - m12 ) * s; } else if ( m11 > m22 && m11 > m33 ) { const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 ); this._w = ( m32 - m23 ) / s; this._x = 0.25 * s; this._y = ( m12 + m21 ) / s; this._z = ( m13 + m31 ) / s; } else if ( m22 > m33 ) { const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 ); this._w = ( m13 - m31 ) / s; this._x = ( m12 + m21 ) / s; this._y = 0.25 * s; this._z = ( m23 + m32 ) / s; } else { const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 ); this._w = ( m21 - m12 ) / s; this._x = ( m13 + m31 ) / s; this._y = ( m23 + m32 ) / s; this._z = 0.25 * s; } this._onChangeCallback(); return this; } setFromUnitVectors( vFrom, vTo ) { // assumes direction vectors vFrom and vTo are normalized let r = vFrom.dot( vTo ) + 1; if ( r < Number.EPSILON ) { // vFrom and vTo point in opposite directions r = 0; if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) { this._x = - vFrom.y; this._y = vFrom.x; this._z = 0; this._w = r; } else { this._x = 0; this._y = - vFrom.z; this._z = vFrom.y; this._w = r; } } else { // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3 this._x = vFrom.y * vTo.z - vFrom.z * vTo.y; this._y = vFrom.z * vTo.x - vFrom.x * vTo.z; this._z = vFrom.x * vTo.y - vFrom.y * vTo.x; this._w = r; } return this.normalize(); } angleTo( q ) { return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) ); } rotateTowards( q, step ) { const angle = this.angleTo( q ); if ( angle === 0 ) return this; const t = Math.min( 1, step / angle ); this.slerp( q, t ); return this; } identity() { return this.set( 0, 0, 0, 1 ); } invert() { // quaternion is assumed to have unit length return this.conjugate(); } conjugate() { this._x *= - 1; this._y *= - 1; this._z *= - 1; this._onChangeCallback(); return this; } dot( v ) { return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w; } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; } length() { return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w ); } normalize() { let l = this.length(); if ( l === 0 ) { this._x = 0; this._y = 0; this._z = 0; this._w = 1; } else { l = 1 / l; this._x = this._x * l; this._y = this._y * l; this._z = this._z * l; this._w = this._w * l; } this._onChangeCallback(); return this; } multiply( q, p ) { if ( p !== undefined ) { console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' ); return this.multiplyQuaternions( q, p ); } return this.multiplyQuaternions( this, q ); } premultiply( q ) { return this.multiplyQuaternions( q, this ); } multiplyQuaternions( a, b ) { // from  const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w; const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w; this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby; this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz; this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx; this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz; this._onChangeCallback(); return this; } slerp( qb, t ) { if ( t === 0 ) return this; if ( t === 1 ) return this.copy( qb ); const x = this._x, y = this._y, z = this._z, w = this._w; //  let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z; if ( cosHalfTheta < 0 ) { this._w = - qb._w; this._x = - qb._x; this._y = - qb._y; this._z = - qb._z; cosHalfTheta = - cosHalfTheta; } else { this.copy( qb ); } if ( cosHalfTheta >= 1.0 ) { this._w = w; this._x = x; this._y = y; this._z = z; return this; } const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta; if ( sqrSinHalfTheta "}]