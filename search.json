[{"title":"我的博客","path":"/posts/d90f63aa/","content":"背景 博客建立到现在已经近三年了，期间各种写作方式，各种主题，都折腾了不少，简单聊聊，分享一下。详细的操作方式这里就不啰嗦了，相信胆大心细的你肯定能解决。 关于主题主题从最初的 keep到有名的 butterfly 被我折腾的花里胡哨，再然后折腾的尽头是极简，所以主题换成 cards 非常简约，但是时间久了看腻了，就换成了现在的 stellar 简约而又不简单。 关于发布流程说到博客的写作流程，最初当然是最基础的 hexo g hexo d 发布到 Github 当然非常麻烦，后来学会了通过 Github Action 实现自动部署这之后就方便了一些，开始尝试在线的编辑器，最初用过 HexoPlusPlus 类似于现在的 QEXO 都是在浏览器编辑文件，然后上传到 github 触发自动部署，但因为编辑器不太好使，而且不太方便，还是用 VScode 最舒服，就这样大概用了一年多。 不过，去年我开始用 Obsidian 记笔记，规划项目等等，所以就想把博客编辑放到这里，通过 github-publisher 插件上传到 Github 触发 Action 实现部署 关于域名和备案域名最初当然是 github 生成的默认域名 (现在这里是很久之前的 butterfly 主题博客)后来买了 wxydejoy.top 并通过阿里云进行备案（备案才能使用国内 CDN）后来觉得域名太长换了 undf.top。 备案的话，需要三个月以上的服务器才行，当时是 27 块通过新人优惠在阿里云买了三个月，然后就是填资料等电话等等等等，繁琐但不复杂。不过服务器到期后阿里云会发邮件警告：域名未指向服务（解决方案是建个 OSS 将域名指向它然后开启访问鉴权，通过 github Action 每周访问一次，这样就可以 0 成本实现） 关于网站加速与防御刚开始，博客当然是使用 github page 部署，国内基本无法访问，后来使用 Vercel 进行部署，速度也是一般般，类似的还有 Cloudflare Page 国内访问速度都很感人。 现在，使用的是又拍云 CDN 通过加入 又拍云联盟 实现，当然你也可以使用腾讯阿里等等，但是一定要开启各种防护，防止被攻击欠费（前段时间我就被刷了一点点流量，莫名其妙）。 防御第一条：禁止国外 IP 访问 CDN，通过 DNS 将其指向源站（Github），然后就是限制各种访问频率，一般小站访问量也不会太多，每分钟能有几百次差不多了。","tags":["📃Blog"],"categories":["💻Code"]},{"title":"Python 爬虫之 DrissionPage","path":"/posts/988b45cc/","content":"DrissionPage 是什么DrissionPage 是一个基于 python 的网页自动化工具。它既能控制浏览器，也能收发数据包，还能把两者合而为一。可兼顾浏览器自动化的便利性和 requests 的高效率。它功能强大，内置无数人性化设计和便捷功能。它的语法简洁而优雅，代码量少，对新手友好。 用 requests 做数据采集面对要登录的网站时，要分析数据包、JS 源码，构造复杂的请求，往往还要应付验证码、JS 混淆、签名参数等反爬手段，门槛较高，开发效率不高。使用浏览器，可以很大程度上绕过这些坑，但浏览器运行效率不高。 因此，这个库设计初衷，是将它们合而为一，同时实现“写得快”和“跑得快”。能够在不同需要时切换相应模式，并提供一种人性化的使用方法，提高开发和运行效率。除了合并两者，本库还以网页为单位封装了常用功能，提供非常简便的操作和语句，使用户可减少考虑细节，专注功能实现。 以简单的方式实现强大的功能，使代码更优雅。 以前的版本是对 selenium 进行重新封装实现的。从 3.0 开始，作者另起炉灶，对底层进行了重新开发，摆脱对 selenium 的依赖，增强了功能，提升了运行效率。 示例代码123456789101112131415from DrissionPage import ChromiumPage# 创建页面对象，并启动或接管浏览器page = ChromiumPage()# 跳转到登录页面page.get(&#x27;https://gitee.com/login&#x27;)# 定位到账号文本框，获取文本框元素ele = page.ele(&#x27;#user_login&#x27;)# 输入对文本框输入账号ele.input(&#x27;您的账号&#x27;)# 定位到密码文本框并输入密码page.ele(&#x27;#user_password&#x27;).input(&#x27;您的密码&#x27;)# 点击登录按钮page.ele(&#x27;@value=登 录&#x27;).click() 应用实例淘宝商品截图123456# 部分代码page = ChromiumPage(co)page.get(img_url,retry=1, interval=1, timeout=1.5) img = page(&#x27;tag:img&#x27;)img.get_screenshot(path=&#x27;./&#x27;, name=&#x27;temp_img.jpg&#x27;) 未来工厂订单数据爬取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from DrissionPage import SessionPage, SessionOptions # pip install DrissionPagefrom DrissionPage import ChromiumPagefrom DrissionPage import ChromiumOptionsimport reimport timeco = ChromiumOptions(read_file=False) # 不读取文件方式新建配置对象co.set_browser_path(r&#x27;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&#x27;) # 设置浏览器路径# co.set_argument(&#x27;--headless&#x27;) # 设置无头模式 隐藏浏览器界面# 设置配置文件路径co.set_user_data_path(r&#x27;C:\\Users\\weiek\\AppData\\Local\\Google\\Chrome\\User Data&#x27;)url_base = &quot;https://www.wenext.cn/index.php?route=account/order&amp;filter_time=6&amp;page=&quot;page = ChromiumPage(co)# cp = ChromiumPage(co)for i in range(1, 20): print(i) url = url_base + str(i) page.get(url) # 等待页面加载完成 page.wait.doc_loaded() # 从 page.html 正则匹配订单号 订单编号 86027961 result_num = re.findall(r&#x27;订单编号 (\\d+)&#x27;, page.html) # print(result_num) try: for i in result_num: page.get(&#x27;https://www.wenext.cn/index.php?route=account/order/info&amp;order_id=&#x27; + i) page.wait.doc_loaded() # print(page.html) # 正则匹配订单金额 余额(158.00) 余额(158) result_money = re.findall(r&#x27;余额\\((.*?)\\)&#x27;, page.html)[0] print(result_money) # time.sleep(10) # 正则匹预计在2024-03-17 23:00:00前发货 result_time1 = re.findall(r&#x27;预计在(.*?)前发货&#x27;, page.html)[0].replace(&#x27;23:00:00&#x27;, &#x27; &#x27;) print(result_time1) # 正则匹配 &lt;td class=&quot;order-body-time&quot;&gt;2024-03-10&lt;/td&gt; # &lt;td class=&quot;order-body-time&quot;&gt;2024-03-10&lt;/td&gt; # &lt;td class=&quot;order-body-time&quot;&gt;已发货，待签收&lt;/td&gt; result_time2_list = re.findall(r&#x27;&lt;td class=&quot;order-body-time&quot;&gt;(.*?)&lt;/td&gt;&#x27;, page.html, re.S) result_time2 = &#x27;0&#x27; for j in result_time2_list: if j == &#x27;已发货，待签收&#x27;: # 获取索引 index = result_time2_list.index(j) # 获取发货时间 result_time2 = result_time2_list[index - 1] if result_time2 != &#x27;0&#x27;: with open(&#x27;wenext.txt&#x27;, &#x27;a&#x27;) as f: # 写入文件 订单号 订单金额 预计发货时间 实际发货时间 f.write(i + &#x27;\t&#x27; + result_money + &#x27;\t&#x27; + result_time1 + &#x27;\t&#x27; + result_time2 + &#x27; &#x27;+&#x27; &#x27;) print(result_time2) # time.sleep(1) except: with open(&#x27;wenexterr.txt&#x27;, &#x27;a&#x27;) as f: f.write(i + &#x27;\t&#x27; + &#x27;error&#x27; + &#x27;\t&#x27; + &#x27;error&#x27; + &#x27;\t&#x27; + &#x27;error&#x27; + &#x27; &#x27;+&#x27; &#x27;)","tags":["💻Code","🕷️Python"],"categories":["💻Code"]},{"title":"生活随笔","path":"/posts/61eef7d7/","content":"无论如何，未来，请多陪陪父母！","tags":["Life"],"categories":["🔖Life"]},{"title":"OMPL开源轨迹规划库","path":"/posts/7f43910f/","content":"下面列出的所有实现都被视为功能齐全。在OMPL中，规划器分为三类: 几何规划器 基于控制的规划器 基于多层次的规划器 要了解如何对规划器进行基准测试，请单击 此处 。 实例图册部分没图就是当时没求解出来ABITstarFMTLBKPIECE1RRTSPARStwoAITstarinformedRRTstarLBTRRTRRTsharpSSTBFMTKPIECE1PDSTRRTstarSTRIDEBiESTlazyLBTRRTPRMRRTXstaticTRRTBITstarlazyPRMPRMstarSBLBKPIECE1lazyPRMstarProjESTSORRTstarESTlazyRRTRRTconnectSPARS 几何规划器此类别中的规划器仅考虑系统的几何和运动学约束。假设任何可行的路径都可以变成动态可行的轨迹。这些规划器中的任何一个都可用于 几何约束进行规划 。此类别中的规划器可以分为几个重叠的子类别: 多查询规划器 这些规划器构建了可用于多个查询的整个环境的路线图。 概率路线图方法PRM 这是基于采样的算法。我们的实现使用一个线程来构建路线图，而另一个线程检查路线图中是否存在开始状态和目标状态之间的路径。OMPL包含许多PRM的变体: LazyPRM 此计划器类似于常规 PRM，但“懒惰”地检查顶点或边的有效性，即仅当它是候选解决方案路径的一部分时。 PRM* 虽然常规 PRM 尝试将状态连接到固定数量的邻居，但 PRM* 会随着路线图的增长而逐渐增加连接尝试的次数，从而向最佳路径提供收敛。 LazyPRM* 具有惰性状态有效性检查的 PRM* 版本。 SPArse 路线图扳手算法 （SPARS） SPARS是一个计划器，它提供渐近 near 最优性（在最优解的常数因子内的解决方案），并包括一个有意义的停止准则。虽然（因为？）它不能保证最优性，但它的收敛率往往远高于PRM*。 SPARS2 SPARS2是SPARS算法的变体，它通过类似的机制工作，但使用不同的方法来识别接口和计算通过所述接口的最短路径。 单查询规划器 这些规划者通常会生长一棵由有效运动连接的状态树。这些规划器的不同之处在于他们用于控制 树的扩展位置 和 方式 的启发式方法。一些基于树的规划者种植 两 棵树:一棵从起点开始，一棵从目标开始。此类规划器将尝试将开始树中的一个状态与目标树中的另一个状态连接起来。 快速探索随机树 （RRT） 这是最早的单个查询规划器之一。该算法易于理解和实现。已经提出了许多很多RRT的变体。OMPL 包含几种 RRT 变体: RRT Connect （RRTConnect） 这个规划器是RRT的双向版本（即，它长了两棵树）。它通常优于原始的RRT算法。 RRT* RRT的渐近最优版本:算法收敛于作为时间函数的最优路径。这是第一个可证明的渐近规划器（与PRM一起）。自发布以来，已经出现了其他几种算法，这些算法提高了RRT*的收敛率，例如 RRT# 和 RRTX 。 下限树 RRT （LBTRRT） LBTRRT是RRT的渐近最优版本:它保证收敛到最优解的常数因子内的解。 稀疏稳定RRT SST 是 RRT 的渐近接近最优增量版本。 基于过渡的 RRT （T-RRT） T-RRT不提供任何硬性最优性保证，但试图找到短而低成本的路径。 矢量场RRT VF-RRT是一个基于树的运动规划器，试图最小化所谓的路径上游成本。上游成本由用户定义的向量场上的积分定义。 平行RRT 已经为基于抽样的计划者提出了许多不同的并行化方案，包括RRT。在此实现中，多个线程同时向同一树添加状态。找到解决方案后，所有线程都将终止。 Lazy RRT （LazyRRT） 此计划器执行惰性状态有效性检查（类似于 LazyPRM）。它不是实验性的，但根据我们的经验，它似乎在任何类别的问题上都没有明显优于其他规划者。 任务空间RRT （TSRRT） TSRRT是RRT的一种变体，其中探索由任务空间指导。它需要一个 ompl::geometric::TaskSpaceConfig 实例，该实例定义如何将配置空间状态投影到任务空间，以及一个将任务空间状态提升到配置空间的反向操作。 膨胀空间树 （EST） 该规划器与RRT大约同时出版。根据我们的经验，它对良好的距离测量并不敏感，这对于复杂的高维状态空间可能很难定义。EST实际上有三个版本: 原始 接近第一次发布的 版本，双向版本 和 基于投影的版本 。低维投影用于跟踪状态空间的探索方式。大多数情况下，OMPL可以自动确定合理的投影。我们已经实施了一些规划器，这些规划器不一定是EST的简单变体，但确实具有相同的扩展策略: 单查询双向延迟碰撞检查计划 （SBL） 此计划器本质上是具有惰性状态有效性检查的 EST 的双向版本。 并行单查询双向延迟碰撞检查计划 （pSBL） 此规划器在 SBL 中并行使用多个线程增长两棵树。 通过内部和外部细胞探索 （KPIECE） 进行运动学规划 KPIECE是一个基于树的规划器，它使用离散化（通常是多个层次）来指导（连续）状态空间的探索。OMPL的实现是简化的，使用单一级别的离散化:一个网格。网格被强加于 projection 状态空间的投影上。在探索空间时，优先考虑到目前为止已探索的网格部分的边界。边界定义为 在 n 维投影空间中具有少于 2 n 个非对角线非空相邻格网像元的格网像 _n_元集。KPIECE有两种变体: 双向 KPIECE （BKPIECE） Lazy Bi-directional KPIECE （LBKPIECE） 具有分辨率独立密度估计（STRIDE）的搜索树 这位规划器的灵感来自 EST。STRIDE 不使用投影，而是使用 几何近邻访问树 直接在状态空间中估计采样密度。STRIDE 对于高维系统非常有用，在这些系统中，自由空间无法通过低维（线性）投影轻松捕获。 路径导向细分树 （PDST） PDST 是一个规划器，它完全消除了对距离度量的依赖，这在难以定义良好距离度量的情况下很有用。PDST保持二进制空间分区，以便运动完全包含在分区的一个单元格中。每个单元格的运动密度用于指导树的扩展。 快速行进树算法 （FMT∗） FMT∗ 算法对一组概率绘制的样本执行“惰性”动态规划递归，以生长路径树，该路径树在成本空间中向外移动。与所有其他规划器不同，需要事先选择有效样本的数量。 双向快速行进树算法（BFMT∗） 执行两个 FMT* 树，一个从起点开始，另一个从目标开始，从而在探索更少的空间时使规划器更快。 多层次规划器 可以利用多个抽象级别的规划算法。如果要使用它们，则应使用 [ompl::base::SpaceInformationPtr](https://ompl.kavrakilab.org/core/classompl_1_1base_1_1SpaceInformationPtr.html &quot;ompl::base::SpaceInformation 的共享指针包装器。&quot;).然后，所有规划器都保证概率完整性，如果提供的抽象是可以接受的。有指南 guide， 教程 和 演示 形式的大量文档。 快速探索随机商空间树 （QRRT） RRT的推广，以在不同的抽象级别上进行规划。 快速交货率* QRRT 的渐近最优版本 商空间路线图规划器 （QMP） PRM的泛化，用于在不同的抽象级别上进行规划。 QMP* QMP 的渐近最优版本 优化规划器 近年来，已经提出了几种基于抽样的计划算法，这些算法仍然提供了一些最优性保证。通常，假定最优解是最短路径。在OMPL中，我们有一个更通用的框架来表示状态和路径的成本，例如，允许您最大化沿路径的最小间隙，最小化机械功或一些任意用户定义的优化标准。有关详细信息，请参阅 最佳规划 。下面的一些规划者使用这种一般成本框架，但请记住，当优化路径长度以外的其他内容时，不能保证收敛到最优。 PRM* PRM的渐近最优版本; 使用一般成本框架。 懒惰PRM* PRM*的惰性版本; 使用一般成本框架。 RRT* RRT的渐近最优版本; 使用一般成本框架。 RRT# RRT* 的一种变体，收敛率更高。 它使用一般成本框架。 RRTX RRT* 的一种变体，收敛率更高。 它使用一般成本框架。 知情的RRT* RRT* 的一种变体，它使用启发式方法来绑定对最佳解决方案的搜索。 它使用一般成本框架。 批处理通知树 （BIT*） 一种随时渐近最优算法，它使用启发式算法对最优解的搜索进行排序和绑定。 它使用一般成本框架。 高级位* （阿比特*） BIT* 的扩展，它使用高级图形搜索技术更快地找到初始解决方案。 它使用一般成本框架。 自适应通知树 （AIT*） 一种随时渐近优化的算法，可同时估计和利用特定于问题的启发式方法。 它使用一般成本框架。 下限树 RRT （LBTRRT） RRT 的渐近接近最优版本。 稀疏稳定RRT SST 是 RRT 的渐近接近最优增量版本。 基于过渡的 RRT （T-RRT） T-RRT不提供任何硬性最优性保证，但试图找到短而低成本的路径。 它使用一般成本框架。 梁 基于渐近最优路线图的规划器。 SPARS2 基于渐近最优路线图的规划器。 FMT* 渐近最优的基于树的规划器。 ST-RRT* 用于时空规划的双向时间优化规划器。 首席财务官 一个元规划器，它在不同的线程中运行多个渐近最优规划器实例。当一个线程找到更好的求解路径时，路径上的状态将传递给其他线程。 随时缩短路径 （APS） APS 是围绕一个或多个几何运动规划器的通用包装器，它反复将 快捷方式 和 混合应用于 一组解决方案路径。可以指定任何数量和计划器的组合，每个计划器都在单独的线程中运行。 AttentionOMPL 如何选择几何规划器如果使用 ompl::geometric::SimpleSetup 类（强烈推荐）来定义和解决运动规划问题，则 OMPL 将自动选择合适的规划器（除非您明确指定了一个）。如果状态空间具有默认投影（如果您使用任何内置状态空间，情况就是如此），那么 使用 LBKPIECE 如果可以则它将使用双向规划器 ，否则它将使用 KPIECE 。这些规划器已被证明在许多现实世界的运动规划问题上都能很好地工作，这就是为什么这些规划器是默认选择的原因。如果状态空间没有默认投影，则将使用 RRTConnect 或常规 RRT ，具体取决于是否可以使用双向规划器。目标的概念在 OMPL 中非常笼统:甚至可能无法对满足目标的状态进行采样，在这种情况下，OMPL 无法在目标状态生长第二棵树。可行性和最优性在实践中，可行和最佳规划者之间的界限并不是那么黑白分明。它们之间的界限可以用适当的 ompl::base::PlannerTerminationCondition 来模糊。例如， ompl::base::exactSolnPlannerTerminationCondition 函数返回一个终止条件，该条件导致优化计划程序在找到第一个解决方案后终止。作为另一个示例，使用 ompl::base::CostConvergenceTerminationCondition 和参数 solutionsWindow=10 和 epsilon=1，导致优化计划程序 _exactly_在找到 10 个解决方案时终止。您可以使用 ompl::base::p lannerOrTerminationCondition 和 ompl::base::p lannerAndTerminationCondition 来组合计划程序终止条件（例如，“在找到 10 个解决方案或 超过 10 秒的时间限制时终止”）。有关详细信息，请参阅 Planner 终止条件 。 其他工具: Hill Climbing Genetic Search 基于控制的规划器如果所考虑的系统受到差异约束，则使用基于控制的规划器。这些规划者依靠 状态传播 而不是简单的插值来生成运动。这些规划器不需要 转向功能 ，但如果用户实现它，它们（KPIECE除外）都将使用它。下面的前两个规划器是对上面相应几何规划师的基诺动力学改编。 快速探索随机树 （RRT） 稀疏稳定RRT SST 是 RRT 的渐近接近最优增量版本。 膨胀空间树 （EST） 通过内外细胞探索（KPIECE）进行Kinodynamic规划 顾名思义，基于控件的KPIECE版本首先出现，几何版本是从中派生出来的。 路径导向细分树 （PDST） 基于控制的PDST版本实际上出现在几何版本之前。鉴于基于控件的版本，也很容易实现几何版本。 Syclop，一个元规划器，在较低级别使用其他规划器 Syclop 是一个元规划器，它将通过状态空间分解计算的高级指南与低级规划算法相结合。低级规划人员所做的进度将反馈给高级规划员，高级规划师使用此信息来更新指南。Syclop 有两种不同版本： Syclop使用RRT作为低级规划器 Syclop 使用 EST 作为低级规划器 线性时态逻辑规划器 （LTLPlanner） LTLPlanner 为运动规划问题找到解决方案，其中目标由线性时态逻辑 （LTL） 规范指定。 OMPL 如何选择基于控件的计划员如果使用 ompl::control::SimpleSetup 类（强烈推荐）来定义和解决运动规划问题，则 OMPL 将自动选择适当的规划器（除非您明确指定了一个）。如果状态空间具有默认投影（如果使用任何内置状态空间，情况就是如此），则它将使用 KPIECE。 该规划器已被证明在许多现实世界的运动规划问题上都能很好地工作，这就是为什么它是默认选择的原因。如果状态空间没有默认投影，则将 使用 RRT 。请注意，没有基于双向控制的规划器，因为我们不假设有一个转向功能可以精确地连接两个状态 _exactly_。 基于多层次的规划器为了解决涉及高维状态空间的问题，我们通常可以使用多级抽象来简化状态空间，从而使专门的规划者能够更快地找到解决方案。此类中的规划器支持状态空间序列，可用于具有几何和动态约束的状态空间。有指南 guide， 教程 和 演示 形式的大量文档。 快速探索随机商空间树 （QRRT） RRT的推广，以在不同的抽象级别上进行规划。 快速交货率* QRRT 的渐近最优版本 商空间路线图规划器 （QMP） PRM的泛化，用于在不同的抽象级别上进行规划。 QMP* QMP 的渐近最优版本 稀商空间路线图规划器 （SPQR）* SPARS向多层次规划的推广。","tags":["ROS2"],"categories":["💻Code"]},{"title":"URDF 导出资料（ROS2）","path":"/posts/711bc132/","content":"坐标系建立 如图所示按照DH坐标法建立各个坐标系 坐标系建立方法去复习机器人导论 建立完成可能会很乱 不用担心 插件安装和使用插件下载地址 经测试 1.6.1支持 solidworks 2022 sp5（实验室当前使用的版本） warning: 插件要在装配体里面才有反应 插件使用打开插件 base_link normal_link 其中关节类型如下 关节类型 描述 continuous 旋转关节，可以围绕单轴无限旋转 revolute 旋转关节，类似于continuous,.但是有旋转的角度极限 一定要设置上下限不然默认为0 prismatic 滑动关节，沿某一轴线移动的关节，带有位置极限 plannar 平面关节，允许在平面正交方向上平移或者旋转 floating 浮动关节，允许进行平移、旋转运动 fixed 固定关节，不允许运动的特殊关节 设置完成后单击导出按钮 导出即可 注意导出名即为ros中的包名，勿乱写 URDF 测试CoppeliaSim Edu 导入URDF 简单拖动旋转测试一下 URDF 文件包修改修改CMakelist.txt根据自己的情况修改 1234567cmake_minimum_required(VERSION 3.10.2)project(moveit_resources_fanuc_description) # 修改为自己的包名find_package(ament_cmake REQUIRED)ament_package()install(DIRECTORY meshes urdf DESTINATION share/$&#123;PROJECT_NAME&#125;) 修改package.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot;?&gt;&lt;package format=&quot;3&quot;&gt; &lt;!-- # 根据内容修改 --&gt; &lt;name&gt;moveit_resources_panda_description&lt;/name&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;description&gt;panda Resources used for MoveIt testing&lt;/description&gt; &lt;author email=&quot;isucan@willowgarage.edu&quot;&gt;Ioan Sucan&lt;/author&gt; &lt;author email=&quot;acorn@willowgarage.edu&quot;&gt;Acorn Pooley&lt;/author&gt; &lt;maintainer email=&quot;dave@dav.ee&quot;&gt;Dave Coleman&lt;/maintainer&gt; &lt;license&gt;BSD&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt;&lt;/package&gt; 编译包将包放入 ros2 或者 moveit2 工作空间中 1colcon build --packages-select moveit_resources_fanuc_description # 修改为自己的包名 MoveIt Setup Assistant 配置1234567# 激活ros2环境source /opt/ros/foxy/setup.bash# 激活moveit环境source ~/moveit2_ws/install/setup.bash # 刚才编译包的路径# 启动moveit MoveIt Setup Assistantros2 launch moveit_setup_assistant setup_assistant.launch.py 剩下的就参照官网文档 演示12# 运行演示ros2 launch panda_moveit_config demo.launch.py # 修改为自己的包名 其他我在导出复杂模型时遇到一些问题，可能是插件的问题，导出的模型有些问题，但是简单模型没有问题 经过CoppeliaSim Edu导入再导出，可以解决这个问题（记得修改urdf内的文件路径）","tags":["ROS2"],"categories":["💻Code"]},{"title":"旭日x3PI的开发日常","path":"/posts/5ecf4bea/","content":"常用命令123456789101112131415161718hrut_somstatus # 用于实时查询温度传感器读数及 CPU/BPU 频率实时信息echo performance &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor # CPU 频率固定在最高值:sudo apt update # 更新软件源sudo apt full-upgrade # 更新系统sudo nmcli device wifi rescan # 扫描wifisudo nmcli device wifi list # 列出wifisudo wifi_connect &quot;SSID&quot; &quot;PASSWD&quot; # 连接wifi wifi支持开热点 具体看 https://developer.horizon.ai/api/v1/fileData/documents_pi/System_Configuration/System_Configuration.html#id2 QT相关QT 安装 1sudo apt install qt5-default QT Creator 安装 1sudo apt install qtcreator 第三方包 串口 sudo apt install libqt5serialport5-dev 蓝牙 sudo apt-get install libkf5bluezqt-dev # 如果不行再尝试这个 sudo apt-get install libbluetooth-dev 截图 sudo apt-get install xfce4-screenshooter # 安装后键盘上面的 prtsc 按键就可以用了 录屏 sudo apt-get install kazam # 找应用即可其他包类似 可以用 apt search 搜索 蓝牙蓝牙连接嵌入式设备 12# 先配对然后连接sudo rfcomm connect hci0 (macaddress) ros 修复ROS2使用zsh无法用tab补全 ros2 指令的相关问题 1sudo apt install python3-argcomplete python3-colcon-common-extensions 然后，在.zshrc里面添加如下语句， 123456source /usr/share/colcon_cd/function/colcon_cd.shexport _colcon_cd_root=/opt/ros/foxy/source /usr/share/colcon_argcomplete/hook/colcon-argcomplete.zsheval &quot;$(register-python-argcomplete3 ros2)&quot;eval &quot;$(register-python-argcomplete3 colcon)&quot; 后记看着内容不多，但在搜索引擎里面找这些废了不少功夫，所以就写了这个，方便自己也方便别人。","tags":["X3PI","开发日常"],"categories":["💻Code"]},{"title":"QtCreator 一键打包你的APP","path":"/posts/ca763a9f/","content":"打开这个 添加工具 添加外部程序 修改如下内容 执行挡： powershell 参数（一行）： 12# qt Creator 8 以上版本 其他版本请根据最下面的提示修改md %&#123;ActiveProject:Path&#125;/package/ ; copy %&#123;ActiveProject:RunConfig:Executable:FilePath&#125; %&#123;ActiveProject:Path&#125;/package/%&#123;ActiveProject:RunConfig:Executable:FileName&#125; ; windeployqt %&#123;ActiveProject:Path&#125;/package/%&#123;ActiveProject:RunConfig:Executable:FileName&#125; Base environment 改为 Current build environment 双击可以重命名 其他保持默认即可 使用 (可选)将编译模式改为release 单击运行即可 运行后可以看到下图即为成功 打开项目所在目录 package 文件夹即为打包后的文件夹 如果使用了Git 不要忘记把package文件夹加入到忽略列表中 其他 qt Creator 版本单击红色方框后 单击右侧环境变量按钮 将 %{ActiveProject:Path} %{ActiveProject:RunConfig:Executable:FilePath} %{ActiveProject:RunConfig:Executable:FileName} 替换为对应的环境变量即可 如 4 版本的qt Creator 12# qt Creator 4 版本md %&#123;CurrentProject:Path&#125;/package/ ; copy %&#123;CurrentRun:Executable:FilePath&#125; %&#123;CurrentProject:Path&#125;/package/%&#123;CurrentRun:Executable:FileName&#125; ; windeployqt %&#123;CurrentProject:Path&#125;/package/%&#123;CurrentRun:Executable:FileName&#125;","tags":["💻Code","📦QT"]},{"title":"leetcode 刷题记录（倒序）","path":"/posts/d444c6c7/","content":"大部分为抄答案，看解析，且跳过困难的题目，希望能学到点东西 合并两个有序链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970大佬递归确实强/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; *///根节点写的不太顺利，但做出来了struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) &#123; struct ListNode *use; // struct ListNode root; struct ListNode* root = (struct ListNode*)malloc(sizeof(struct ListNode)); // root = list2; // use = root-&gt;next; root-&gt;next = NULL; use = root; int temp = 0; while (list1 || list2) &#123; if (!list1) &#123; // list1 null use-&gt;next = list2; list2 = list2-&gt;next; use = use-&gt;next; &#125; else if (!list2) &#123; // list2 null use-&gt;next = list1; list1 = list1-&gt;next; use = use-&gt;next; &#125; else &#123; // compare if (list1-&gt;val &lt; list2-&gt;val) &#123; use-&gt;next = list1; list1 = list1-&gt;next; use = use-&gt;next; &#125; else &#123; use-&gt;next = list2; list2 = list2-&gt;next; use = use-&gt;next; &#125; &#125; &#125; return root-&gt;next;&#125;struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) &#123; if (list1 == NULL) &#123; return list2; &#125; if (list2 == NULL) &#123; return list1; &#125; struct ListNode* mergedList; if (list1-&gt;val &lt;= list2-&gt;val) &#123; mergedList = list1; mergedList-&gt;next = mergeTwoLists(list1-&gt;next, list2); &#125; else &#123; mergedList = list2; mergedList-&gt;next = mergeTwoLists(list1, list2-&gt;next); &#125; return mergedList;&#125;作者：tt-1103链接：https://leetcode.cn/problems/merge-two-sorted-lists/solutions/2512813/he-bing-you-xu-lian-biao-by-tt-1103-74r9/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 两数相加 12345678910111213141516171819202122232425262728293031// 链表递归 https://leetcode.cn/problems/add-two-numbers/description/struct ListNode *helper(struct ListNode *l1, struct ListNode *l2, int carry)&#123; if (l1 == NULL &amp;&amp; l2 == NULL &amp;&amp; carry == 0) &#123; return NULL; &#125; int sum = carry; if (l1 != NULL) &#123; sum += l1-&gt;val; l1 = l1-&gt;next; &#125; if (l2 != NULL) &#123; sum += l2-&gt;val; l2 = l2-&gt;next; &#125; struct ListNode *l = malloc(sizeof(struct ListNode)); l-&gt;val = sum % 10; l-&gt;next = helper(l1, l2, sum / 10); return l;&#125;struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)&#123; return helper(l1, l2, 0);&#125; 20. 有效的括号大佬的答案 123456789101112131415161718bool isValid(char* s) &#123; char mp[128] = &#123;&#125;; mp[&#x27;)&#x27;] = &#x27;(&#x27;; mp[&#x27;]&#x27;] = &#x27;[&#x27;; mp[&#x27;&#125;&#x27;] = &#x27;&#123;&#x27;; int top = 0; // 直接把 s 当作栈 for (int i = 0; s[i]; i++) &#123; char c = s[i]; if (mp[c] == 0) &#123; // c 是左括号 s[top++] = c; // 入栈 &#125; else if (top == 0 || s[--top] != mp[c]) &#123; // c 是右括号 return false; // 没有左括号，或者左括号类型不对 &#125; &#125; return top == 0; // 所有左括号必须匹配完毕&#125; 15. 三数之和 能猜到双指针我就很知足了， 48. 旋转图像 难点在原地 看答案，找规律，转置+翻转，完成 12345678910111213141516171819202122232425262728293031323334353637void rotate(int** matrix, int matrixSize, int* matrixColSize) &#123; int temp; // 转置 for (int i = 0; i &lt; matrixSize; i++) &#123; for (int j = i + 1; j &lt; matrixSize; j++) &#123; temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; // 翻转 for (int i = 0; i &lt; matrixSize; i++) &#123; // 行 for (int j = 0; j &lt; matrixSize/2; j++) &#123; //列 temp = matrix[i][j]; matrix[i][j] = matrix[i][matrixSize-j-1]; matrix[i][matrixSize-j-1] = temp; &#125; &#125;&#125; 238. 除自身以外数组的乘积（做出了，但耗时，再做） 380. O(1) 时间插入、删除和获取随机元素（再看看吧）45. 跳跃游戏 II（再做） 55. 跳跃游戏（想耍小聪明降低运算时间，但是各种漏洞） 121. 买卖股票的最佳时机（做了，耗时，脑子不够灵活再做）189. 轮转数组 (做出来了，比我预期的好得多) 169. 多数元素 (做了，但耗时再做)80. 删除有序数组中的重复项 II给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 12345678910111213141516171819202122232425262728int removeDuplicates(int* nums, int numsSize) &#123;if (numsSize &lt;= 2) &#123;return numsSize;&#125;int slow = 2, fast = 2;while (fast &lt; numsSize) &#123;if (nums[slow - 2] != nums[fast]) &#123;nums[slow] = nums[fast];++slow;&#125;++fast;&#125;return slow;&#125; 26. 删除有序数组中的重复项　双指针问题做的越来越舒服了　还不错，很快做完了； 27. 移除元素 (work 1.5)给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1： 输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,3,0,4]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 88. 合并两个有序数组 (work 1)给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 53. 最大子数组和 coolBoy 我觉得这道题目的思想是： 走完这一生如果我和你在一起会变得更好，那我们就在一起，否则我就丢下你。我回顾我最光辉的时刻就是和不同人在一起，变得更好的最长连续时刻 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4] 输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums &#x3D; [1]输出：1 示例 3： 输入：nums &#x3D; [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 15. 三数之和复制粘贴 25. K 个一组翻转链表复制粘贴 215. 数组中的第K个最大元素复制粘贴 LRU 缓存机制提交记录是先去b站看了解析视频然后自己写的，很多cpp的内容还是不熟悉，要继续。 状态 日期 语言 时间 空间 优化 通过 2023.10.10 C++ 372 ms 161.7 MB 官方题解 通过 2023.10.10 C++ 372 ms 161.4 MB ai 优化 通过 2023.10.10 C++ 476 ms 170.7 MB 通过 2023.10.10 C++ 488 ms 170.8 MB 超出时间限制 2023.10.10 C++ N&#x2F;A N&#x2F;A 超出时间限制 2023.10.10 C++ N&#x2F;A N&#x2F;A 执行出错 2023.10.09 C++ N&#x2F;A N&#x2F;A 执行出错 2023.10.09 C++ N&#x2F;A N&#x2F;A 自己的最终代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class LRUCache &#123;public: LRUCache (int capacity) &#123; __cap = capacity; &#125; int get (int key) &#123; //key = 0; if (hashmap.find (key) == hashmap.end ())&#123; // 没找到 return -1; &#125; else &#123; // 添加 key_value kv; kv.key = key; kv.value = hashmap [key]-&gt;value; value_list.erase (hashmap [key]); value_list.push_front (kv); hashmap [key] = value_list.begin (); return kv.value; &#125; return key; &#125; void put (int key, int value) &#123; if (hashmap.find (key) == hashmap.end ())&#123; // 没找到 // 满了吗？ if (__cap == hashmap.size ())&#123; hashmap.erase ( value_list.back ().key); value_list.pop_back (); &#125; // 添加 key_value kv; kv.key = key; kv.value = value; value_list.push_front ( kv); hashmap [key] = value_list.begin (); &#125; else &#123; // 找到了 // 删除并添加到头 value_list.erase (hashmap [key]); // 添加 key_value kv; kv.key = key; kv.value = value; value_list.push_front ( kv); hashmap [key] = value_list.begin (); &#125; &#125;private: int __cap; struct key_value &#123; int key; int value; bool operator==(const key_value&amp; kv)&#123; return key == kv.key; &#125; &#125;; map&lt;int, list&lt;key_value&gt;::iterator&gt; hashmap; list&lt;key_value&gt; value_list;&#125;; ai优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;class LRUCache &#123;public: LRUCache (int capacity) : capacity (capacity) &#123; &#125; int get (int key) &#123; if (cache_map.find (key) == cache_map.end ()) &#123; return -1; // 未找到 &#125; else &#123; // 将键值对移到链表头部表示最近使用 moveToFront (key); return cache_map [key]-&gt;second; &#125; &#125; void put (int key, int value) &#123; if (cache_map.find (key) == cache_map.end ()) &#123; if (cache_map.size () &gt;= capacity) &#123; // 缓存已满，删除最久未使用的项目 int lru_key = lru_list.back ().first; cache_map.erase (lru_key); lru_list.pop_back (); &#125; // 添加新项目到链表头部 lru_list.push_front (std::make_pair (key, value)); cache_map [key] = lru_list.begin (); &#125; else &#123; // 更新已存在的键值对的值，然后移到链表头部表示最近使用 cache_map [key]-&gt;second = value; moveToFront (key); &#125; &#125;private: int capacity; std::unordered_map&lt;int, std::list&lt;std::pair&lt;int, int&gt;&gt;::iterator&gt; cache_map; std::list&lt;std::pair&lt;int, int&gt;&gt; lru_list; // 将键值对移到链表头部 void moveToFront (int key) &#123; auto it = cache_map [key]; lru_list.splice (lru_list.begin (), lru_list, it); cache_map [key] = lru_list.begin (); &#125;&#125;; 206. 反转链表看了下提交记录，应该是复制粘贴，主要是cpp不熟，改天重写一遍 这里就记录一下官方答案吧 123456789101112131415161718192021222324/ * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return ret; &#125;&#125;; 3 无重复字符的最长子串独立编写 代码1234567891011121314151617181920212223int lengthOfLongestSubstring(string s)&#123; string temp; int ftemp = 0; for(int i = s.length(); i &gt; 0; i--) &#123; if (temp.find(s[s.length() - i]) &gt; temp.length()) // 无重复 temp.find(s[s.length() - i]) == -1 但会很大 所以 &#123; // 无重复 temp.push_back(s[s.length() - i]); ftemp = temp.length() &gt; ftemp ? temp.length() : ftemp; &#125; else &#123; // 有重复 i += (temp.length() - temp.find(s[s.length() - i]) - 1); temp.clear(); temp.push_back(s[s.length() - i]); ftemp = temp.length() &gt; ftemp ? temp.length() : ftemp; &#125; &#125; return ftemp;&#125; 使用到的函数1234string::find(char c) // 返回c在string中的位置 无则返回string::nposstring::length() // 返回string的长度string::push_back(char c) // 在string的末尾添加cstring::clear() // 清空string 思路刚开始看错了题 做完去看评论 发现这个题的思路是滑动窗口 然鹅我不知道那是什么东东 只是大概理解字面意思 这道题主要用到思路是：滑动窗口 什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要把队列的左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 时间复杂度：O(n)O(n)O(n) 作者：powcai链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/3982/hua-dong-chuang-kou-by-powcai/ 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结c++ 很多特性还不会用 要继续学习","tags":["💻Code","🙂Leetcode"],"categories":["💻Code"]},{"title":"旭日 x3PI RealSense人体关键点识别","path":"/posts/6306f887/","content":"起因简单介绍一下我的目标 获取部分人体关键点的空间坐标 控制双臂机器人进行拥抱 首次尝试2022.11 开始做识别部分的内容，开始挑选硬件这是当时小组会的PPT X3就不用多说了 非常强大 初次接触人体关键点识别刚开始是拿了一个普通的USB摄像头进行识别，但是摄像头的输出像素格式是YUYV，当时关键点识别还只能用mjpeg的USB摄像头或者MIPI的摄像头，于是乎买了官方的MIPI进行尝试 效果确实不错，但是我不光要关键点的二维坐标，还要三维坐标，这里就需要深度相机了 实验室刚好有一台Intel的深度相机435，折腾了好久，因为并不熟悉这些东西，最后也没折腾出来 仔细想想，机器人头上装俩摄像头就很奇怪，想想就脑壳痛。 当时问群里的开发人员，他们说这个相机暂时不支持，后面可能会支持。其实当时已经有codec模块了，但是好像没有文档，反正是没找到。 所以转去了用笔记本做主控，但是因为一些结构上的原因我又回来了 其实也就花了两天的时间，比我移植ALPHAPOSE快多了 RealSense 人体关键点识别先讲一下整体思路 Realsense node发布的是rgb格式的图像，使用hobot_codec把rgb转成jpeg jpeg转nv12（rgb8好像不能转nv12 我也不知道为什么 程序说的）,最后nv12送给mono2d_body_detection 就可以了 安装realsense2 SDK设置网络环境这里因为网络原因需要设置一下GITHUB的代理的host，不然无法访问。 打开https://www.ipaddress.com/ 输入raw.githubusercontent.com 查询IP地址 找不到就一直往下滑，直到找到 把找到的ip按这个格式保存好 12345140.82.112.3 github.com185.199.108.133 raw.githubusercontent.com185.199.109.133 raw.githubusercontent.com185.199.110.133 raw.githubusercontent.com185.199.111.133 raw.githubusercontent.com 编辑hosts文件 123456sudo vim /etc/hosts# 重启网络/etc/init.d/networking restart # ping一下试试ping raw.githubusercontent.com 添加ROS apt源1234567sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasesudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/nullsudo apt update 安装Realsense SDK这一步因为网络原因可能会比较漫长，耐心等待，不如起来活动活动吃个饭。 1234567# 显示ROS当前版本，如果显示为空，请source /opt/tros/setup.bashecho $ROS_DISTRO # 安装RealSense SDKsudo apt-get install ros-$ROS_DISTRO-librealsense2* -y # 安装RealSense ros wrappersudo apt-get install ros-$ROS_DISTRO-realsense2-camera -ysudo apt-get install ros-$ROS_DISTRO-realsense2-description -y 建立软连接123cd /opt/tros## 使用/opt/tros目录下的create_soft_link.py创建ROS package至tros.b的软连接sudo python3 create_soft_link.py --foxy /opt/ros/foxy/ --tros /opt/tros/ 到这里Realsense2 SDK就安装完成了 运行测试运行前要先： source /opt/ros/foxy/setup.bash 然后： source /opt/tros/setup.bash 运行程序： ros2 launch realsense2_camera rs_launch.py depth_module.profile:=640x480x15 这里要感谢一下王卓大佬 运行这里我写了个脚本，保存为.sh文件，然后运行就好了，当然你也可以一步步运行看看哪里出错了 12345678910111213141516171819202122232425echo &#x27;设置ros2环境变量&#x27;source /opt/ros/foxy/setup.bashsource /opt/tros/setup.bashsleep 5echo &#x27;启动ros2 realsense 节点&#x27;ros2 launch realsense2_camera rs_launch.py depth_module.profile:=640x480x15 &amp;sleep 5echo &#x27;启动ros2 rgb8 2 jpeg 节点&#x27;ros2 run hobot_codec hobot_codec_republish --ros-args -p channel:=0 -p in_mode:=ros -p in_format:=rgb8 -p out_mode:=ros -p out_format:=jpeg -p sub_topic:=/camera/color/image_raw -p pub_topic:=/image_jpeg --log-level error &amp;sleep 5echo &#x27;启动ros2 jpeg 2 nv12 节点&#x27;ros2 run hobot_codec hobot_codec_republish --ros-args -p channel:=1 -p in_mode:=ros -p in_format:=jpeg -p out_mode:=shared_mem -p out_format:=nv12 -p sub_topic:=/image_jpeg -p pub_topic:=/hbmem_img --log-level error &amp;sleep 5echo &#x27;启动ros2 websocket 节点&#x27;ros2 run websocket websocket --ros-args -p image_topic:=/image_jpeg -p image_type:=mjpeg -p smart_topic:=/hobot_mono2d_body_detection --log-level error &amp;sleep 5echo &#x27;启动ros2 mono2d_body_detection 节点&#x27;ros2 run mono2d_body_detection mono2d_body_detection --log-level error &amp;sleep 5echo &#x27;启动ros2 websocket 节点&#x27;ros2 launch websocket hobot_websocket.launch.py &amp; 需要注意的是 rgb8(ros) -&gt; jpeg(ros) -&gt; nv12(shared_mem) -&gt; mono2d_body_detection 参考链接安装realsense SDK参考：https://c-gitlab.horizon.ai/HHP/box/hobot_slam/orb_slam3 软链接参考：https://developer.horizon.ai/api/v1/fileData/TogetherROS/quick_start/install_use_ros_pkg.html codec参考：https://c-gitlab.horizon.ai/HHP/box/hobot_codec 注如果有哪里有问题，包括我的问题和你运行的问题，欢迎评论指出，我会及时修改 这里还要感谢一下王卓大佬 关于realsense 的文档藏的也太深了。。。 To Do深度信息获取与计算表情视频切换播放","tags":["ROS2","X3PI","RealSense"],"categories":["💻Code"]},{"title":"FreeRTOS 参数配置","path":"/posts/a7f7097f/","content":"注：大部分内容为 AI 回答，仅作整理汇总 CMSIS_V 1 vs CMSIS_V 2当然 V2 更好 宏定义MPU FPUENABLE_MPUENABLE_MPU 是一个宏定义，用于启用或禁用 ARM Cortex-M 处理器的内存保护单元（MPU）。MPU 是一种硬件机制，用于实现内存保护和访问控制，可以帮助确保系统的安全性和稳定性。 当 ENABLE_MPU 宏被定义时，意味着 MPU 被启用，系统将使用 MPU 提供的内存保护和访问控制功能。这意味着您可以配置 MPU 来限制特定区域的内存访问权限，例如只读、只写、可执行等，从而增强系统的安全性。 在一些 RTOS（实时操作系统）或者裸机应用中，启用 MPU 可以提供额外的内存保护，防止错误的内存访问导致系统崩溃或者数据损坏。然而，MPU 的配置需要仔细的设计和调试，因为不正确的配置可能会导致系统功能异常或者性能下降。 因此，在启用 ENABLE_MPU 宏之前，需要确保对 MPU 的配置和使用有充分的理解，并根据系统的需求进行合适的配置。 ENABLE_FPUENABLE_FPU 是一个宏定义，用于启用或禁用 ARM Cortex-M 处理器的浮点单元（FPU）。FPU 是一种硬件模块，用于执行浮点数运算，包括单精度和双精度浮点数的加减乘除等操作。 启用 ENABLE_FPU 宏意味着您的处理器支持 FPU，并且编译器将会生成相应的浮点数运算指令。通常情况下，当您的应用需要进行大量的浮点数计算时，启用 FPU 可以提高运算速度和效率。 在一些 RTOS（实时操作系统）或者裸机应用中，启用 FPU 可以使您的应用能够充分利用硬件浮点单元，从而提高性能。 要通过代码启用 FPU，具体的步骤因芯片和开发环境而异，但一般情况下包括以下几个方面： 设置处理器中的 FPU：在一些芯片中，您需要在启动代码或初始化代码中设置处理器的 FPU。这通常涉及将相应的寄存器设置为启用 FPU。 编译器选项：您需要确保编译器正确地配置为支持 FPU。这可能需要在编译器选项中设置一些标志，以告知编译器您的处理器支持 FPU，并启用相应的优化。 启用 FPU 相关的 CMSIS 配置：如果您在使用 CMSIS（Cortex Microcontroller Software Interface Standard）的话，您可能需要确保 CMSIS 配置正确，以便使用 FPU 相关的功能和优化。 内核设置USE_PREEMPTIONUSE_PREEMPTION 是一个宏定义，用于启用或禁用 RTOS 中的抢占式调度。在 RTOS 中，任务可以按照优先级抢占式地运行，这意味着当更高优先级的任务准备就绪时，它可以抢占当前正在执行的任务，从而立即执行。 启用 USE_PREEMPTION 宏表示您希望 RTOS 支持抢占式调度。这使得更高优先级的任务能够在需要时立即执行，从而提高系统的响应性和实时性。通常情况下，对于需要实时性能的系统，启用抢占式调度是一个好的选择。 在启用抢占式调度时，需要考虑以下几个方面： 任务优先级：确保您为任务分配了适当的优先级。较高优先级的任务将能够抢占较低优先级的任务。 临界区保护：由于任务可以被抢占，因此在访问共享资源时需要使用适当的同步机制，如信号量、互斥量或者临界区保护。这可以防止在多任务环境下出现数据竞争和不一致性。 任务设计：要注意任务的设计，确保它们的执行时间尽可能短，以便更容易被抢占。如果任务执行时间过长，可能会降低系统的响应性。 调度策略：在使用抢占式调度时，RTOS 通常会根据任务的优先级来确定下一个要执行的任务。您可能需要了解 RTOS 的调度策略，并根据需要进行配置。 下面是一个简单的示例代码，演示了如何在 FreeRTOS 中启用抢占式调度： 12345678910111213141516171819202122232425262728293031#include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;// 定义任务函数void Task1(void *pvParameters) &#123; while (1) &#123; // 执行任务1的工作... &#125;&#125;void Task2(void *pvParameters) &#123; while (1) &#123; // 执行任务2的工作... &#125;&#125;int main(void) &#123; // 启用抢占式调度 #define USE_PREEMPTION 1 // 创建任务1 xTaskCreate(Task1, &quot;Task1&quot;, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL); // 创建任务2 xTaskCreate(Task2, &quot;Task2&quot;, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL); // 启动调度器 vTaskStartScheduler(); return 0;&#125; 在上述示例中，我们在 FreeRTOS 中启用了抢占式调度，并创建了两个任务 Task1 和 Task2。由于它们具有相同的优先级，因此它们将以轮询的方式运行，RTOS 会根据任务的优先级来决定下一个要运行的任务。 确保您的 RTOS 正确配置和编译，并遵循 RTOS 的使用规范，以确保您的应用能够正确地利用抢占式调度。 CPU_CLOCK_HZCPU_CLOCK_HZ 是一个宏定义，用于指定 CPU 的时钟频率，通常以赫兹（Hz）为单位。在 RTOS 或其他嵌入式系统中，指定正确的 CPU 时钟频率对于确保系统正常运行至关重要。 设置正确的 CPU 时钟频率可以确保任务的时间片（如果使用抢占式调度）和延迟函数（如果存在）的准确性。此外，许多外设和定时器也依赖于 CPU 时钟频率来计算其操作。 通常情况下，CPU_CLOCK_HZ 的值应该与您的实际硬件平台的 CPU 时钟频率相匹配。这个值通常在启动代码或配置文件中设置。在一些 RTOS 中，您可能需要在操作系统配置文件中指定 CPU 时钟频率。 TICK_RATE_HZTICK_RATE_HZ 是一个宏定义，用于指定 FreeRTOS 中的系统时钟节拍频率，通常以赫兹（Hz）为单位。它定义了系统中定时器中断的触发频率，决定了任务调度器的运行频率以及 FreeRTOS 中延时函数的精度。 系统的节拍频率应该是一个能够满足系统实时性需求的合适值。通常情况下，它应该足够高，以便系统能够及时响应各种事件和任务，但又不能太高，以免消耗过多的处理器资源。 典型的 TICK_RATE_HZ 值可以是几十赫兹（例如 100 Hz、200 Hz）到几百赫兹（例如 1 kHz、10 kHz）不等。具体的选择取决于系统的实际需求和硬件能力。 较高的 TICK_RATE_HZ 值通常会提高系统的响应速度和实时性，但也会增加系统的负载和能耗。因此，在选择 TICK_RATE_HZ 的值时需要权衡这些因素。 以下是一些常见的 TICK_RATE_HZ 值的示例： 100 Hz：用于一般嵌入式应用，对实时性要求不是非常高的场景。 200 Hz：用于具有中等实时性要求的应用，对实时性有一定的要求。 1 kHz：用于对实时性要求较高的应用，如实时控制系统等。 10 kHz：用于对实时性要求非常高的应用，如高性能控制系统等。 您可以根据系统的实际需求和性能要求选择适当的 TICK_RATE_HZ 值。在设置 TICK_RATE_HZ 值时，还需要考虑系统的处理器速度和其他硬件限制，以确保系统的稳定性和性能。 MAX_PRIORITIESMAX_PRIORITIES 是一个宏定义，用于指定 FreeRTOS 中任务的最大优先级数目。在 FreeRTOS 中，任务的优先级通常从 0 开始，较小的数值表示较高的优先级，因此 MAX_PRIORITIES 定义了系统中可用的最大任务优先级数目。 适当地选择 MAX_PRIORITIES 的值非常重要，因为它直接影响了系统的资源管理、任务调度和实时性能。选择过小的 MAX_PRIORITIES 可能会导致任务优先级不足以满足系统的需求，而选择过大的 MAX_PRIORITIES 则可能会浪费系统资源和降低系统性能。 一般来说，您应该根据系统的实际需求来选择合适的 MAX_PRIORITIES 的值。以下是一些考虑因素： 任务的优先级需求： 您需要考虑系统中各个任务的优先级关系，并确保 MAX_PRIORITIES 的值足够大，以便为所有任务分配合适的优先级。通常情况下，系统中可能会有一些关键任务，它们需要较高的优先级，以确保它们能够及时响应各种事件。 系统的复杂性： 如果系统比较复杂，可能需要更多的任务优先级来管理各种任务之间的依赖关系和执行顺序。较大的 MAX_PRIORITIES 值可以提供更灵活的任务调度策略，但也会增加系统的复杂性。 系统资源限制： 考虑系统的内存和处理器资源限制，以及 FreeRTOS 对于任务管理的开销。选择过大的 MAX_PRIORITIES 值可能会消耗过多的系统资源，降低系统的性能。 通常情况下，MAX_PRIORITIES 的值可以选择为 4 到 32 之间的数值。这个范围通常能够满足大多数嵌入式系统的需求。在选择 MAX_PRIORITIES 的值时，建议先对系统进行一些简单的分析和设计，以确定任务优先级的需求，并根据需求来选择合适的值。 MINIMAL_STACK_SIZEMINIMAL_STACK_SIZE 是一个宏定义，用于指定 FreeRTOS 中任务的最小堆栈大小，通常以字节为单位。堆栈是用于存储任务执行期间局部变量、函数调用和中断处理的重要内存区域。适当设置堆栈大小对于确保任务的正常运行和系统的稳定性非常重要。 在 FreeRTOS 中，每个任务都需要一个堆栈，堆栈的大小取决于任务执行期间所需的内存空间。MINIMAL_STACK_SIZE 定义了任务堆栈的最小大小，确保任务有足够的堆栈空间来执行其功能。 通常情况下，您可以根据任务的功能和使用的变量数量来选择适当的 MINIMAL_STACK_SIZE 值。以下是一些考虑因素： 任务的功能和复杂性： 如果任务执行复杂的计算或涉及大量的函数调用、局部变量和参数传递，那么它可能需要更大的堆栈空间。 中断处理： 如果任务需要处理频繁的中断，或者在中断处理函数中执行大量的操作，那么它可能需要更大的堆栈空间来存储中断处理的上下文。 系统资源限制： 考虑系统的内存限制和任务数量，以及 FreeRTOS 对于堆栈管理的开销。选择合适的 MINIMAL_STACK_SIZE 值可以确保系统的稳定性和性能。 通常情况下，MINIMAL_STACK_SIZE 的值可以选择为几百字节到几千字节之间的数值。对于简单的任务，可能只需要几百字节的堆栈空间，而对于复杂的任务或处理大量数据的任务，则可能需要几千字节的堆栈空间。 在选择 MINIMAL_STACK_SIZE 的值时，建议先对任务的功能和资源使用情况进行评估，然后根据评估结果来选择适当的值。确保为任务分配足够的堆栈空间，以避免堆栈溢出和系统崩溃。 MAX_TASK_NAME_LENMAX_TASK_NAME_LEN 是一个宏定义，用于指定 FreeRTOS 中任务名称的最大长度。在 FreeRTOS 中，每个任务都可以有一个唯一的名称，用于标识和调试目的。MAX_TASK_NAME_LEN 定义了任务名称的最大长度，确保任务名称能够被正确地存储和管理。 适当设置 MAX_TASK_NAME_LEN 对于确保任务名称能够满足系统的标识和调试需求非常重要。通常情况下，任务名称的长度应该足够长，以包含有意义的信息，并能够清晰地标识任务的功能或用途。 以下是一些考虑因素： 任务名称的信息量： 任务名称应该能够清晰地表达任务的功能或用途，以便于系统的标识和调试。较长的任务名称可能包含更多的信息，但也可能会增加系统的开销和复杂性。 系统资源限制： 考虑系统的内存限制和任务数量，以及 FreeRTOS 对于任务管理的开销。选择合适的 MAX_TASK_NAME_LEN 值可以确保系统的稳定性和性能。 通常情况下，MAX_TASK_NAME_LEN 的值可以选择为几十到几百之间的数值。对于大多数嵌入式系统，任务名称通常不会特别长，因此可以选择一个适度的值来满足系统的需求。 在选择 MAX_TASK_NAME_LEN 的值时，建议先评估系统的标识和调试需求，并根据需求来选择合适的值。确保任务名称能够清晰地表达任务的功能或用途，同时又不会增加系统的开销和复杂性。 USE_16_BIT_TICKS32 - 32 USE_16_BIT_TICKS 是一个宏定义，用于指定 FreeRTOS 是否使用 16 位的节拍计数器。在 FreeRTOS 中，节拍计数器用于跟踪系统运行的时间，以及计算任务延时和超时等。如果启用了 USE_16_BIT_TICKS 宏，FreeRTOS 将使用 16 位的节拍计数器；否则，将使用较长的节拍计数器（通常是 32 位）。 启用 USE_16_BIT_TICKS 可以节省内存空间，因为 16 位的计数器比较短，需要的内存更少。这在内存资源有限的嵌入式系统中尤其有用。 然而，使用 16 位的计数器也会带来一些限制。由于计数器的长度较短，它们的溢出周期也会相应地变短。这意味着系统运行的时间可能会受到限制，而任务的延时和超时也会受到影响。因此，启用 USE_16_BIT_TICKS 时需要谨慎考虑系统的实时性需求。 通常情况下，如果系统的实时性要求不是特别严格，而且内存资源有限，那么启用 USE_16_BIT_TICKS 可能是一个合适的选择。但如果系统的实时性要求比较高，或者需要较长的运行时间，那么可能需要禁用 USE_16_BIT_TICKS，以使用更长的计数器来确保系统的正确运行。 在启用或禁用 USE_16_BIT_TICKS 时，建议根据系统的具体需求进行评估，并进行充分的测试和验证，以确保系统能够满足实时性和稳定性要求。 IDLE_SHOULD_YIELDIDLE_SHOULD_YIELD 是一个宏定义，用于指定 FreeRTOS 中空闲任务（Idle Task）是否应该在没有其他任务需要执行时主动让出 CPU。如果启用了 IDLE_SHOULD_YIELD 宏，空闲任务将在空闲时执行 taskYIELD() 函数，从而让出 CPU，允许其他更高优先级的任务运行。 启用 IDLE_SHOULD_YIELD 可以提高系统的响应速度，因为空闲任务可以主动让出 CPU，让其他任务更快地执行。这对于实时性要求较高的系统尤其有用，可以确保任务能够及时地响应各种事件和输入。 然而，需要注意的是，在某些情况下，让出 CPU 可能会带来一些额外的开销和性能损失。如果系统中存在大量的空闲时间，而且没有其他更高优先级的任务需要执行，那么频繁地让出 CPU 可能会降低系统的效率。 因此，在启用 IDLE_SHOULD_YIELD 时需要谨慎考虑系统的实际情况和性能需求。如果系统的空闲时间较少，或者没有其他更高优先级的任务需要执行，那么可能不需要启用 IDLE_SHOULD_YIELD。 在配置 FreeRTOS 时，可以根据系统的实际需求来决定是否启用 IDLE_SHOULD_YIELD。需要权衡系统的实时性、响应速度和性能等因素，以选择合适的配置选项。 USE_MUTEXESUSE_MUTEXES 是一个宏定义，用于指定 FreeRTOS 是否支持互斥量（Mutexes）。互斥量是一种同步原语，用于在多任务系统中保护共享资源，以防止多个任务同时访问导致数据不一致或竞争条件的发生。 启用 USE_MUTEXES 宏表示您希望在 FreeRTOS 中使用互斥量来保护共享资源。当任务需要访问共享资源时，它可以获取互斥量，这样其他任务就无法同时访问该资源，直到释放了互斥量为止。 互斥量在许多多任务系统中都是非常常见和重要的同步机制，特别是在需要保护关键资源或临界区的情况下。通过使用互斥量，可以确保数据的完整性和一致性，避免竞争条件和数据访问冲突的发生。 启用 USE_MUTEXES 可以提高系统的可靠性和稳定性，确保任务之间的合作和数据共享能够正常进行。但需要注意的是，互斥量的过度使用可能会导致死锁和性能下降，因此需要合理地设计和使用互斥量来避免这些问题的发生。 在配置 FreeRTOS 时，可以根据系统的实际需求和资源限制来决定是否启用 USE_MUTEXES。如果系统中存在共享资源需要保护，那么启用互斥量是一个明智的选择。 USE_RECURSIVE_MUTEXESUSE_RECURSIVE_MUTEXES 是一个宏定义，用于指定 FreeRTOS 是否支持递归互斥量（Recursive Mutexes）。递归互斥量是一种特殊类型的互斥量，允许同一个任务多次获取同一个互斥量，而不会导致死锁。 在某些情况下，任务可能需要多次获取同一个互斥量，例如在递归调用的函数中，或者在多个层次的函数调用中需要保护共享资源。如果使用普通的互斥量，在任务多次获取同一个互斥量时会导致死锁，因为同一个任务已经持有了该互斥量，再次获取它时会一直等待直到被释放。 启用 USE_RECURSIVE_MUTEXES 宏表示您希望在 FreeRTOS 中支持递归互斥量。这样，同一个任务可以多次获取同一个互斥量，而不会导致死锁。任务可以多次释放递归互斥量，直到与之匹配的获取次数为零，这时其他任务才能获取该互斥量。 递归互斥量在某些情况下是非常有用的，特别是在需要保护共享资源的复杂递归调用或层次结构中。但需要注意的是，滥用递归互斥量可能会导致设计上的复杂性和性能下降，因此需要谨慎使用。 在配置 FreeRTOS 时，可以根据系统的实际需求和资源限制来决定是否启用 USE_RECURSIVE_MUTEXES。如果系统中存在需要在同一个任务中多次获取同一个互斥量的情况，那么启用递归互斥量是一个合理的选择。 USE_COUNTING_SEMAPHORESUSE_COUNTING_SEMAPHORES 是一个宏定义，用于指定 FreeRTOS 是否支持计数信号量（Counting Semaphores）。计数信号量是一种同步原语，用于在多任务系统中管理资源的访问和共享。 启用 USE_COUNTING_SEMAPHORES 宏表示您希望在 FreeRTOS 中支持计数信号量。计数信号量允许多个任务同时访问同一个资源，而不会导致竞争条件或数据不一致的发生。计数信号量的值可以是任意非负整数，表示资源的可用数量。 计数信号量通常用于管理有限资源的访问，例如共享内存池、缓冲区或设备。当任务需要访问资源时，它可以通过获取计数信号量来申请资源，当资源不可用时，任务会被阻塞，直到资源可用为止。任务使用完资源后，通过释放计数信号量来释放资源，以便其他任务可以继续使用。 启用 USE_COUNTING_SEMAPHORES 可以提高系统的可靠性和稳定性，确保任务能够安全地访问和共享资源。但需要注意的是，过度使用计数信号量可能会导致竞争条件和性能下降，因此需要合理地设计和使用计数信号量来避免这些问题的发生。 在配置 FreeRTOS 时，可以根据系统的实际需求和资源限制来决定是否启用 USE_COUNTING_SEMAPHORES。如果系统中存在需要管理有限资源的情况，那么启用计数信号量是一个合理的选择。 QUEUE_REGISTRY_SIZEQUEUE_REGISTRY_SIZE 是一个宏定义，用于指定 FreeRTOS 中队列注册表的大小。在 FreeRTOS 中，队列注册表用于跟踪和管理系统中所有创建的队列，以便于调试和跟踪队列的使用情况。 队列注册表的大小决定了系统中可以注册的队列的最大数量。每个队列都会占用一定的注册表条目，因此 QUEUE_REGISTRY_SIZE 定义了系统中可以同时存在的队列的最大数量。 适当设置 QUEUE_REGISTRY_SIZE 对于确保系统能够正常运行和调试是非常重要的。如果系统中同时存在的队列数量超过了队列注册表的大小，可能会导致一些队列无法被正确管理和跟踪，从而影响系统的稳定性和可靠性。 一般来说，QUEUE_REGISTRY_SIZE 的值应该根据系统中实际使用的队列数量进行估计，并留有一定的余量以应对未来可能的扩展。如果系统中使用了大量的队列，那么 QUEUE_REGISTRY_SIZE 的值就需要设置得比较大；反之，如果系统中使用的队列数量较少，那么 QUEUE_REGISTRY_SIZE 的值可以设置得较小。 在配置 FreeRTOS 时，可以根据系统的实际需求和队列数量来确定 QUEUE_REGISTRY_SIZE 的值。通常建议设置一个合适的默认值，并根据系统的运行情况进行调整和优化。 USE_APPLICATION_TASK_TAGUSE_APPLICATION_TASK_TAG 是一个宏定义，用于指定 FreeRTOS 是否启用任务标记功能（Task Tagging）。任务标记功能允许开发人员为每个任务附加一个标记，以便在调试和分析中识别和跟踪任务。 启用 USE_APPLICATION_TASK_TAG 宏表示您希望在 FreeRTOS 中启用任务标记功能。一旦启用，您可以为每个任务设置一个标记，以便在系统运行时跟踪任务的信息。任务标记可以是任何您认为有用的信息，例如任务的名称、任务的功能、任务的状态等。 任务标记功能在调试和分析大型 FreeRTOS 应用程序时非常有用。通过任务标记，您可以更容易地识别和跟踪任务，了解它们的运行状况和行为，从而更快地定位和解决问题。 在配置 FreeRTOS 时，您可以根据系统的实际需求和调试要求来决定是否启用 USE_APPLICATION_TASK_TAG。如果您需要在运行时跟踪任务，并且任务的信息对于调试和分析非常重要，那么启用任务标记功能可能是一个明智的选择。 需要注意的是，启用任务标记功能可能会增加系统的内存消耗和运行时开销，因此在资源有限的环境中需要权衡使用该功能的成本和收益。 ENABLE_BACKWARD_COMPATIBILITYENABLE_BACKWARD_COMPATIBILITY 是一个宏定义，用于指定是否启用 FreeRTOS 的向后兼容性功能。向后兼容性是指新版本的 FreeRTOS 是否能够与旧版本的 FreeRTOS 兼容，以便在升级到新版本时，现有的应用程序可以继续正常运行。 启用 ENABLE_BACKWARD_COMPATIBILITY 宏表示您希望在新版本的 FreeRTOS 中启用向后兼容性功能。这意味着新版本的 FreeRTOS 将尽可能地保持与旧版本的接口和行为一致，以确保现有的应用程序可以平稳地升级到新版本，而不需要进行太多的修改和调整。 向后兼容性是非常重要的，特别是对于长期维护的嵌入式系统来说。通过保持向后兼容性，可以降低系统升级的成本和风险，减少因升级导致的问题和不稳定性。 在配置 FreeRTOS 时，您可以根据实际需求和应用程序的情况来决定是否启用 ENABLE_BACKWARD_COMPATIBILITY。如果您的应用程序依赖于旧版本的 FreeRTOS，并且需要平滑地升级到新版本，那么启用向后兼容性功能可能是一个明智的选择。 需要注意的是，启用向后兼容性功能可能会增加新版本 FreeRTOS 的体积和复杂性，因此在资源有限的环境中需要权衡使用该功能的成本和收益。 USE_PORT_OPTIMISED_TASK_SELECTIONUSE_PORT_OPTIMISED_TASK_SELECTION 是一个宏定义，用于指定 FreeRTOS 是否启用端口优化的任务选择功能。任务选择是指在多任务系统中选择下一个要执行的任务的过程。启用此宏将使用端口特定的优化来实现任务选择，以提高系统的性能和效率。 当启用 USE_PORT_OPTIMISED_TASK_SELECTION 宏时，FreeRTOS 将使用特定于硬件平台的任务选择实现，以提高任务切换的速度和效率。这种优化可能会利用硬件的特性或者对任务状态的特定存储方式，从而加速任务的切换过程。 启用端口优化的任务选择功能可以提高系统的性能和效率，特别是在高负载和高实时性要求的系统中。通过减少任务切换的开销，系统可以更快地响应各种事件和任务，提高系统的响应速度和实时性。 在配置 FreeRTOS 时，您可以根据实际硬件平台和性能需求来决定是否启用 USE_PORT_OPTIMISED_TASK_SELECTION。如果您的系统需要更高的性能和效率，并且硬件平台支持端口优化的任务选择功能，那么启用此宏可能是一个合适的选择。 需要注意的是，启用端口优化的任务选择功能可能会增加 FreeRTOS 的复杂性，并且可能会限制其在其他硬件平台上的移植性。因此，在权衡使用此功能时需要考虑这些因素。 USE_TICKLESS_IDLEUSE_TICKLESS_IDLE 是一个宏定义，用于指定 FreeRTOS 是否启用 Tickless Idle 模式。Tickless Idle 模式是一种省电功能，可在系统空闲时让 CPU 进入低功耗模式，以节省能源并延长电池寿命。 当启用 USE_TICKLESS_IDLE 宏时，FreeRTOS 将启用 Tickless Idle 模式。在 Tickless Idle 模式下，系统会动态调整系统定时器的间隔，在任务无需处理时尽可能地延迟系统的时钟中断，以减少 CPU 的唤醒次数，并将 CPU 保持在低功耗模式下。 启用 Tickless Idle 模式可以显著降低系统的功耗，特别是在长时间空闲或低负载情况下。这对于依赖电池供电的嵌入式系统尤其重要，可以延长电池寿命，并减少充电次数。 在配置 FreeRTOS 时，您可以根据系统的实际需求和功耗优化的要求来决定是否启用 USE_TICKLESS_IDLE。如果您的系统依赖电池供电，并且需要最大限度地降低功耗以延长电池寿命，那么启用 Tickless Idle 模式可能是一个明智的选择。 需要注意的是，启用 Tickless Idle 模式可能会增加 FreeRTOS 的复杂性，并且可能会影响系统的实时性能。在启用 Tickless Idle 模式时，需要仔细测试和验证系统的实时性能，以确保满足系统的实时性要求。 USE_TASK_NOTIFICATIONSUSE_TASK_NOTIFICATIONS 是一个宏定义，用于指定 FreeRTOS 是否启用任务通知功能。任务通知是一种轻量级的通信机制，允许任务之间进行同步和通信，而无需使用信号量或消息队列等更重量级的同步原语。 启用 USE_TASK_NOTIFICATIONS 宏表示您希望在 FreeRTOS 中启用任务通知功能。一旦启用，您可以使用任务通知来实现任务之间的同步、事件通知和等待等功能。任务通知可以用于替代信号量、事件组和消息队列等同步原语，从而提高系统的性能和效率。 任务通知是一种非常灵活和高效的通信机制，特别适用于需要高实时性和低延迟的系统。与传统的同步原语相比，任务通知具有更低的内存消耗和更快的响应时间，可以更好地满足实时性要求。 在配置 FreeRTOS 时，您可以根据系统的实际需求和性能要求来决定是否启用 USE_TASK_NOTIFICATIONS。如果您需要在任务之间进行高效的通信和同步，并且希望提高系统的性能和效率，那么启用任务通知功能可能是一个合适的选择。 需要注意的是，任务通知功能可能会增加 FreeRTOS 的复杂性，并且可能需要一些额外的学习和理解来正确地使用。在使用任务通知时，需要注意避免死锁和竞争条件等问题，以确保系统的稳定性和可靠性。post&#x2F;code&#x2F;embedded&#x2F; FreeRTOS 参数配置 Selection deleted FreeRTOS 参数配置 文档属性 FreeRTOS 参数配置 {“headline”:”FreeRTOS 参数配置”,”color”:” #00ffff “} 2024-04-12 19:06:46 Lab STM32 💻Code 添加文档属性 RECORD_STACK_HIGH_ADDRESSRECORD_STACK_HIGH_ADDRESS 是一个宏定义，用于指定 FreeRTOS 是否记录任务堆栈的高地址。当启用 RECORD_STACK_HIGH_ADDRESS 宏时，FreeRTOS 将在任务创建时记录任务堆栈的高地址。 任务堆栈的高地址记录可以帮助识别任务的堆栈使用情况，特别是在调试和优化任务堆栈大小时非常有用。通过记录堆栈的高地址，您可以了解任务实际使用的堆栈大小，从而更好地优化任务堆栈大小，避免堆栈溢出问题。 在启用 RECORD_STACK_HIGH_ADDRESS 宏后，您可以通过调用 uxTaskGetStackHighWaterMark() 函数来获取任务堆栈的高地址记录。这个函数会返回任务堆栈的高地址记录与任务堆栈的当前使用情况之间的差值，这就是任务堆栈的最大使用量。 1234UBaseType_t uxHighWaterMark;// 获取任务堆栈的最大使用量uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL); 通过分析任务堆栈的最大使用量，您可以更好地了解任务的堆栈使用情况，并相应地调整任务堆栈的大小，以确保系统的稳定性和可靠性。 存储相关TOTAL_HEAP_SIZETOTAL_HEAP_SIZE 是一个宏定义，用于指定 FreeRTOS 中用于动态内存分配的堆的总大小。在 FreeRTOS 中，堆用于分配任务、队列、信号量等对象所需的内存空间。 通过设置 TOTAL_HEAP_SIZE，您可以指定 FreeRTOS 可用的总内存量。FreeRTOS 将会从这个总内存池中动态分配内存，用于创建任务、队列、信号量等对象。在运行时，FreeRTOS 会根据需要从堆中分配内存，并在对象不再需要时释放内存，以便其他对象可以重复利用。 在设置 TOTAL_HEAP_SIZE 时，需要根据系统的实际需求和资源限制来确定堆的大小。如果堆的大小设置得太小，可能会导致内存分配失败或者系统性能下降；如果设置得太大，可能会浪费宝贵的内存资源。 通常情况下，可以根据系统的任务数量、队列大小、信号量数量等因素来估算堆的大小。另外，还需要考虑系统的其他内存需求，如栈空间、静态内存分配等。 在设置 TOTAL_HEAP_SIZE 时，建议留有一定的余量，以应对系统在运行时可能出现的内存需求增加的情况。同时，也可以通过监视系统的内存使用情况，根据实际情况调整堆的大小，以达到最佳的性能和稳定性。 以下是一个设置 TOTAL_HEAP_SIZE 的示例： 1#define TOTAL_HEAP_SIZE (20 * 1024) // 设置堆的总大小为20KB 在这个示例中，堆的总大小被设置为 20 KB。您可以根据实际需求修改这个值，并确保系统的稳定性和性能。 Memory Management scheme默认 heap_4 在 FreeRTOS 中，内存管理方案取决于您选择的内存分配器。FreeRTOS 提供了几种内存分配器，可以根据您的需求和平台选择合适的内存管理方案。 Heap_1: Heap_1 是 FreeRTOS 提供的最简单的内存分配器，它使用静态数组作为堆。静态数组的大小由 configTOTAL_HEAP_SIZE 宏定义确定，数组的大小在编译时就被确定。这种分配器非常适合于资源有限的嵌入式系统，它简单、轻量，并且不需要额外的外部依赖。 Heap_2: Heap_2 是另一种简单的内存分配器，它也使用静态数组作为堆，但允许您通过 configAPPLICATION_ALLOCATED_HEAP 宏自定义堆的起始地址和大小。这种分配器允许您将堆放置在特定的内存区域，例如特定的 RAM 区域或者特殊的存储器设备。 Heap_3: Heap_3 是 FreeRTOS 提供的动态内存分配器，它使用标准的 malloc() 和 free() 函数来分配和释放内存。这种分配器非常适合于具有标准 C 库支持的系统，它可以充分利用标准库提供的内存管理功能，并且能够适应不同大小的内存需求。 Heap_4: Heap_4 是一种更高级的内存分配器，它使用先进的分配算法来提高内存分配和释放的效率。它是一种适用于大型系统和高性能系统的内存分配方案，可以有效地管理大量的动态内存，并且具有较低的内存碎片化和内存浪费。 在选择内存管理方案时，需要考虑系统的资源限制、性能要求和实现的复杂度等因素。不同的内存分配器适用于不同的场景，您可以根据您的具体需求选择最合适的内存管理方案。 hook function related definitions在 FreeRTOS 中，钩子函数（hook functions）是一组特殊的函数，允许用户在 FreeRTOS 内核执行关键操作时插入自定义的代码。这些钩子函数可以用于监视系统状态、调试应用程序、实现定制功能等。以下是一些与钩子函数相关的定义： vApplicationMallocFailedHook: 当 FreeRTOS 内核尝试分配内存失败时，将调用此钩子函数。用户可以在此函数中实现自定义的处理逻辑，例如记录错误、采取措施或者进行其他处理。 1void vApplicationMallocFailedHook( void ); vApplicationStackOverflowHook: 当任务堆栈溢出时，将调用此钩子函数。用户可以在此函数中实现自定义的堆栈溢出处理逻辑，例如记录错误、重启系统或者进行其他处理。 1void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ); vApplicationIdleHook: 当系统处于空闲状态时，将调用此钩子函数。用户可以在此函数中实现自定义的空闲处理逻辑，例如休眠处理器、执行低优先级任务等。 1void vApplicationIdleHook( void ); vApplicationTickHook: 每次 FreeRTOS 定时器节拍时，将调用此钩子函数。用户可以在此函数中实现自定义的定时处理逻辑，例如记录系统时间、执行周期性任务等。 1void vApplicationTickHook( void ); vApplicationDaemonTaskStartupHook: FreeRTOS 守护任务启动时，将调用此钩子函数。用户可以在此函数中实现自定义的守护任务启动处理逻辑。 1void vApplicationDaemonTaskStartupHook( void ); vApplicationDaemonTaskStartupHook: FreeRTOS 守护任务启动时，将调用此钩子函数。用户可以在此函数中实现自定义的守护任务启动处理逻辑。 1void vApplicationDaemonTaskStartupHook( void ); 通过实现这些钩子函数，用户可以在 FreeRTOS 内核执行关键操作时插入自定义的处理逻辑，从而更好地监视、调试和优化系统。需要根据实际需求选择合适的钩子函数，并实现相应的处理逻辑。","tags":["💻Code"],"categories":["💻Code"]},{"title":"MoneyProgress_win","path":"/posts/3ouvu5p/","content":"起因前段时间分享了一个MoneyProgress的Mac软件,一直有人在论坛发帖问有没有win版的,恰好最近在看Qt,于是就有了这个项目. 写这个贴子的目的是为了记录一下开发过程,以及遇到的问题. 以后可以拿它做参考,也可以给有需要的人提供一些帮助. MAC版的项目地址: MoneyProgressWIN版的项目地址: MoneyProgress_win 程序很大程度参考了原作者的UI设计,这里再次感谢原作者. 开发环境 Windows 10 20H2(这个不是很重要) Qt 5.15 with Mingw(这个很重要) 开发过程这块看我的commit记录就行了,虽然有点乱,但是基本上都是有用的. 这里只记录一些比较重要的问题,其他的问题可以参考Qt官方文档 多看文档,多看文档,多看文档. 问题1: 图片过大原作者的图片都是png格式,大小足足有3.27MB,分辨率为1024x1024,应该是自己画的吧. 刚开始导入图片设置为label设置样式表background-image: url(:/img/avatar.png); 是这样的: 可以看到图片很大,很奇怪, 解决办法: 设置为border-image: url(:/img/avatar.png); 这样它就会自动缩放了.可以通过设置label的width和height来控制图片的大小. 问题2: 无法获取到正确的屏幕分辨率这个问题是论坛上有人提出来的,我也遇到了. 原代码为: 12345// 这里省略了一些代码// 获取屏幕分辨率高度QApplication::desktop()-&gt;width(); 实际获取的不一定就是当前屏幕的分辨率,有时候会获取到错误的值.比如你有多块屏幕,它会获取到所有屏幕的分辨率的和.就很离谱.这就会导致我们的程序在不同的屏幕上显示的效果不一样.任务栏的弹窗就奇奇怪怪的.甚至看不到. 解决办法: 1234// 这里省略了一些代码QApplication::screenAt(QCursor().pos())-&gt;geometry().width() 意为获取鼠标所在屏幕的分辨率宽度.非常ok. 问题3: 文本无法正常更新问题代码: 因为我想实现每次点击任务栏图标都会弹出一个弹窗,显示当前的挣钱进度,所以我在MoneyProgress类中添加了一个IconMessage类的对象(一个小widget),并且在MoneyProgress类中添加了一个update函数,用来更新弹窗中的文本.同时update还要负责更新主窗口中的文本.所以就有了如下代码 1234567891011121314151617181920void MoneyProgress::update()&#123; // 这里省略了一些代码 // 判断两个界面是否可见 if (this-&gt;isVisible()) &#123; ui-&gt;labelMoneyNow-&gt;setText(&quot;您当前已经挣了&quot;+QString::number(moneyday*progress/1000,&#x27;f&#x27;,1)+&quot;元;&quot;); ui-&gt;labelDay-&gt;setText(&quot;您一月工作&quot; + QString::number(days) + &quot;天;&quot;); ui-&gt;labelMoneyDay-&gt;setText(&quot;您一天能挣&quot; + QString::number(moneyday, &#x27;f&#x27;, 1) + &quot;元;&quot;); ui-&gt;labelHourDay-&gt;setText(&quot;您一天工作&quot; + QString::number(hours, &#x27;f&#x27;, 1) + &quot;小时;&quot;); ui-&gt;labelMoneySecond-&gt;setText(&quot;您一秒钟能挣&quot; + QString::number(moneysecond, &#x27;f&#x27;, 6) + &quot;元;&quot;); &#125; if (iconmessage.isVisible()) &#123; iconmessage.update(progress, moneyday); qDebug() &lt;&lt; progress; &#125;&#125; 可以看到大致思路就是判断两个界面是否可见,如果可见就更新文本.但是任务栏那个小窗口的文本无法更新,调试发现了一个低级错误 12345update(); //错误的写法iconmessage.show();// update(); 把update()放在这里就可以更新了 确实很低级 问题4: QSettings 无效这个问题是在保存时间的时候遇到的,我想把设置保存到QSettings里面,但是发现无论怎么设置都无效.在网上逛了半天,发现是因为QSettings只能在构造函数和析构函数中使用,不能在其他函数中使用. 问题代码: 12345678910//原本设计的是每次设置改变就保存一次,但是发现无效void MoneyProgress::on_timeSleepdown_userTimeChanged(const QTime &amp;time)&#123; // 这里省略了一些代码 settings 是一个QSettings对象,在.h文件中定义 settings.setValue(&quot;sleepDown&quot;, sleepDown); // 保存设置&#125; 解决办法: 将QSettings的保存设置放到析构函数中,这样就可以正常使用了. 12345678910111213141516171819202122MoneyProgress::~MoneyProgress()&#123; QSettings settings(&quot;MuYin&quot;, &quot;MoneyProgress_win&quot;); // 保存设置 settings.setValue(&quot;money&quot;, money); settings.setValue(&quot;days&quot;, days); settings.setValue(&quot;workUp&quot;, workUp); settings.setValue(&quot;workDown&quot;, workDown); settings.setValue(&quot;sleepUp&quot;, sleepUp); settings.setValue(&quot;sleepDown&quot;, sleepDown); // settings.setValue(&quot;geometry&quot;, this-&gt;saveGeometry()); // settings.setValue(&quot;windowState&quot;, this-&gt;saveState()); // 保存设置 settings.sync(); delete ui;&#125; 问题5: QSS样式表不会用因为我设置了标题栏隐藏 this-&gt;setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint); // 隐藏标题栏 所以一直弄不出来borde的样式,最后发现改centralwidget的border属性就可以了. 问题代码: 123456QWidget &#123; background-color: rgb(255, 255, 255); border-width: 3px; border-color: rgba(255, 216, 58, 225); border-radius: 15px;&#125; 解决方法 12345678910QWidget &#123; background-color: rgb(255, 255, 255); border-color: rgba(255, 216, 58, 225); border-radius: 15px;&#125;QWidget#centralwidget &#123; background-color: rgb(255, 255, 255); border: 3px solid #ffee6f; /* border-color: rgba(255, 216, 58, 225); */&#125; css还是不太了解,回头需要好好学习一下. 问题6: 程序整体缩放问题引用网友的话: Qt下高分屏的问题，几乎是一场灾难。希望未来 Qt 能有更好的解决方案。 解决方法: 添加 qt/etc/qt.conf文件,注意这是在qrc文件中的路径,它的完整路径是qrc:/qt/etc/qt.conf,网上说一定不要弄错文件内容的意思为不使用QT的缩放功能,而是使用系统的缩放功能 123[Platforms]WindowsArguments = dpiawareness=0 具体看这个commit 问题7: QtCreator 无法Debug将build模式从release改为debug就可以了……………………………. 总结项目不大,时间也不算长,大概两三个晚上的样子,但是在这个过程中学到了很多东西,比如说QSettings的使用,QSS的使用,QTimer的使用,QApplication::screenAt(QCursor().pos())-&gt;geometry().width()的使用,以及一些小技巧,比如说QSettings只能在构造函数和析构函数中使用,QSS的border属性要写在centralwidget上,QTimer的start函数可以传入一个参数,表示延迟多久开始计时,QApplication::screenAt(QCursor().pos())-&gt;geometry().width()可以获取鼠标所在屏幕的分辨率宽度等等. 最后希望大家能够多多支持,如果有什么问题,欢迎指正,可以在评论区留言,我会尽快回复的.","tags":["💻Code","📃Study","📦QT"],"categories":["💻Code"]},{"title":"ROS2自定义消息使用记录","path":"/posts/2llqu4i/","content":"起因最近在做人体姿态估计的项目,需要用到ROS2,但是ROS2的消息类型不够用,所以需要自定义消息类型,这里记录一下自定义消息类型的过程. 使用的工具如下 ROS2 Humble VSCode Alphapose 之前跟着官方文档做过一次,但是学会了,但又没学会.这次是真的要用,反而出问题了. 自定义消息类型之前以为每个包里面都可以自定义消息,但是想多了,需要独立的包来存放自定义消息. 创建包1ros2 pkg create --build-type ament_python --node-name people_msgs people_msgs 创建消息1234# Point.msgfloat32 xfloat32 yfloat32 z 12# People.msg 以为人体关键点是26个,所以这里就写26个,但是后面发现出了问题Point[26] keypoints 记住这个26,问题就出在这里. 12# PeopleArray.msgPeople[] people 编译1colcon build --packages-select people_msgs 使用心 待完成 [ ](https://oss.xljsci.com//download/%E5%B0%8F%E7%BB%BF%E9%B2%B8%E8%8B%B1%E6%96%87%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E5%99%A8_setup_2.3.6.exe) [ 下载pad端 ](https://oss.xljsci.com//download/%E5%B0%8F%E7%BB%BF%E9%B2%B8%E8%8B%B1%E6%96%87%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E5%99%A8_setup_2.3.6.exe) 帮助 0.1M&#x2F;2.32G 开通鲸会员 首页 20231219-2023年度学生党支部书记抓党建述职暨推优工作通知20231219-2023年度学生党支部书记抓党建述职暨推优工作通知 鲸译AI通用版 鲸译AI机械工程版 跟随 译文 锁定 连翻 复制 14 23 years 原文 选中下方词组添加为术语和单词 复制 修改 23 年度 反馈 笔记 信息 写作 单词 速读 解析 汇报 上传完成（1&#x2F;1） 20231219-2023年度学生党支部书记抓党建述职暨推优工作通知.pdf 去阅读&#96;&#96;&#96;bashsource install&#x2F;setup.bash 1234567## 使用自定义消息### 创建包```bashros2 pkg create --build-type ament_python --node-name people_sub people_sub 编写代码1234567891011121314151617181920212223242526272829303132333435363738394041# people_sub.pyimport rclpyfrom rclpy.node import Nodefrom people_msgs.msg import PeopleArrayclass PeopleSub(Node): def __init__(self): super().__init__(&#x27;people_sub&#x27;) self.sub = self.create_subscription(PeopleArray, &#x27;people&#x27;, self.people_callback, 10) def people_callback(self, msg): self.get_logger().info(&#x27;I heard: %s&#x27; % msg) def getnode(self): # 假如说这是识别后处理关键点的函数 peoplearray = PeopleArray() for i in peoplelist: # 假如说这是识别后所有人的列表 people = People() # people.keypoints.clear() # 这里是关键,不然会出问题 for j in i: #每个人身上的关键点 point = Point() point.x = j[0] point.y = j[1] point.z = j[2] people.keypoints.append(point) peoplearray.people.append(people) return peoplearray return selfdef main(args=None): rclpy.init(args=args) people_sub = PeopleSub() rclpy.spin(people_sub) people_sub.destroy_node() rclpy.shutdown()if __name__ == &#x27;__main__&#x27;: main() 编译1colcon build --packages-select people_sub 使用12source install/setup.bashros2 run people_sub people_sub 问题我使用自定义消息进行接收,发现接收到的消息是空的,后来发现是因为我在创建消息的时候,它会默认创建一个空的消息(26个数据都是0),所以我在创建消息的时候,需要先清空消息,然后再添加数据. 感悟果然实践是检验真理的唯一标准 这次的问题是单步调试出来的,调试之前处理了python路径的问题,不然无法使用VSCode调试. python扩展路径问题12# 1.通过脚本查看python路径python -c &quot;import sys; print(sys.path)&quot; 设置环境vscode路径 Python扩展 设置 -&gt; Pythoninterpreter Path -&gt; (&#x2F;usr&#x2F;bin&#x2F;python3)换成上一步的路径即可解决 还有个问题我问了下GPT ROS2使用自定义Python解释器要指定ROS 2使用的Python解释器，您可以设置环境变量PYTHON_EXECUTABLE，将其设置为要使用的Python解释器的路径。例如，假设您的自定义Python解释器位于&#x2F;path&#x2F;to&#x2F;my&#x2F;python，则可以使用以下命令在终端中设置环境变量： export PYTHON_EXECUTABLE=/path/to/my/python 设置环境变量后，ROS 2将使用指定的Python解释器。您可以在启动ROS 2节点时验证Python解释器是否正确设置，例如： ros2 run my_package my_node --ros-args --log-level debug 这将在终端输出ROS 2节点的日志信息，其中包括使用的Python解释器。如果您看到的输出中包含您自定义的Python解释器路径，则表示ROS 2正在使用指定的Python解释器。 注意，设置自定义Python解释器可能会导致ROS 2某些功能无法正常工作，因为ROS 2可能依赖于特定版本的Python和Python库。如果您遇到问题，请尝试使用ROS 2默认的Python解释器，或者确保您的自定义Python解释器与ROS 2所需的Python版本和库兼容。","tags":["ROS2"],"categories":["💻Code"]},{"title":"自用软件分享","path":"/posts/ed992427/","content":"废话不多说，直接开始 本站不提供任何下载，只做介绍，资源请自行寻找 WindowsLinux我的软件","tags":["💻Software"],"categories":["💻Software"]},{"title":"2022照片故事分享","path":"/posts/6679f469/","content":"虽然我不经常拍照，但是我还是有一些照片的，分享一下这些照片的故事(简短)。 12 回家躺尸 11 开始接触旭日x3派，非常不错的一块板子，但是它不带gpu 10 我以为那是一只松鼠，可惜不是 9 辛苦打工人，玩各种模块 8 在寝室躺尸，那天天气很红 7辛苦打工人 6 毕业 5 入党 4 跟3d打印机干架（维修） 3 樱花真的很美，但看多了也就习惯了，香味很喜欢 2 考研找导师 1 折腾内网穿透","tags":["Life"],"categories":["💻Code"]},{"title":"串口应用层通信协议代码解析","path":"/posts/a941f9c6/","content":"背景介绍串口这里不再多说，不懂的进链接去了解一下。在STM32中，串口的通信协议一般是应用层协议，即上位机和下位机之间的通信协议。这里的应用层协议是师兄设计的，之前也看过几遍，但没看懂，今天来仔细分析一下。 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) 是串口接收中断的回调函数，简单理解就是每次串口接收到数据都会调用这个函数。 协议格式123456789A00B0000// A后面的两位数字代表通道号// B后面的四位数字代表值// 注：均为字符格式A01B1200 代码正文1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;\t/*define a symbol\trcvstate:\t| 7\t| 6\t| 5\t|\t4 |3|\t2|\t1|\t0|\tstate bit |&#x27;A&#x27;received|&#x27;B&#x27;received|cmd rcv cplt| ERROR\t| receive index |\t*/\tstatic uint8_t rcvstate = 0x00; switch (UART_RCV_DATA)\t//switch the received data &#123; case &#x27;A&#x27;:\t//data head is &#x27;A&#x27; UART_RCV_BUFFER[0] = &#x27;A&#x27;; rcvstate |= 0x81;\t//set A flag and data cnt 1 break; case &#x27;B&#x27;:\t//data head2 is &#x27;B&#x27; if(rcvstate == 0x83)\t//if get &#x27;A&#x27; and data index equals 3 &#123; rcvstate = 0xC4;\t//set A and B flag and data cnt 4 UART_RCV_BUFFER[3] = &#x27;B&#x27;; &#125; else &#123; rcvstate = 0x00;\t//reset state &#125; break; default: if(UART_RCV_DATA - &#x27;0&#x27; &lt;= 9)\t//check if data is numbers &#123; if(rcvstate &amp; 0xC0)\t//if rcvstate is 0x8X or 0xCX, result is true &#123; UART_RCV_BUFFER[rcvstate &amp; 0x0F] = UART_RCV_DATA;\t//save data to buffer[index] rcvstate += 1;\t//data index increase &#125; else &#123; rcvstate = 0x00;\t//reset state &#125; &#125; else\t//other data received &#123; //now no other CMD is defined rcvstate = 0x00;\t//reset state &#125; if((rcvstate &amp; 0x0F) == 8)\t//Data receive completed &#123; rcvstate |= 0x20;\t//SET complete flag /* CMD_temp: high 16 bits =\tContral Channel low 16 bits =\tContral Value */ uint32_t CMD_temp = 0x00000000; CMD_temp = 10 * (UART_RCV_BUFFER[1] - &#x27;0&#x27;)\t//calculate ctrl channel + (UART_RCV_BUFFER[2] - &#x27;0&#x27;); CMD_temp &lt;&lt;= 16;\t//move channel data to high 16 bits CMD_temp += 1000 * (UART_RCV_BUFFER[4] - &#x27;0&#x27;)\t//calculate ctrl value + 100 * (UART_RCV_BUFFER[5] - &#x27;0&#x27;) + 10 * (UART_RCV_BUFFER[6] - &#x27;0&#x27;) + 1 * (UART_RCV_BUFFER[7] - &#x27;0&#x27;); //send CMD message if(osMessageQueuePut(CMD_QueueHandle, &amp;CMD_temp, 0, 0) == osOK) &#123; rcvstate = 0x00;\t//reset state &#125; else &#123; rcvstate |= 0x10;\t//report error &#125; &#125; break; &#125;\tif(rcvstate &amp; 0x10)\t//ERROR report signal\t&#123; //send error report rcvstate = 0x00;\t//reset state\t&#125;&#125; 解析过程代码里面有注释可以参考，口头表述比较困难这里用结果来表示吧。 1234567891011121314151617//char input[13] = &quot;A02B0005CCCC&quot;;输入的数据为 :A rcvstate: 81输入的数据为 :0 rcvstate: 82输入的数据为 :2 rcvstate: 83输入的数据为 :B rcvstate: c4输入的数据为 :0 rcvstate: c5输入的数据为 :0 rcvstate: c6输入的数据为 :0 rcvstate: c7输入的数据为 :5 rcvstate: e8输入的数据为 :C rcvstate: 0输入的数据为 :C rcvstate: 0输入的数据为 :C rcvstate: 0输入的数据为 :C rcvstate: 0输入的数据为 : rcvstate: 0 已知的BUG发送 A02B010 也会有数据产生，而且会乱码","tags":["💻Code","📃Study","📦STM32"],"categories":["💻Code"]},{"title":"戴森球计划[游戏安利]","path":"/posts/7c3617f6/","content":"游戏介绍 探索未知的星球，发现珍奇，让你的足迹遍布星辰大海。 《戴森球计划》是一款融合了太空、自动化工厂、冒险、探索等元素的科幻题材沙盒建造类游戏。在未来，人类踏入高级文明的行列之时，科技的强大带来了飞速的发展，虚拟现实迭代了空间与时间。人类创造了超级计算机——“主脑”，以期待利用其强大的计算能力来进一步扩大虚拟世界的运用。 作为玩家的你，加入了空间管理联盟COSMO开启的一项代号为“戴森球计划”的工程项目，建造戴森球，为“主脑”提供持续稳定的能量。在游戏中，玩家将从上帝视角进行工厂建造及资源管理。在这一过程中，你势必会遭遇诸多困难，毕竟宇宙之大，什么都可能发生。然而，你的创造力与想象力将会助你达成这一宏大的目标，整个银河势必将在你的规划下成为人类文明前进的基石。 你可以不断解锁科技，一步一步打造专属你的戴森球；也可以探索宇宙，发现宇宙珍奇，踏遍星辰大海；或是架设星际物流系统，串联出庞大的工业帝国；亦或是不断优化设计，让生产流水线的效率更高。 随机生成的星图，每一局都是独一无二的宇宙。更加微观的建造戴森球，从一个零件开始构架。千变万化的宇宙生态，中子星、白矮星、红巨星，甚至黑洞。不止于地表的自动化生产流水线，跨越星系运输物资。多种可自主定制的设定，打造属于你自己的戴森球计划。球形地表，完美表现在一颗星球之上完成建设的特色。 将资源通过传送带串联在各个建筑之间，形成高效的流水线生产，让科技自主的前进。同时在建造过程中建筑会自动吸附网格，铺设流水线时可以利用建筑网格吸附功能自动对齐建筑，大大提高建造的效率，形成大规模的自动化流水线。 跨越地表运输的限制，组建你的星际运输大队，将另一个星球的物资传递过来，集合全宇宙的力量来快速发展自己。 每一次游戏的开始都会随机生成全新的星图，拥有不同的星球种类，矿物分布。每一个星球的地形也会变化。在这个千变万化的宇宙中去完全属于你自己的“戴森球计划”。 同时游戏中直接展现了各式各样的星球和天象，中子星、白矮星、红巨星、气态星球、日冕、永昼永夜等，统统都可以在这里看到。 宣传视频 买家秀 一些有趣但很真实的评论 早上八点打开游戏，关闭游戏是已经是早上七点，这游戏能让时间倒流！！！ 配置要求不高，但是后期PPT是无法避免的 戴森球计划（❌） 时间消失模拟器（✔️） 千人大厂十连抽，五人作坊戴森球！ 70块钱他就能给你几十个恒星系玩哎，当你看到戴森球代替恒星升起，物流飞船遍布整个宇宙，自动化生产线源源不断生产出一些看上去非常厉害的东西的时候，那感觉，真的绝了 还没出的战斗序列《戴森球计划》TGS战斗系统宣传视频：黑雾崛起 玩家文档https://wiki.biligame.com/dsp/%E9%A6%96%E9%A1%B5 最后测试一下我的随机图片壁纸","tags":["🎮Game"],"categories":["🎮Game"]},{"title":"ROS 自定义订阅者","path":"/posts/7e7b94b3/","content":"背景介绍软件平台 The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it’s all open source. Robot操作系统(ROS)是一组软件库和工具，可帮助您构建机器人应用程序。从驱动程序到最先进的算法，再加上强大的开发工具，ROS为您的下一个机器人项目提供了所需的一切。而且这一切都是开源的。 硬件平台 地平线旭日®️X3派是一款面向生态开发者的嵌入式AI开发板，接口兼容树莓派，具有5Tops端侧推理与4核ARM A53处理能力。可同时多路Camera Sensor的输入并支持H.264&#x2F;H.265编解码。结合地平线的高性能AI工具链与机器人开发平台，助力开发者快速落地解决方案。 ROS 订阅机制ROS 2将复杂的系统分解为许多模块化节点。 主题是 ROS 图的重要组成部分，充当节点交换消息的总线。 一个节点可以将数据发布到任意数量的主题，同时订阅任意数量的主题。 主题是数据在节点之间移动的主要方式之一，因此也是在系统的不同部分之间移动的主要方式之一。 (不得不说官方文档还是写的很不错的) 自定义订阅者(这里参考了很多官方文档) 创建包打开一个新终端并获取 ROS 2 安装，以便命令正常工作。ros2 导航到上一教程中创建的目录。ros2_ws 回想一下，包应该在目录中创建，而不是在工作区的根目录中创建。 因此，导航到 并运行包创建命令：srcros2_ws/src ros2 pkg create --build-type ament_python py_pubsub 您的终端将返回一条消息，验证您的软件包及其所有必要文件和文件夹的创建。 编写订阅节点导航到 py_pubsub 回想一下，此目录是一个 Python 包，与它嵌套的 ROS 2 包同名。ros2_ws/src/py_pubsub/py_pubsub 1234567891011121314151617181920212223242526272829303132333435363738import rclpyfrom rclpy.node import Nodefrom std_msgs.msg import Stringclass MinimalSubscriber(Node): def __init__(self): super().__init__(&#x27;minimal_subscriber&#x27;) self.subscription = self.create_subscription( String, &#x27;topic&#x27;, self.listener_callback, 10) self.subscription # prevent unused variable warning def listener_callback(self, msg): self.get_logger().info(&#x27;I heard: &quot;%s&quot;&#x27; % msg.data)def main(args=None): rclpy.init(args=args) minimal_subscriber = MinimalSubscriber() rclpy.spin(minimal_subscriber) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber.destroy_node() rclpy.shutdown()if __name__ == &#x27;__main__&#x27;: main() 添加依赖将一个级别导航回目录，其中已为您创建了目录和文件。ros2_ws/src/py_pubsub setup.py setup.cfg package.xml 使用文本编辑器打开。package.xml 如上一教程所述，请确保填写&lt;description&gt; &lt;maintainer&gt; &lt;license&gt;标记： 123&lt;description&gt;Examples of minimal publisher/subscriber using rclpy&lt;description&gt;&lt;maintainer email=&quot;you@email.com&quot;&gt;Your Name&lt;/maintainer&gt;&lt;license&gt;Apache License 2.0&lt;/license&gt; 在上述行之后，添加与节点的导入语句对应的以下依赖项： 12&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt; 这声明了包的需求以及何时执行其代码 添加入口点打开setup.py文件。 同样，将 、 和 字段与您的 ：maintainer maintainer_email description licensepackage.xml 12345maintainer=&#x27;YourName&#x27;,maintainer_email=&#x27;you@email.com&#x27;,description=&#x27;Examples of minimal publisher/subscriber using rclpy&#x27;,license=&#x27;Apache License 2.0&#x27;, 在字段的括号内添加以下行： 12345entry_points=&#123; &#x27;console_scripts&#x27;: [ &#x27;talker = py_pubsub.publisher_member_function:main&#x27;, ],&#125;, 不要忘记保存。 检查设置.cfg文件的内容应自动正确填充，如下所示：setup.cfg 1234[develop]script-dir=$base/lib/py_pubsub[install]install-scripts=$base/lib/py_pubsub 这只是告诉设置工具将您的可执行文件放入 ，因为会在那里寻找它们。 您现在可以构建软件包，获取本地安装文件并运行它，但让我们先创建订阅者节点，以便您可以看到完整的系统在工作。 消息格式参考旭日x3的ai_msgs ai_msgs自定义的ai msg，包括人&#x2F;物&#x2F;车等检测框roi，跟踪track id，抓拍，特征，手势识别等结果。用于算法模型推理后，发布推理结果。 message详细说明如下： PerceptionTargets.msg感知结果的消息定义，一般每帧图像对应一个感知结果消息。消息包含： 1、std_msgs&#x2F;Header header 消息头，包含stamp和frame_id，和用于模型推理的图片header一致，用于表示此消息所对应的图片。 2、int16 fps 感知结果的输出帧率，即算法模型推理处理帧率，小于0无效。 当fps小于sensor的图像输出帧率时，说明算法模型推理耗时比较长，需要对推理流程进行优化。 3、Perf[] perfs 性能统计信息，比如记录每个模型推理的耗时。 当有多个模型时，可以通过记录每个模型的性能信息发现模型推理流程的性能瓶颈。同时当发生推理异常导致无ai消息输出时，也能够根据性能统计信息中的模型名，判断是哪个模型没有输出，实现快速缩小排查范围。 4、Target[] targets 感知目标集合。 5、Target[] disappeared_targets 消失目标集合。 CaptureTargets.msg抓拍结果的消息定义。消息包含： 1、std_msgs&#x2F;Header header 消息头，包含stamp和frame_id，和用于模型推理的图片header一致，用于表示此消息所对应的图片。 2、Perf.msg 性能统计信息，比如记录每个模型推理的耗时 4、Target[] targets 抓拍目标集合。 Perf.msg性能统计信息。 1、string type 类型，用于表示处理模块。例如type为模型名时，表示对此模型推理的性能统计。 2、builtin_interfaces&#x2F;Time stamp_start 开始处理的时间戳。 3、builtin_interfaces&#x2F;Time stamp_end 处理完成的时间戳。 Target.msg目标消息。 1、string type 目标类型名称，如：人、车、动物、物体，具体值可以定义为为person&#x2F;car&#x2F;object&#x2F;animal 2、uint64 track_id 目标跟踪ID号。 3、Roi[] rois 目标的检测框。一个目标可能包含多个检测框，如同时具有人体、人头和人脸检测框。 4、Attribute[] attributes 属性。一个目标可能包含多个属性信息，如同时具有年龄、性别和手势结果。 5、Point[] points 关键点。一个目标可能包含多个关键点信息，如同时具有人脸关键点、人体骨骼点、人手关键点 6、Capture[] captures 跟踪目标抓拍图信息，包含抓拍图、特征、特征的底库检索结果信息。 Roi.msgroi感知消息，如：人体检测框、人头检测框、人脸检测框、人手检测框。 1、string type roi类型，如body&#x2F;head&#x2F;face&#x2F;hand。 2、sensor_msgs&#x2F;RegionOfInterest rect 检测框。 3、float32 score 检测结果的置信度。 Attribute.msg属性感知消息，如：年龄、性别、手势、眼镜、口罩、活体信息、车辆类型、车辆颜色、车辆速度、车辆所在车道等信息。 1、string type 属性类型，如年龄：age，性别：gender， 手势：gesture。 2、float32 value 属性数值。 如age数值定义举例： ​\tval为实际年龄数值 gender数值定义举例： ​\t“1”: “男”, “-1”: “女” gesture数值定义举例： ​\t0: Background, &#x2F;&#x2F; 无手势 ​\t1: FingerHeart, &#x2F;&#x2F; 比心 ​\t2: ThumbUp, &#x2F;&#x2F; 大拇指向上 ​\t3: Victory, &#x2F;&#x2F; V手势 ​\t4: Mute, &#x2F;&#x2F; 嘘 ​\t10: Palm, &#x2F;&#x2F; 手掌 ​\t11: Okay, &#x2F;&#x2F; OK手势 ​\t12: ThumbRight, &#x2F;&#x2F; 大拇指向右 ​\t13: ThumbLeft, &#x2F;&#x2F; 大拇指向左 ​\t14: Awesome, &#x2F;&#x2F; 666手势 3、float32 confidence 属性结果的置信度。 Point.msg关键点感知结果，如：人脸关键点、人体骨骼点、人手关键点。 1、string type 类型，如body_kps&#x2F;face_kps&#x2F;hand_kps。 2、geometry_msgs&#x2F;Point32[] point 关键点数值。 3、float32[] confidence 每个关键点的置信度，维度和关键点数值相同。 Capture.msg抓拍信息。 1、std_msgs&#x2F;Header header 抓拍图对应原视频帧的timestamp和frame_id。 2、sensor_msgs&#x2F;Image img 抓拍图。 3、float32[] features 抓拍图对应的特征数据，数据长度为0时表示无特征。 4、DBResult db_result 特征的底库检索结果。只有当有特征时底库检索结果有效。 DBResult.msg底库检索结果。 1、string db_type 底库名称。 2、string match_id 匹配目标ID。 3、float32 distance 特征比对距离。 4、float32 similarity 特征比对相似度。 构建和运行编译 colcon build --packages-select py_pubsub 打开一个新终端，导航到 ，并获取安装文件： . install/setup.bash 现在运行说话者节点： ros2 run py_pubsub listener 我的代码修改其实Python脚本代码可以直接运行，无需编译 12345678910111213141516171819202122232425262728293031323334353637383940414243import rclpyfrom rclpy.node import Nodefrom ai_msgs.msg import PerceptionTargetsclass MinimalSubscriber(Node): def __init__(self): super().__init__(&#x27;minimal_subscriber&#x27;) self.subscription = self.create_subscription( PerceptionTargets, &#x27;hobot_mono2d_body_detection&#x27;, self.listener_callback, 10) self.subscription # prevent unused variable warning def listener_callback(self, msg): if len(msg.targets) &gt; 1: self.get_logger().info(&#x27;I heard:&#x27; + str(msg.targets[0].type) + str(msg.fps))# &quot;%s&quot;&#x27; % msg.data else: self.get_logger().info(&#x27;dont&#x27;)# https://c-gitlab.horizon.ai/HHP/box/hobot_msgs/-/tree/develop/ai_msgsdef main(args=None): rclpy.init(args=args) minimal_subscriber = MinimalSubscriber() rclpy.spin(minimal_subscriber) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber.destroy_node() rclpy.shutdown()if __name__ == &#x27;__main__&#x27;: main() 结果展示1234567891011[INFO] [1672741631.264257258] [minimal_subscriber]: I heard:person30[INFO] [1672741631.295972687] [minimal_subscriber]: I heard:person30[INFO] [1672741631.327739324] [minimal_subscriber]: I heard:person30[INFO] [1672741631.363461421] [minimal_subscriber]: I heard:person30[INFO] [1672741631.392870207] [minimal_subscriber]: I heard:person30[INFO] [1672741631.429643377] [minimal_subscriber]: I heard:person30[INFO] [1672741631.465771636] [minimal_subscriber]: I heard:person30[INFO] [1672741631.496358035] [minimal_subscriber]: I heard:person30","tags":["ROS"],"categories":["💻Code"]},{"title":"干饭日记","path":"/posts/39fh31o/","content":"","tags":["🍚干饭日记"],"categories":["🔖Life"]},{"title":"address_calculate","path":"/posts/2scrgfh/","content":"记录一次芯片的地址计算 地址介绍前几天刚发了一篇ltc2497的六层板绘制过程,这两天准备写它的驱动,奈何芯片比较小众只能自己写(练习一下) 先看他的地址列表 12345678910111213141516171819202122232425262728// #define LTC2497_I2C_ADDRESS 0x14 // Low Low Low// #define LTC2497_I2C_ADDRESS 0x16 // Low Low High// #define LTC2497_I2C_ADDRESS 0x15 // Low Low Float// #define LTC2497_I2C_ADDRESS 0x26 // Low High Low// #define LTC2497_I2C_ADDRESS 0x34 // Low High High// #define LTC2497_I2C_ADDRESS 0x27 // Low High Float// #define LTC2497_I2C_ADDRESS 0x17 // Low Float Low// #define LTC2497_I2C_ADDRESS 0x25 // Low Float High// #define LTC2497_I2C_ADDRESS 0x24 // Low Float Float// #define LTC2497_I2C_ADDRESS 0x56 // High Low Low// #define LTC2497_I2C_ADDRESS 0x64 // High Low High// #define LTC2497_I2C_ADDRESS 0x57 // High Low Float// #define LTC2497_I2C_ADDRESS 0x74 // High High Low// #define LTC2497_I2C_ADDRESS 0x76 // High High High// #define LTC2497_I2C_ADDRESS 0x75 // High High Float// #define LTC2497_I2C_ADDRESS 0x65 // High Float Low// #define LTC2497_I2C_ADDRESS 0x67 // High Float High// #define LTC2497_I2C_ADDRESS 0x66 // High Float Float// #define LTC2497_I2C_ADDRESS 0x35 // Float Low Low// #define LTC2497_I2C_ADDRESS 0x37 // Float Low High// #define LTC2497_I2C_ADDRESS 0x36 // Float Low Float// #define LTC2497_I2C_ADDRESS 0x47 // Float High Low// #define LTC2497_I2C_ADDRESS 0x55 // Float High High// #define LTC2497_I2C_ADDRESS 0x54 // Float High Float// #define LTC2497_I2C_ADDRESS 0x44 // Float Float Low// #define LTC2497_I2C_ADDRESS 0x46 // Float Float High// #define LTC2497_I2C_ADDRESS 0x45 // Float Float Float 看起来很复杂,貌似没有规律 地址计算刚开始我也没看出来,然后我把它放到万能的excel中排了一下序列,结果如下 (第一排是16进制,缺了 0x 不要介意) 规律如下: 第一排的第一个数字,也就是地址前四位依次为1-7 第二排都为4-7 low &lt; float &lt; high 是不是发现了规律 本质上就是三进制转为8进制+4进制再加一个基地址0x14 程序编写验证拿clion新建了个工程试一下 123456789101112131415161718192021222324252627282930313233void set_ltc2497_adress(uint8_t addr2,uint8_t addr1, uint8_t addr0)&#123; //auto calculate the address uint8_t num = 0x00; num = addr2*9 + addr1*3 + addr0*1; num = ((num/4) &lt;&lt; 4)|(num%4); num = num + 0x14; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; &quot;0x&quot; &lt;&lt; std::hex &lt;&lt; int(num) &lt;&lt; std::endl; &#125;int main()&#123; //输出全部地址 for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; for (int k = 0; k &lt; 3; k++) &#123; set_ltc2497_adress(i, j, k); &#125; &#125; &#125; system(&quot;pause&quot;); return 0;\treturn 0;&#125; 输出结果如下 123456789101112131415161718192021222324252627address: 0x14address: 0x15address: 0x16address: 0x17address: 0x24address: 0x25address: 0x26address: 0x27address: 0x34address: 0x35address: 0x36address: 0x37address: 0x44address: 0x45address: 0x46address: 0x47address: 0x54address: 0x55address: 0x56address: 0x57address: 0x64address: 0x65address: 0x66address: 0x67address: 0x74address: 0x75address: 0x76 至此,结束","tags":["💻Code"],"categories":["💻Code"]},{"title":"pcb_6","path":"/posts/2nqj13j/","content":"记录第一次画6层板的过程为防止意外,添加了水印 设计目标最近做实验气阀控制板上面的接口总是不够用，最近正好有时间，就想着做一个，这个板子的目标是： 可扩展 闭环 尽可能多的接口 尽可能小 （不喜欢太大的板子） i2c接口 （单纯的不喜欢spi） 6层板 （前两天看见6层板免费了，还有盘中孔工艺） 芯片选型气阀主要是pwm信号来控制的，在半岛小芯上面根据自己的需求筛选了一下芯片，最终选定了一款16路pwm芯片和adc芯片，以及一个附加的参考电压芯片。 pca9685 一款led驱动芯片 有62个可选地址 ltc2497 adc芯片 有28个可选地址 lt1236-5 5v参考电压芯片 所以最终理论最大气阀接口数量为 16*28&#x3D;448 足够了 电路设计pwm信号通过运放进行放大驱动气阀，adc读取气阀反馈值，通过主控芯片进行闭环运算。 整体参考官方手册进行设计，有两个要注意的是： 输入电压12V 需要降压电路 5V 3.3V 都需要，比较麻烦 结果如下： pcb 绘制这里闹了笑话 一开始搞不清 过孔 埋孔 盲埋孔（读者请自行百度）画了一堆盲埋孔（制作工艺复杂）嘉立创无法生产，后来又在孔的直径上面出了问题 免费直径 0.45 最终还是画好了 结果如下 不同颜色代表不同的层 关于6层板的层定义这里不再写。 芯片采购板子大部分都直接smt贴片了，只有三个芯片自行邮寄 这里又被淘宝坑了一波，他没货不跟我说，也怪我，耽误了5天 芯片不到pcb都不做！！！！嘉立创规则。。。。。。我的错 到货讲真 到货后大吃一惊 如图 芯片漏贴一个(芯片封装我买错了,打了电话芯片才寄过来自己手动改造了一下) 2.54排针弄成了1.27排针………. TODO 程序验证 结果PWM 没有进行RC滤波处理ADC 转换速率慢7.5SPS 项目上肯定是不能用了 续集无了","tags":["PCB"],"categories":["💻Code"]},{"title":"invoice_ocr","path":"/posts/3ie04lo/","content":"因最近实验室财务政策(报销的相关事情)有一些改变，需要自己去写入库单，然后去财务处报销，但是我不想手写Word，然后就有了这个工具。 之前财务也有用过一个OCR的工具，但是我觉得不太好用，所以就干脆自己写了一个。 在提高效率的同时，也可以学习一下OCR的相关知识。 用到的库语言当然不用说了，Python。 ocr(文字识别)：百度的OCR api 增值税发票识别（封面也是这里找的） json：用来解析百度OCR的返回值 python-docx：用来生成Word文档 pypdf2：用来生成PDF文档 datetime：用来生成时间戳 思路 从淘宝等网站获取订单发票 用百度OCR识别发票信息 生成Word文档 将发票pdf重命名并归档 效果部分效果图如下： 代码很长且没有注释，但是我觉得很好理解，就不贴了。 其实自己也快忘了hhhh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457from datetime import datetimeimport shutilfrom time import sleepfrom aip import AipOcrimport PyPDF2 as pdfimport jsonimport docximport os&quot;&quot;&quot; 你的 APPID AK SK &quot;&quot;&quot;APP_ID = &#x27;xxxx&#x27;API_KEY = &#x27;xxx&#x27;SECRET_KEY = &#x27;xxxx&#x27;client = AipOcr(APP_ID, API_KEY, SECRET_KEY)&quot;&quot;&quot; 读取pdf &quot;&quot;&quot;def get_file_content(filePath): with open(filePath, &#x27;rb&#x27;) as fp: return fp.read()# 遍历文件夹下所有pdf文件def get_pdffiles(dir_path): import os files = os.listdir(dir_path) pdf_files = [] for file in files: if file.endswith(&#x27;.pdf&#x27;): pdf_files.append(dir_path+&#x27;/&#x27;+file) return pdf_files# 商品类class Commodity: def __init__(self): self.name = &#x27;&#x27; self.type = &#x27;&#x27; self.unit = &#x27;&#x27; self.price = 0 self.tax_rate = 0 self.tax = 0 self.total_price = 0 self.num = 0 # 入库单类# 入库单# Warehouse receiptclass WarehouseReceipt(): def __init__(self, pdf_file_path=&#x27;&#x27;): self.order_num = &#x27;&#x27; self.order_date = &#x27;&#x27; self.supplier = &#x27;&#x27; self.commodity_list = [] self.total_price = 0 self.json = &#x27;&#x27; self.pdf_file_path = pdf_file_path self.company = &#x27;&#x27; self.c_price = &#x27;&#x27; def __str__(self): return &#x27;订单号：&#x27;+self.order_num+&#x27;，订单日期：&#x27;+self.order_date+&#x27;，供应商：&#x27;+self.supplier+&#x27;，总价：&#x27;+self.total_price def ocr(self): # pdf_file_path = &#x27;invoice/1.pdf&#x27; if self.get_pdf_num() &gt; 1: #print(&#x27;pdf文件页数大于1,暂不支持&#x27;) return else: #print(&#x27;pdf文件页数为1&#x27;) #print(&#x27;开始识别&#x27;) #print(self.pdf_file_path) pdf_file = self.get_file_content() self.json = client.vatInvoicePdf(pdf_file) # with open(&#x27;&#123;&#125;.json&#x27;.format(self.pdf_file_path), &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(self.json, f, ensure_ascii=False, indent=4) #print(self.json) def ocr_pic(self): # pdf 转图片 def pdf_to_pic(self): from pdf2image import convert_from_path pages = convert_from_path(self.pdf_file_path, 200) for page in pages: page.save(self.pdf_file_path.replace(&#x27;.pdf&#x27;,&#x27;.jpg&#x27;), &#x27;JPEG&#x27;) pdf_to_pic(self) # 识别图片 image = self.get_pic_content() self.json = client.receipt(image) # 保存json数据 with open(&#x27;invoice/&#123;&#125;.json&#x27;.format(self.pdf_file_path), &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(self.json, f, ensure_ascii=False, indent=4) #print(self.json) def handle_json(self): json_data = self.json # 商品对象列表 self.commodity_list = [] words_result = json_data[&#x27;words_result&#x27;] for i in range(0, len(words_result[&#x27;CommodityTaxRate&#x27;])): # 商品名称 self.commodity_list.append(Commodity()) if i == len(words_result[&#x27;CommodityTaxRate&#x27;])-1: for j in range(int(words_result[&#x27;CommodityTaxRate&#x27;][i][&#x27;row&#x27;])-1, len(words_result[&#x27;CommodityName&#x27;])): #print(i, j) self.commodity_list[i].name += words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;] # self.commodity_list[i]+=(words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;]) else: for j in range(int(words_result[&#x27;CommodityTaxRate&#x27;][i][&#x27;row&#x27;])-1, int(words_result[&#x27;CommodityTaxRate&#x27;][i+1][&#x27;row&#x27;])-1): #print(i, j) self.commodity_list[i].name += words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;] # self.commodity_list[i]+=(words_result[&#x27;CommodityName&#x27;][j][&#x27;word&#x27;]) # 商品单价(含税) # 判断是否含税 if &#x27;%&#x27; in words_result[&#x27;CommodityTaxRate&#x27;][i][&#x27;word&#x27;]: #print(&#x27;含税&#x27;,i) #print(&#x27;ll&#x27;,self.commodity_list) #print(&#x27;ll&#x27;,self.commodity_list[i]) self.commodity_list[i].price = float( words_result[&#x27;CommodityPrice&#x27;][i][&#x27;word&#x27;]) + float(words_result[&#x27;CommodityTax&#x27;][i][&#x27;word&#x27;]) / int(words_result[&#x27;CommodityNum&#x27;][i][&#x27;word&#x27;]) #print(&#x27;%&#x27;) else: self.commodity_list[i].price = float( words_result[&#x27;CommodityPrice&#x27;][i][&#x27;word&#x27;]) # 商品类型(只能单页) if words_result[&#x27;CommodityType&#x27;]: self.commodity_list[i].type = words_result[&#x27;CommodityType&#x27;][i][&#x27;word&#x27;] #self.commodity_list[i].price = words_result[&#x27;CommodityPrice&#x27;][i][&#x27;word&#x27;] # 单个商品总价 self.commodity_list[i].total_price = self.commodity_list[i].price * \\ int(words_result[&#x27;CommodityNum&#x27;][i][&#x27;word&#x27;]) # 处理单价和总价的小数点 self.commodity_list[i].price = round( self.commodity_list[i].price, 2) self.commodity_list[i].total_price = round( self.commodity_list[i].total_price, 2) self.commodity_list[i].num = int( words_result[&#x27;CommodityNum&#x27;][i][&#x27;word&#x27;]) # 商品单位 self.commodity_list[i].unit = words_result[&#x27;CommodityUnit&#x27;][i][&#x27;word&#x27;] self.total_price = float(words_result[&#x27;AmountInFiguers&#x27;]) self.order_date = words_result[&#x27;InvoiceDate&#x27;] self.company = words_result[&#x27;SellerName&#x27;] self.c_price = words_result[&#x27;AmountInWords&#x27;] # 商品名称 #print(self.commodity_list) for i in self.commodity_list: #print(i.name) #print(i.price) #print(i.total_price) #print(i.num) #print(i.type) #print(i.unit) pass # 生成入库单word文件 def generate_word(self): from docx.shared import Pt from docx.oxml.ns import qn from docx.shared import Inches from docx.enum.text import WD_ALIGN_PARAGRAPH import datetime from docx.enum.table import WD_TABLE_ALIGNMENT from docx.enum.table import WD_ALIGN_VERTICAL from docx.enum.text import WD_PARAGRAPH_ALIGNMENT # 生成word文件 doc = docx.Document() # 设置所有字体为宋体 doc.styles[&#x27;Normal&#x27;].font.name = u&#x27;宋体&#x27; doc.styles[&#x27;Normal&#x27;]._element.rPr.rFonts.set(qn(&#x27;w:eastAsia&#x27;), u&#x27;宋体&#x27;) # 设置所有段落的行距为1.5倍 doc.styles[&#x27;Normal&#x27;].paragraph_format.line_spacing = 1.5 # 设置 title = doc.add_paragraph(&quot;浙江工业大学耗材入库单&quot;, style=&#x27;Normal&#x27;) # 设置标题字体大小 title.runs[0].font.size = Pt(18) # 加粗 title.runs[0].font.bold = True # 设置标题居中 title.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 添加当天时间 today = datetime.datetime.now().strftime(&#x27;%Y年%m月%d日&#x27;) today = doc.add_paragraph(today, style=&#x27;Normal&#x27;) today.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 添加部门公章 doc.add_paragraph(&quot;部门（公章）： 单位：\t元&quot;, style=&#x27;Normal&#x27;) # 设置表格 table = doc.add_table(rows=1, cols=7, style=&#x27;Table Grid&#x27;) # 左下 table.alignment = WD_ALIGN_VERTICAL.CENTER # table.alignment = # table.alignment = WD_TABLE_ALIGNMENT.LEFT # table.alignment = WD_TABLE_ALIGNMENT.BOTTOM # 根据内容自动调整列宽 # table.autofit = True # table.autofitcontent = True # 设置每一列的宽度 table.cell(0, 1).width = Inches(4) table.cell(0, 2).width = Inches(3) # 设置 首行 table.cell(0, 0).text = &#x27;供货单位&#x27; table.cell(0, 1).text = self.company table.cell(0, 2).text = &#x27;入库日期&#x27; table.cell(0, 3).text = self.order_date # 合并单元格 table.cell(0, 3).merge(table.cell(0, 4)) table.cell(0, 5).text = &#x27;入库单号&#x27; table.cell(0, 6).text = self.order_num # 表格 根据内容自动调整 table.allow_autofit = True hdr_cells = table.add_row().cells hdr_cells[0].text = &#x27;序号&#x27; hdr_cells[1].text = &#x27;耗材名称&#x27; hdr_cells[2].text = &#x27;规格型号&#x27; hdr_cells[3].text = &#x27;单位&#x27; hdr_cells[4].text = &#x27;数量&#x27; hdr_cells[5].text = &#x27;单价&#x27; hdr_cells[6].text = &#x27;金额&#x27; for index,i in enumerate(self.commodity_list): row_cells = table.add_row().cells row_cells[0].text = str(index+1) row_cells[1].text = i.name row_cells[2].text = i.type row_cells[3].text = i.unit row_cells[4].text = str(i.num) row_cells[5].text = str(i.price) row_cells[6].text = str(i.total_price) # 合计行 row_cells = table.add_row().cells row_cells[0].text = &#x27;合计&#x27; # 合并单元格 row_cells[1].text = &#x27;(大写)&#x27; row_cells[2].merge(row_cells[3]).merge(row_cells[4]).text = self.c_price row_cells[5].text = &#x27;(小写)&#x27; row_cells[6].text = str(self.total_price) # 添加制表等 doc.add_paragraph(&quot;制表（保管）： 采购： 入库验收：&quot;, style=&#x27;Normal&#x27;) last = doc.add_paragraph( &quot;第一联：存根联\t第二联：财务\t第三联：供货单位（采购）\t第四联：验收人&quot;, style=&#x27;Normal&#x27;) last.runs[0].font.size = Pt(10) last.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 保存文件 doc.save(&#x27;invoice/word/&#x27;+str(self.total_price)+self.company+self.order_date+&#x27;.docx&#x27;) def get_file_content(self): with open(self.pdf_file_path, &#x27;rb&#x27;) as fp: return fp.read() def get_pic_content(self): with open(self.pdf_file_path.replace(&#x27;.pdf&#x27;,&#x27;.jpg&#x27;), &#x27;rb&#x27;) as fp: return fp.read() # 获取pdf页码 def get_pdf_num(self): pdfFileObj = open(self.pdf_file_path, &#x27;rb&#x27;) pdfReader = pdf.PdfFileReader(pdfFileObj) num = pdfReader.numPages return num def cp(self): # 复制并重命名pdf文件 shutil.copy(self.pdf_file_path, &#x27;invoice/pdf/&#x27;+str(self.total_price)+self.company+self.order_date+&#x27;.pdf&#x27;) # 删除原pdf文件 os.remove(self.pdf_file_path) def deal(self): self.ocr() # 捕捉异常 try: self.handle_json() except Exception as e: print(e, &#x27;json文件处理失败&#x27;) # 创建错误日志 with open(&#x27;invoice/log/error-&#123;&#125;.log&#x27;.format(datetime.now().strftime(&#x27;%Y年%m月%d日%H-%M&#x27;)), &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(self.pdf_file_path+&#x27; &#x27;+str(e) + &#x27;\\r &#x27;+str(self.json)+&#x27;\\r &#x27;) #print(e) #print(&#x27;处理json文件出错&#x27;) # 抛出异常 else: #print(&#x27;处理json文件成功&#x27;) print(&#x27;处理json文件成功&#x27;,self.pdf_file_path) # 创建成功日志 with open(&#x27;invoice/log/success-&#123;&#125;.log&#x27;.format(datetime.now().strftime(&#x27;%Y年%m月%d日%H-%M&#x27;)), &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(self.pdf_file_path+&#x27;\\r &#x27;) self.generate_word() self.cp() # options = &#123;&#125; # options[&#x27;pdf_file_num&#x27;] = get_pdf_num(pdf_file_path) # res_pdf = client.vatInvoicePdf(pdf_file, options) # # 保存json数据 # with open(&#x27;invoice/1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(res_pdf, f, ensure_ascii=False, indent=4) def dealdebug(self): self.ocr() # 捕捉异常 self.handle_json() self.generate_word() # options = &#123;&#125; # options[&#x27;pdf_file_num&#x27;] = get_pdf_num(pdf_file_path) # res_pdf = client.vatInvoicePdf(pdf_file, options) # # 保存json数据 # with open(&#x27;invoice/1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(res_pdf, f, ensure_ascii=False, indent=4)# read json# def read_json(file_path):# with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:# json_data = json.load(f)# handle_json(json_data)if __name__ == &#x27;__main__&#x27;: for i in get_pdffiles(&#x27;invoice/new&#x27;): WarehouseReceipt(i).deal() #WarehouseReceipt(&#x27;invoice/new/202205171971483062.pdf&#x27;).dealdebug() # WarehouseReceipt(&#x27;invoice ew\\202209102153729425.pdf&#x27;).deal() # wh1 = WarehouseReceipt(&#x27;invoice/invoice.pdf&#x27;) # with open(&#x27;invoice/invoice.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: # wh1.json = json.load(f) # wh1.ocr() # wh1.handle_json() # wh1.deal() # wh1.handle_json() # wh1 = WarehouseReceipt() # with open(&#x27;invoice/invoice.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: # wh1.json = json.load(f) # wh1.handle_json() # wh1.generate_word() # read_json(&#x27;invoice/invoice.json&#x27;) # read_json(&#x27;invoice/1.json&#x27;) # pdf_file_path = &#x27;invoice/1.pdf&#x27; # pdf_file = get_file_content(pdf_file_path) # options = &#123;&#125; # options[&#x27;pdf_file_num&#x27;] = get_pdf_num(pdf_file_path) # res_pdf = client.vatInvoicePdf(pdf_file, options) # # 保存json数据 # with open(&#x27;invoice/1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: # json.dump(res_pdf, f, ensure_ascii=False, indent=4)# 从文件读取json数据(测试用)# 调用增值税发票识别# res_image = client.vatInvoice(image)# res_url = client.vatInvoiceUrl(url)# res_pdf = client.vatInvoicePdf(pdf_file)# #print(res_image)# #print(res_url)# #print(res_pdf)# 如果有可选参数# options = &#123;&#125;# options[&#x27;pdf_file_num&#x27;] = get_invoice_num(file_path)# res_image = client.vatInvoice(image, options)# res_url = client.vatInvoiceUrl(url, options)# res_pdf = client.vatInvoicePdf(pdf_file, options)# #print(res_image)# #print(res_url)# #print(res_pdf)","tags":["💻Code","Python"],"categories":["💻Code"]},{"title":"qt_study","path":"/posts/307ko19/","content":"Now现在在悄咪咪的学qml(为什么悄咪咪?自己悟) 等项目有需要再去光明正大的学Widget 来看看最近的小玩意吧 mac 授权 小工具(功能完全实现) 串口助手(还在写) 因虽然之前学习过一些MFC的相关知识,但是缺少对整体的学习,最近需要用到QT,顺便也系统的学习一下QT的相关知识。 但是传统QT写的界面非常简陋,一点也不好看,最近正在找办法写个好看的.哪怕是Python自带的tkinter都有很好看的主题可以选择. 还在找办法写个好看的,但是目前还是没有找到好的方法,先系统的学着吧. 好看的同时我还想保证兼容性和速度,难哇! Qt Widgets 与 Qt Quicker这个官方视频讲的很不错,建议观看 Qt 版本区别 Qt4.8.7是Qt4的终结版本，是Qt4系列版本中最稳定最经典的（很多嵌入式板子还是用Qt4.8），其实该版本是和Qt5.5差不多时间发布的。（大版本之间存在同时开发维护） Qt5.6.3最最后支持xp系统的长期支持版本，Qt5.7.0是最后支持xp系统的非长期支持版本。 Qt5.12.3是最后提供mysql数据库插件的版本，往后的版本需要自行编译对应的mysql数据库插件，官方安装包不再提供。 Qt5.12.5是最后样式表性能最高的版本，经过酷码大佬查阅代码发现此后版本的样式表源码中为了修复一个bug做了循环嵌套设置，导致性能急剧下降，界面越多性能暴降10倍以上。 Qt5.14.2是最后提供二进制安装包的版本，后面的版本都需要在线安装。 Qt5.15系列是最后支持win7的版本，后面的Qt6系列版本需要更改源码编译才能支持，这对于小白来说难于上青天。_Qt_5.15 Qt 5.15 LTS 维护至 2023年5月29日 算算我毕业都2024了 所以 干脆QT6吧! 版本选择一图看懂Qt版本选择","tags":["💻Code","⌨️Qt"],"categories":["💻Code"]},{"title":"Python_study","path":"/posts/3ahvaci/","content":"虽然之前学过不少 python 的知识，但是还是没有系统的学习过一些基础知识，补一下。参考书 Python 基础教程(第 3 版)_百度百科 丑话说在前面只记一下易错点和之前不会的点吧，个人向。 大量 复制粘贴 不喜勿看 因篇幅较长,请移步至Document","tags":["💻Code"],"categories":["💻Code"]},{"title":"cloudreve配置修复","path":"/posts/49u3l9/","content":"初最近通过 Cloudreve 搭建了实验室网盘系统，但是在使用时遇到一个 bug：无法上传大于 1MB 的文件，下面来讲讲修复之路。 启拿到问题当然要找找问题所在，方可对症下药， 如图所示，报错奇奇怪怪，也看不懂，拿去百度搜索也搜不到，起初是以为nginx的反向代理问题，所以去尝试修改nginx的配置文件。 修改多次无果，我开始换nginx版本，从二进制版本换为编译版本，无果 网上找了一些教程，发现可能是nginx重启不彻底，手动搜索进程进行重启，无果 潮问题没解决，我临时换了其他网盘去用，但是解决不了问题，心里始终不舒服，所以继续花时间找原因。 宝塔？？？ 前去找这个报错的来源 找了半天找到了这个 看了下里面的日志，果然，就是他 终你问我什么结果，当然是删掉这个插件了 修改了一下配置，毕竟网站安全也很重要","tags":["💻Code","🔧Cloudreve"],"categories":["💻Code"]},{"title":"C++学习","path":"/posts/21r8od0/","content":"因目前 c++的学习主要是针对三个方向 基本语法 数据结构 QT(能用就行的地步) 参考书: C++ Primer Plus（第 6 版） 数据结构、算法与应用 C++语言描述原书第 2 版 Qt 5.9 C++开发指南 (王维波 栗宝鹃 侯春望) Qt5 开发及实例（第 3 版） (陆文周) 因篇幅较长,请移步至Document","tags":["💻Code","⏳C++","📃Study"],"categories":["💻Code"]},{"title":"学习路线","path":"/posts/1s2b6vp/","content":"前两天收到了导师发的学习清单，准备正式开始梳理自己未来的学习路线，在这之前一直都很迷茫，下面的路线有很多交叉的地方，需要融会贯通。 现在初步只是思维导图，后续我将根据自己的情况进行补充计划。 目前主要学习科目： Freertos 嵌入式 当前的重点仓库地址wxydejoy&#x2F;cpp_study · GitHub embeded systemstm32esp32Linux这个只能边做边学 scientificmatlab配合机器人导论 robotics机器人导论视频课程 Python实战 练习 脚本 机器学习 otherslatex正则 2022 级新生学习清单零、必会工具软件WORD、PPT、excel、solidworks、CAXA&#x2F;CAD、matlab、LABVIEW一、基础理论与方法0、高等数学、线性代数、复变函数、概率论、矩阵理论1、数值计算2、数学建模3、实验设计与分析二、专业基础0、机械制图、机械原理、机械设计、理论力学中的力学与运动学动力学原理与方法、单片机原理、经典控制论1、电机拖动、传感器原理、人工神经网络、计算机接口与控制、气压&#x2F;液压传动与控制、信号处理三、机器人研究方向1、机器人学导论2、ROS 系统3、美国机器人路线图 2020 机器人2020 版机器人路线图 架构与设计实现 移动性 抓取与操作 感知 规划与控制 学习与适应 多机器人系统 人机交互 基础知识 基本的英文 学会使用 科学上网 线性代数 https://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html 微积分 理论力学 Matlab or Python 控制理论 数字电路与模拟电路 一点点单片机 Linux 和 C 语言 基本的 3D 设计 入门主要工具书 机器人学导论（原书第 4 版） 空间变换 运动学 雅可比矩阵 动力学 控制 实践 动手 Penn’s Robotics Specialization ROS 进阶 数学 Modern Robotics 控制 运动规划 机器学习 强化学习 最新论文 科研数值计算数学建模嵌入式（本科初步了解，研究生初期深入学习）开发平台 CPU: Intel x86 x64, ARM64 MCU 编程：C51, STM32 FPGA 嵌入式开发软件 Keil uVision, STM32Cube, JTAG debugger, System Viewer 嵌入式 Linux Bootloader, Driver, … 实时操作系统 uCOS, FreeRTOS, ROS（严格来说是 ROS2） 外设 Timer, ADC &#x2F; DAC, ROM &#x2F; RAM, PWM, I&#x2F;O &#x2F; GPIO, … 执行器 电机(步进, 无刷, 舵机, …), 电调, FOC 传感器 陀螺仪, 加速度计, 超声波, 红外, … 电路电子元件 电容, 电阻, 开关, 二极管, 晶振… PCB 设计, 元件焊接 通信协议 Bluetooth, Zigbee, Wifi, UART, TCP, UDP, I2C, … 仪器 万用表, 示波器, 信号发生器, 逻辑分析仪, … 其他编程 Python 作为兴趣 or 工具 作为机器学习等相关知识的基础 AHK 键盘脚本，提高效率 软件 收集各种小工具 52pojjie 机械（本科已完成）本科完成所有知识的学习，研究生期间根据未来方向加深图学 基本二维图纸的绘制 力学 理论力学 材料力学 热力学 有限元方法 机械 机械原理 机械设计 基础电学 电路基础 电工与电子技术 材料与工艺 工程材料 金属工艺学 基本控制 测试与传感技术 微机原理与结构技术 单片机原理及应用 CAD&#x2F;CAM 数控技术及应用 机电控制系统分析与设计 生产 互换性与技术测量 制造技术基础 机械制造工艺学 管理参考链接嵌入式经典书籍分享电子科技大学软件学院本科阶段计算机体系结构学习&amp;嵌入式开发的公开课&#x2F;书籍&#x2F;Blog&#x2F;资料整理嵌入式，计算机常用电子书籍整理开源机器人学学习指南","tags":["💻Code"],"categories":["💻Code"]},{"title":"StepperMotor","path":"/posts/1325oa2/","content":"&#x3D;&#x3D;文章内容大部分来源于网络，仅做摘抄笔记。&#x3D;&#x3D; 定义步进电机是一种将电脉冲信号转换成相应角位移或线位移的电动机。每输入一个脉冲信号，转子就转动一个角度或前进一步，其输出的角位移或线位移与输入的脉冲数成正比，转速和角加速度与脉冲频率成正比（在非超载的情况下）。因此，步进电动机又称脉冲电动机。 步进电机作为一种可控制用的特种电机，利用其没有累计误差的特点，广泛的用于各种开环控制。 学习资料[野火]电机应用开发实战指南 — [野火]电机应用开发实战指南—基于 STM32 文档 步进与伺服这个问题从当年开始学习伺服电机就分不清楚，这里放个视频，讲的不错。 6 分钟讲透伺服电机与步进电机的区别_哔哩哔哩_bilibili &#x2F;&#x2F;","tags":["💻Code","Motor"],"categories":["💻Code"]},{"title":"ESP32","path":"/posts/3foj6j8/","content":"初芯片涨价、支持国产、物联网、方便好用、支持低代码 这些都是选择ESP32的原因之一 使用方法AT指令可以使用简单的AT指令实现一些比较常用的功能 这里丢个链接AT 固件 - ESP32 - — ESP-AT 用户指南 latest 文档 C&#x2F;C++语言编程 VScode 不建议小白使用，网上例程少，上手慢。 初次编译慢，但后续修改方便，配合上vscode的错误提示，还可。 这个是我目前在用的，因为AT指令不能完全满足我的需求，所以只能自己敲代码了。 当然你也可以选择arduino，不过我觉得它又丑又慢，而且我本身经常用vscode。 通过官方插件，日常使用还是很不错的。 Arduino 每次修改都要完全重新编译。 又丑又慢，不过胜在编程操作简单。 而且网上有很多例程，可以借鉴，开发效率稍微高点，建议新手使用。 一些问题 不建议使用esp32的ADC接口，精度较低。 AT指令无法调试PWM，暂未找到解决办法。 ESP32资源有限，只能用在小项目或者副芯片。","tags":["💻Code"],"categories":["💻Code"]},{"title":"STM32&Cubeide","path":"/posts/2fsd2a9/","content":"初 如图所示，stm32有很多种ide，CubeIde综合了其他软件的特点，是st公司推出的一款软件，然鹅，选择stm32的最直接，最简单的原因是它有黑色主题！！！ 由于网上资料较少，所以整理如下笔记。 Printf &amp; Scanf 重定向 取消编译syscalls.c文件或者删除与以下代码相冲突的代码。 添加retarget.h 和 retarget.c （点击即可下载代码） 在main.c中#include &quot;retarget.c&quot; retarget_init(); 完成以上步骤即可 Stlink 调试注意事项接线图如下 另外32最小板使用cubeide调试时一定要5v供电，否则会报错找不到设备。 Muselab DAP 仿真器 DAPLink真的很不错，可以使用cubeide调试，而且调试器很小，还有串口。 使用 DAPLink 配合 cubeide 非常舒服，但是不知道为什么我的不会自动reset，可能是换了国产芯片的原因吧。 定时器公式（截图来自b站洋桃电子视频） 仍在学习中！！！","tags":["💻Code"],"categories":["💻Code"]},{"title":"2021年终总结","path":"/posts/2h3skbi/","content":"因其他博主的年终总结都在元旦或者春节，而我，喜欢在一件大事结束之后进行总结。从去年这个月到现在，我的学习生活中最重要的一件事就是考研，那我就沿着考研的时间线来进行总结。 总的来说，折腾博客从未停止，可以说博客陪我考研，而且是&#x3D;博客是一个很好的倾述地点，在这里，由衷的感谢各位朋友，还有正在看文章的你。 下面的复盘主要是两个方面 考研 or 博客 初三月份，刚刚开学没多久，课程表如图所示（教师已打码） 那时还要上课，但是课程不多，其实三月前就已经确定好了考本校。三月就开始做高数（张宇的基础题）和英语（背背单词什么的），其实三月份并不认真，三天打鱼两天晒网，效率一般，但胜在心态比较好，当时的计划是慢慢适应考研生活，为后面集中精力学习打好心态基础。 三月底，我买了人生中第一个域名，并且搭建了第一个正式的博客 那会刚刚知道 Github，对很多事情还是很陌生，Git 也不会用。 4 月状态已经好很多了，每天都能做到在教室学习（教室 5 楼基本没有人）学习效率也还可以。 博客这边就是经常魔改，瞎折腾。当时还很喜欢逛酷安，甚至莫名其妙上了一次推荐。 中 5 月份，博客这边还在痴迷图床，想要找到一个安全稳定的图床，想用 onedrive 做图床，甚至还为此通宵。 5 月底，视觉识别课程开始编写程序，我就在寝室摸索了几天，最后做的还不错。这里不得不吐槽一下当时的队友（已经记不清名字了），啥也不干，人家忙的很，当然，没干活的最后给了 5%的分数，参与分。 5 月份学习具体在做什么已经不知道了，也找不到记录。。。。 6 月 按部就班吧，心态好像还可以，忙着各种大作业 7 月开始打卡日记，具体内容去日记看吧。 7 月 因为有期末考试，实习参观等等，心态很差，基本三天打鱼两天晒网，没学多少。 说到这里 不得不提吉利余姚 当时去参观 开工资 3000 我们人傻了 老师也傻了 笑而不语 夏令营表现还行，但拿到了优秀营员，这里要感谢机器人视觉识别课程的老师，让我有东西可以讲。 7 月底进行了整体规划(实际上是心态崩了，不想学) 潮8 月 最肝的一个月，因为图书馆只开两层，每天都要早期去占位，一坐就是一天。那段时间比较刻苦，现在想想也是很怀念。 9 月我好像就开始看政治了 最后政治考的一般般 对这东西确实不敏感 9 月 学校开学，整个学校都开始乱糟糟的，自然心态也不是很好。 其实从开始备考到 10 月左右吧，游戏基本没断过，算是一个情绪的出口。 但是之后因为时间紧张还是停掉了。 10 月 想国庆回家来着，但没回 11 月 开始背政治 12 月 考试 2 月底 成绩 406 3 月底 复试 总总的来说，这一年酸甜苦辣咸有，所有的付出都是值得的。 刚开始写这篇文章感觉可以写很多字，但是越到后面，越发现没什么可以写，每天都是重复而机械的日子，但偶尔也有一些收获，这一年让我认清了很多事情，也重新认识了一些人，总之这一年感谢自己的努力，也感谢身边人的照顾。","tags":["Life"],"categories":["🔖Life"]},{"title":"Texttool","path":"/posts/1v242pf/","content":"To practice my English skill, I will use English to finish my idea.Because of my study, I have to finish it later, but trust me, I will finish it. IntroduceIn our daily life, we need to process the sentences, which includes chaotic characters, usually. To solve this problem, I prepare to compile my own tool. Lanage Python UI Tkinter The reason why I use Python and Tkinter is that I have used before. Meanwhile, I can finish it quickly. Feature Real-time processing Usage record Adaptive interface Small function with my heart Character conversion Punctuation modification Spaces and blank lines Links convert Markdown shortcut Find and Replace so on ProcedureContinuous updating Real-time processing Usage record Adaptive interface 1234567891011121314151617181920def window(): root = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称 screenWidth = root.winfo_screenwidth() # 屏幕宽度 screenHeight = root.winfo_screenheight() # 屏幕高度 w = 550 # 窗口宽 x = (screenWidth - w) / 2 # 窗口左上角x轴位置 y = (screenHeight - w) / 2 # 窗口左上角y轴位置 root.geometry(&quot;%dx%d+%d+%d&quot; % (w, w, x, y)) # 表示距离屏幕左上角(400,200) root.title(&quot;Text tool&quot;) # 窗口的标题 root.geometry(&quot;550x550&quot;) # 窗口的大小 root.configure(bg=&#x27;white&#x27;) # root.iconbitmap(&quot;snake.ico&quot;) maintext = Text(root,bg=&#x27;#2B2B2B&#x27;,borderwidth=0,font=(&#x27;microsoft yahei&#x27;, 14, &#x27;bold&#x27;),foreground=&#x27;white&#x27;) maintext.place(relx=0, rely=0, relwidth=1, relheight=1) root.mainloop() # 让程序继续运行，同时进入等待与处理窗口事件，放在程序最后一行 Small function with my heart Character conversion Punctuation modification Spaces and blank lines Links convert Markdown shortcut Find and Replace Final","tags":["💻Code"],"categories":["💻Code"]},{"title":"欲善其事 先利其器","path":"/posts/aqu6r6/","content":"好软推荐（记录） 大部分 Windows 软件来自吾爱破解论坛 压缩包较大，需要请留言。侵删！ 前方大量图片来袭!!! Windows2345 图片浏览器（绿色版）虽然 2345 是出了名的流氓软件，但不得不说，看图软件是很好用的。 Photoshop CC 精简版绿色，启动快，常用功能齐全。 Premiere Pro 2020绿色，启动快，常用功能齐全。 Advanced Renamer批量重命名工具 AIAD 64硬件检测工具 AutoCAD2007远古 CAD 版本，兼容性好! B 站视频下载工具简单方便，支持多线程下载。 Caplos键盘大小写显示工具，适用于无线键盘没有指示灯的用户，支持改键。 使用 RK61 时找到的软件。 Captura开源视频录制软件 支持多种录制方式 CCleaner著名系统清理软件，绿色版。 CoreTempCPU 检测软件，支持 32、64 位系统。 笔记本温度有点高唉，继续 Draw.io点击访问 Everything非常方便的搜索工具 Explorer++多标签文件管理器 冰点下载某文档下载器（大部分功能已经失效，留念） Folder Painter文件夹染色工具 Groupy软件多标签管理 Imagine图片压缩工具 MacroCreatorAHK 语言版按键精灵!!! NotePad++超强记事本工具 PDF-XChange Editor Pluspdf 编辑，查看，转换工具。功能齐全。 PotPlayer强大的视频播放器 ReNamer批量重命名工具 Rolan方便的软件面板 SpaceSniffer直观存储管理软件 ScreenToGif录屏转 gif，gif 编辑。 Sidebar硬件监控工具 Snipaste强大的截图、贴图工具。 TaskbarX任务栏透明，居中工具 Termius全平台终端管理软件 TrafficMonitor硬件监控软件，可以显示在任务栏。 Uninstall Tool‘软’如其名，软件卸载工具。 Watermark Image Pro‘软’如其名，图片加水印软件。支持批量，功能强大。 windows10 manager‘软’如其名，win10 系统管理工具 XMind强大的思维导图软件。 格式工厂格式转换大师 鼠标图标编辑器 Fontmin详情见这里 这个是桌面版软件 小说下载器 AutoOff自动关机软件 知网研学文献管理 ChromeBitwarden免费密码管理器 Infinity 新标签页 pro‘软’如其名 万能复制‘软’如其名 AdGuard 广告拦截器‘软’如其名","tags":["📦software"],"categories":["💻Code"]},{"title":"三根杆","path":"/posts/e556/","content":"初机械手臂（英语：robotic arm）是具有模仿人类手臂功能并可完成各种作业的自动控制设备，这种机器人系统有多关节连结并节允许在平面或三度空间进行运动或使用线性位移移动。 本文的主题是平面三轴机械臂。 启首先来学习一下单轴的，如下图： （系统画图画的） 将物理问题转化为数学问题，建立坐标系： 杆长取r很容易就能得到端点坐标为rcosα,rscinα 是不是很简单，那接下来看两个杆。 中如图所示 继续将物理问题转化为数学问题，建立坐标系： 这里我作了两条辅助线用来辅助理解 图中α，β为绝对角度（也就是相对于x轴的角度），θ1，2，是相对角度（相对于上一段的角度）他的值可能为正也可能为负值，这样我们就能得到α，β与θ的表达式α=θ1，β=θ1+θ2 杆长依旧取r，为了便于说明这里三根杆的长度都取r这里我们很容易就能得到最右端坐标的表达式为：rcosα+rcosβ,rscinα+rsinβ 同理我们可以得到三杆的表达式α=θ1，β=θ1+θ2，γ=θ1+θ2+θ3和rcosα+rcosβ+rcosγ,rscinα+rsinβ+rsinγ 到这里你肯定觉得这好简单，为什么要写一篇文章讲这个？ 上述思路皆为正运动学（正运动学可以大致理解为已知三根杆的长度和角度，求端点坐标）。既然有正运动学，就会有逆运动学（逆运动学可以理解为已知三杆长度和端点坐标，求相关角度）。而在实际运用中，逆运动学往往更多，比如抓取物体。 潮咱们还是从简单的开始 杆长r，端点坐标为x,y，很容易就能得到α角度arccos(r/x),arcsin(r/y) 接下来看两杆 依旧看这幅图，很容易就能想到余弦定理求角度，这没问题，但你可能会遇到一个问题，如图 你得到的结果可能是两个，这个时候就需要添加条件排除掉其中一个，或者根据条件选取最合适的一个，比如说让相对角度尽可能小，这样可以减少电机转动的圈数。 两杆就开始有多解，那三杆呢，肯定会有更多解，这个时候就要根据项目的具体情况去添加限制条件，下面拿具体项目来讲讲。 题目：使用摄像头进行识别并抓取物块放到指定的位置 这里是三个杆，就要想办法增加条件限制解的个数，比如物体的姿态，机械爪需要从哪个角度抓取等等条件。 我这里增加的就是物体姿态角，通过姿态角将三杆问题转化为两杆，再增加相对角度之和最小的条件得到最终结果。 如图所示： 下面详细介绍具体过程和代码实现（MFC &amp; C++） 求解根据坐标和姿态计算角度 移动到合适的抓取姿态依次转动三根杆到合适的角度（也可以同时转动） 抓取进行抓取 在这三个过程中还要通过正运动学计算并绘制爪子另外，计算机的坐标原点和xy轴都在左上角，并不是中心点，需要进行坐标系变换，这里不再详细讲述。 源码仓库GitHub - wxydejoy&#x2F;DrawPath: 三杆 机械臂 这里就不对代码进行介绍了，内容很多，核心部分以及思路已经在上述内容中讲过，欢迎指正。 终思路其实不是很难，难的是其中的细节，敲错一点或者有理解不清楚的结果就会完全不一样。 平面三杆已经有点复杂了，那如果是空间三杆呢？如何计算？ 引機械手臂 - 维基百科，自由的百科全书","tags":["⚙️Machine"],"categories":["💻Code"]},{"title":"三种常用表达式","path":"/posts/iir0g4/","content":"Regex正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本教程，加上应用的时候进行一定的参考，掌握正则表达式不是问题。 许多程序设计语言都支持利用正则表达式进行字符串操作。 保留匹配内容为了保留某部分，通常情况下我们在正则表达式中使用()将我们要保留的内容括住。如下，我们要保留的是中间的数字部分，在替换时使用$1将括号的内容表达出来。$1可以认为是一个变量，代表着()中的内容。 非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f \\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f \\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘ ’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’ ’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 &#123; 标记限定符表达式的开始。要匹配 {，请使用 {。 &#96; &#96; 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 &#123;n&#125; n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 &#123;n,&#125; n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 &#123;n,m&#125; m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 以下正则表达式匹配一个正整数，[1-9]设置第一个数字不是 0，[0-9]* 表示任意多个数字： 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 CornCron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义： 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * &#x2F; 分（Minutes） 0~59的整数 , - * &#x2F; 小时（Hours） 0~23的整数 , - * &#x2F; 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? &#x2F; L W C 月份（Month） 1~12的整数或者 JAN-DEC , - * &#x2F; 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1&#x3D;SUN） , - * ? &#x2F; L C # 年(可选，留空)（Year） 1970~2099 , - * &#x2F; 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： （1）：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）&#x2F;：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5&#x2F;20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 Cidr CIDR Block 地址范围 IP地址数 10.0.0.0&#x2F;8 10.0.0.0 – 10.255.255.255 16,777,216 172.16.0.0&#x2F;12 172.16.0.0 – 172.31.255.255 1,048,576 192.168.0.0&#x2F;16 192.168.0.0 – 192.168.255.255 65,536 比如腾讯云的防火墙就可以根据自己的ip设置 参考资料菜鸟教程 博客园 cidr","tags":["💻Code"],"categories":["💻Code"]},{"title":"upyun","path":"/posts/3f4daa0d/","content":"启前段时间折腾存储空间，折腾一圈还是又拍云最香，免费。但是自己不小心把一个文件夹删了，想要找回，却没有回收站这个功能，很遗憾，它就这么没了。 所以想找个办法备份图床，另外在 Github 逛到了 upyun-sdk 所以就拿来写写。 将又拍云存储的数据下载到本地，并且上传到一个新的存储空间内。 为保证数据完整，禁止删除任意文件。 支持同步 中写这个脚本的最终目的不是省钱（图床一共也没几个钱），而是锻炼自己！ 有目的的学习效率更高！ 通过这个脚本，学习到了一些python的知识 类的定义 （定义了一个myupyun的子类） 类的继承 （myupyun类继承了 upyun-py 中的UpYun类，并且添加了一些新的代码） 递归函数 （又拍云并未提供列举所有目录的接口，自己用递归编写了文件遍历函数） 多级文件夹 （os.open 有时并不能创建文件夹，os.mkdir 只能创建一级文件夹，创建多级文件夹要用 os.mkdirs 另外还认识到一些不足之处来日补上 函数有些凌乱 并发下载 进度条使用不完善 数据库 潮讲完自己的，下面来讲将给读者的（没错就是屏幕前的你！），分享一下使用方法（0 基础）。 环境要求 python3+你喜欢的编辑器 克隆仓库 在你喜欢的地方打开powershell or git bash 这里更建议放服务器里面，当然 Windows 也行 git clone https://github.com/wxydejoy/upyun-backup-server.git 安装依赖 123python -m venv venv # 创建虚拟环境pip install -r requirements.txt 配置参数 打开main.py按照提示填入合适的参数 12345678910111213141516# 只下载和上传，不删除，也就是说不需要删除权限# 源仓库配置st1_name = &quot;&quot;st1_operator = &quot;&quot;st1_password = &quot;&quot;# 目标仓库配置st2_name = &quot;&quot;st2_operator = &quot;&quot;st2_password = &quot;&quot;st2_link = &quot;&quot;# 本地配置local_dir = &quot;local/&quot; # 本地相对路径 RUN 运行 main.py 即可 终这个备份当然可以自动 服务器宝塔：添加定时任务定时运行脚本即可，注意运行路径非宝塔：自行百度添加服务器定时任务 Windows打开系统搜索，搜任务计划程序 点击创建基本任务，按照引导创建即可（友情提示：任务计划程序很好用，思路放开）","tags":["💻Code","📦Python"]},{"title":"HEXO & Fontmin","path":"/posts/79e22e25/","content":"初想要自定义字体吗？字体太大？担心字体拖慢加载速度？快来使用 gulp-fontmin！字体缩小 5 倍不是梦！ 字体一直一来都是静态博客中比较大的文件，尤其是特殊的字体能达到 10Mb 以上，为了提高网页加载速度必须对他动手，之前尝试过字蛛，但已年久失修，现有Fontmin以及gulp-fontmin（其实也好多年了，问题不大），所以调试一下，写篇教程，然后美化一下自己的博客。 启首先需要找到你喜欢的字体，这里不再讨论。 安装依赖（时间有点长是正常情况） 123npm install --global gulp-cli #全局安装gulp指令集npm install gulp --save #安装gulp插件npm install --save-dev gulp-fontmin 预gulp安装完成后运行gulp -v检查版本 123$ gulp -vCLI version: 2.3.0Local version: 4.0.2 中首先在博客根目录新建gulpfile.js 复制以下代码并按照注释修改 123456789101112131415161718192021222324252627282930var gulp = require(&quot;gulp&quot;);var fontmin = require(&quot;gulp-fontmin&quot;);function minifyFont(text, cb) &#123; gulp .src(&quot;source/font/*.ttf&quot;) //原字体所在目录 .pipe( fontmin(&#123; text: text, &#125;) ) .pipe(gulp.dest(&quot;source/fontdest/&quot;)) //压缩后的输出目录 .on(&quot;end&quot;, cb);&#125;gulp.task(&quot;mini-font&quot;, (cb) =&gt; &#123; var buffers = []; gulp .src([&quot;./.deploy_git/**/*.html&quot;]) //HTML文件所在目录请根据自身情况修改 .on(&quot;data&quot;, function (file) &#123; buffers.push(file.contents); &#125;) .on(&quot;end&quot;, function () &#123; var text = Buffer.concat(buffers).toString(&quot;utf-8&quot;); minifyFont(text, cb); &#125;);&#125;);gulp.task(&quot;default&quot;, gulp.parallel(&quot;mini-font&quot;)); 潮引入字体 12345@font-face &#123; font-family: &quot;lxk&quot;; /* 字体名自定义即可 */ src: url(&quot;/fontdest/李旭科书法1.4.ttf&quot;); /* 字体文件路径 */ font-display: swap;&#125; Butterfly 请参照店长自定义字体教程 终最终效果 注：字体越大压缩效果越好 从此可以肆无忌惮的使用自定义字体了","tags":["💻Code","📦Hexo"]},{"title":"Threejs 导入模型","path":"/posts/e90952d5/","content":"效果展示 关于ThreejsThree.js是基于原生WebGL封装运行的三维引擎，在所有WebGL引擎中，Three.js是国内文资料最多、使用最广泛的三维引擎。 Iframe1&lt;iframe id=&quot;modelFrame&quot; src=&quot;https://ts.undf.top/3d/bysj.html&quot; width=&quot;100%&quot; height=&quot;75%&quot; style = &quot;border-radius: 10px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 为了方便引入，采用iframe框架，可以有效减少引入处的代码长度。 源码仓库点我 仓库内3d文件夹下面即是所有源代码。如果不需要自定义修改，建议复制整个文件夹到你的目录内，如果需要自定义模型和样式，请参照下面的关键代码解释 关键代码如果需要更改js文件的位置需要修改 html 文件里面的位置和 stl.js 文件内的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// 如果需要修改文件位置，记得修改这里的路径import * as THREE from &#x27;./build/three.module.js&#x27;;import Stats from &#x27;./build/stats.js&#x27;;import &#123; STLLoader &#125; from &#x27;./build/stl.js&#x27;; let container, stats; let camera, cameraTarget, scene, renderer; init(); animate(); function init() &#123; container = document.createElement( &#x27;div&#x27; ); document.body.appendChild( container ); camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 30 ); camera.position.set( 0, 0.85, 0 ); //相机位置 cameraTarget = new THREE.Vector3( 0, - 0.25, 0 ); scene = new THREE.Scene(); scene.background = new THREE.Color( 0x72645b ); scene.fog = new THREE.Fog( 0x72645b, 2, 15 ); // Ground // const plane = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( &#123; color: 0x999999, specular: 0x101010 &#125; ) ); plane.rotation.x = - Math.PI / 2; plane.position.y = - 0.5; scene.add( plane ); plane.receiveShadow = true; const loader = new STLLoader(); // Binary files。即 二进制 stl 文件 const material = new THREE.MeshPhongMaterial( &#123; color: 0xAAAAAA, specular: 0x111111, shininess: 200 &#125; ); loader.load( &#x27;./model/bysj.stl&#x27;, function ( geometry ) &#123; const mesh = new THREE.Mesh( geometry, material ); //模型参数 mesh.position.set( 0, - 0.18, - 0.1 ); mesh.rotation.set( - Math.PI / 2, 0, 0 ); mesh.scale.set( 0.008, 0.008, 0.008 ); mesh.castShadow = true; mesh.receiveShadow = true; scene.add( mesh ); &#125; ); scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) ); addShadowedLight( 1, 1, 1, 0xffffff, 1.35 ); addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 ); // renderer renderer = new THREE.WebGLRenderer( &#123; antialias: true &#125; ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.outputEncoding = THREE.sRGBEncoding; renderer.shadowMap.enabled = true; container.appendChild( renderer.domElement ); // stats stats = new Stats(); container.appendChild( stats.dom ); // window.addEventListener( &#x27;resize&#x27;, onWindowResize ); &#125; function addShadowedLight( x, y, z, color, intensity ) &#123; const directionalLight = new THREE.DirectionalLight( color, intensity ); directionalLight.position.set( x, y, z ); scene.add( directionalLight ); directionalLight.castShadow = true; const d = 1; directionalLight.shadow.camera.left = - d; directionalLight.shadow.camera.right = d; directionalLight.shadow.camera.top = d; directionalLight.shadow.camera.bottom = - d; directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 4; directionalLight.shadow.bias = - 0.002; &#125; function onWindowResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); &#125; function animate() &#123; requestAnimationFrame( animate ); render(); stats.update(); &#125; function render() &#123; const timer = Date.now() * 0.0005; camera.position.x = Math.cos( timer ) * 3; camera.position.z = Math.sin( timer ) * 3; camera.lookAt( cameraTarget ); renderer.render( scene, camera ); &#125;","tags":["💻Code"],"categories":["💻Code"]},{"title":"从零开始个人主页","path":"/posts/8730864/","content":"初目前我的个人主页是在 threejs 开源项目的基础上自己修改而成，但主页文件过于庞大（加载缓慢），且在部分平台无法完全展示，而且恰逢寒假，时间充足，所以准备一边学习 HTML+CSS+JS，一边写个人主页，有目的的学习会让人更有动力。 启其实我前段时间就写了，但是写出来的很烂，能用但不好用。 而且也嵌入了 threejs，非常庞大，所以这次从头开始，做一个极其简洁的主页。 预初步计划图示如下 手机端 电脑端 感觉有点空空荡荡的，到时候背景搞得花一点。 中设置所有内容居中 设置文字颜色，大小 设置背景等 设置图标，超链接 潮调整间隔padding,调整整体布局 移动端适配 通过 javascript 判断并跳转 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; try&#123; var urlhash=window.location.hash; if(!urlhash.match(&quot;fromapp&quot;))&#123; if((navigator.userAgent.match(/(iPhone|iPod|Android|ios|iPad)/i)))&#123; window.location=&#x27;/mobile/index.html&#x27; &#125; &#125; &#125; catch(err)&#123;&#125;&lt;/script&gt; 终如图 不得不说，前端还是蛮难的，主要是内容非常多。 这次就这样简简单单告一段落，回头再加东西。","tags":["💻Code"],"categories":["💻Code"]},{"title":"图书馆奇遇记","path":"/posts/85b39a47/","content":"今天来聊聊在图书馆遇到的各种自由职业者。 WIFI起名员（点赞）主要特点：Wi-Fi名字起的非常不错 比如：连热点看大学生 coffee的工业制法 花间一壶酒 野指针001 黄金脆皮鸡 等等 猜猜哪个是我的热点名？（提示：小米9） 12.5日更新 有个Wi-Fi名叫连到我就让你嘿嘿嘿，名字很好玩对吧，我就试了试密码，先后试了试88888888,12345678,123456789,1234567890,让我没想到的是竟然蒙对了，密码就是最后一个。笑死。 噪音制造器主要特点：擅长制造各种噪音 品茶大师主要特点：摇头晃脑 品茶出声（⚠️是品茶的声音，不是正常人喝水的声音） 狗粮生产机确实羡慕小情侣，但咱也不是没谈过，你正常谈也没什么问题，别影响其他人嘛 主要特点：聊天 卿卿我我 窗外的乌鸦这个不是说某一位同学，是真的乌鸦，有时很吵，有时又还好。 空调不得不说图书馆的空调是真不错，比宿舍强多了。宿舍空调功率太小，吹不到下铺，桌子底下冻得要死，上铺却很热。","tags":["📚Library"],"categories":["🔖Life"]},{"title":"NPM 图床探究","path":"/posts/50ee91a2/","content":"起因最近在吾爱发帖，苦于福利区不能贴图，要用自己的图床，然后我用了又拍云，一个帖子，一天，3 元。 这个价格有点贵了 hhh，所以想要找个稳定的图床，本来用 jsd + GitHub 但是论坛屏蔽掉了 jsd 好像是因为会传播木马什么的，总之是不安全。 而且写教程还是蛮辛苦的，不想因为图床挂了而不能看，所以想要一个稳定的免费的图床，所以就想到了 npm 经测试 NPM 不会被论坛审核，可以使用 NPM 图床创建及日常使用这里给店长打个广告，我也是通过店长和cyfan才了解到 npm 图床的 npm 图床的使用 NPM 图床的自动化流程如下 12345678910graph TD; Picgo上传多张图片到GitHub --&gt; Windows自动更新npm包版本; Windows自动更新npm包版本--&gt;自动查找替换链接; Windows自动更新npm包版本--&gt; GithubAction自动发包; GithubAction自动发包 --&gt; 图床更新完成; 自动查找替换链接--&gt;push博客仓库; Picgo 上传图片到 GitHub这一步的目的是方便预览，而且为后面查找替换打个基础 而且这一步会遇到 GitHubaction 报错 这不重要 关掉通知 直接无视 GitHub Action 自动推送到 npm这个教程里面有写，不再赘述npm 图床的使用 至于为什么使用 action 发包是因为图床很大，发包很慢 Windows 自动发包利用 shell 脚本，这个脚本放到图床仓库根目录运行即可 12345git pullgit add .git commit -m &#x27; ty &#x27;npm version patchgit push 内容其实很简单，就是简单的 git 命令 批量查找替换`sed` 命令 挺好的~~~12345678910111213141516171819202122232425262728293031323334353637383940414243444546这里是利用shell脚本的查找替换功能比如将`3.txt`中的 `npm.elemecdn.com/wxydeimage` 替换成 `npm.elemecdn.com/wxydeimage@1.0.23` 其中有转义符号`sed -i &#x27;s/cdn.jsdelivr.net\\/gh\\/wxydejoy\\/image/npm.elemecdn.com\\/wxydeimage@1.0.23/g&#x27; 3.txt `加上文件遍历，就变成了这个样子。这个脚本放在博客根目录即可```shell#!/bin/bash#folder=&quot;./test&quot;function readfile ()&#123;#这里`为esc下面的按键符号 for file in `ls $1` do#这里的-d表示是一个directory，即目录/子文件夹 if [ -d $1&quot;/&quot;$file ] then#如果子文件夹则递归 readfile $1&quot;/&quot;$file else#否则就能够读取该文件的地址 echo $1&quot;/&quot;$file#读取该文件的文件名，basename是提取文件名的关键字 sed -i &#x27;s/cdn.jsdelivr.net\\/gh\\/wxydejoy\\/image/npm.elemecdn.com\\/wxydeimage@1.0.23/g&#x27; $folder/$file fi done&#125;#函数定义结束，这里用来运行函数folder=&quot;./source/_post&quot;readfile $folder```其中`wxydejoy image`是GitHub用户名和仓库`wxydeimage`是`npm`包名，`1.0.23` 是版本号写着写着电脑黑屏了，吓死，幸亏是vscode自动保存了，有惊无险## 完全自动化我的目标是只要在提交之前运行一次脚本，无需手动修改版本号==敬请期待==## 后话今天看到npm的图床是想换来着，但是跑了一下速度，还是又拍云香，npm就用来论坛发帖吧，不过这个方案比较适合没有又拍云的同学。�","tags":["💻Hexo"],"categories":["💻Code"]},{"title":"PDF 去除水印教程","path":"/posts/b79413ee/","content":"PS 去水印拿到一个 PDF 你首先要判断一下他是不是源文件， 很显然这个不是，所以无法使用常规手法， 而且这个是纯图片格式，可以选择 PS 去水印，后面遇到其他 PDF 我再更新 效果勉勉强强，本人 PS 技术一般般，方法如下： 将 PDF 转为图片：尽量搞得清楚点，有些软件可能会压缩图片，这里还是推荐 adobe 的，或者 x-change 这些论坛里面都有 随便找一张或者几张 PDF 分页图片导入到 PS，通过调整色阶，对比度，甚至手动抠出 等等方法，去除水印 将 2 中的方法录制为动作（ps 自带录制功能 ALT + F9）实在不行可以百度搜索：ps 录制功能 然后对所有 PDF 分页图片进行批处理（同样是 PS 自带功能 选项卡：文件 – 自动 – 批处理）实在不行可以百度搜索：ps 批处理 将处理好的分页文件合成 PDF 完成 其中最重要的是摸索 PS 工具，将水印去除，这是技术核心。这个就没什么可教的了，百度一下 下一篇更新：pitstop 的使用 Pitstop 的使用方法（偏实用向，新手向）效果图 工具设置首先把 pitstop 的选择器 固定到快捷栏 工具栏 右键 自定义快速工具 找到 Pitstop 选择器 把选择对象和检查器以及动作列表固定上去 案例 1 分块水印分块水印的意识是 水印的这个也算比较复杂的了，我也是第一次遇到，当然这个也可以用 PS 搞，但不建议，因为这个不是纯图片格式的 pdf，也就是说他的每个元素是可以选择的。 首先用选择工具选择你想去除的水印，为了避免广告就拿这个押题来举例吧 右键 显示检查器 ：可以看到它不是文本，不是图片，讲真的我也以为要翻车了，之前没遇到过嘛。 但是注意到了它的颜色比较特别所以摸索了一下 打开动作列表，新建动作 在色彩里面找到选择填充色彩 注意：此时要保持选中水印才能抓取 添加移除所选对象动作 单页测试 测试成功则改成整个文档运行动作，到此完成 案例 2 固定位置水印 且无遮挡 还是老样子，选择器选择，查看属性，不是文本，不是图片，但位置固定（在页眉） 打开动作列表 找到： 选择区域内部或外部的对象 填入数据，注意：锚点数据复制粘贴即可，大小的数据可以稍大一点 单页测试运行即可 PITSTOP 中文过期解决办法打开文件夹：删除除动作列表之外的文件，不行就再替换一下激活文件C:\\Users\\w\\AppData\\Roaming\\Enfocus Prefs Folder refs Folder","tags":["📚Library"],"categories":["🔖Life"]},{"title":"关于小米的一些个人看法","path":"/posts/744f/","content":"%%% tip home %%%-仅仅是个人看法,不喜勿喷,不想吵架.%%% endtip %%%- 我的手机 在 miui+上面的截图,懒得手机截图了 刷的乌龟官改包,至于为什么不用原版,乌龟有个工具包,挺好用的. 工具包截图 乌龟的好像是开发板改的,基本跟原版差不多吧 目前感觉还不错流畅度 动画比之前是好多了 还不错的感觉 偶尔卡顿 感受不明显续航 我的小米 ⑨ 我换过中电的电池 好像是 3800 左右 一天一两充的样子 ,亮屏玩不了多久 只能说 够用发热 平常不打游戏 打游戏也问题不大 感觉还好 满分 5 分 给个 4 分应该不过分 毕竟是老机器了 而且最近一直有新功能在更新,感觉还不错 网上的言论网上说什么的都有,个人感觉喷子居多 我觉得有些点是被舆论放大很多,其实有些是小问题 至于某些型号发热 比如 火龙 888 这个我觉得大概率是真的 毕竟那么多人喷 也不可能空穴来风 而且 888 也是一头火龙 小米的调校本来就一般 这些都不是我在意的点,重点在下面 近期关键问题小米社区屏蔽关键词 发热 掉帧 等等讲真我刚开始看到这个觉得不可能,小米那么开放,肯定不是真的 但我去搜索 真的被屏蔽了 被网友发现之前 被网友骂了之后 有些词还是被屏蔽,没用 到这里其实也还好吧,为了压制舆论,我也理解,勉强接受 小米直面会耍猴就这个,看过的应该都想喷,果核剥壳也发推送讲这个真的太耍猴了,预告说讲讲近期问题,mix4 什么的,还有粉丝关注的问题巴拉巴拉 结果 放完广告就没了 我刚开始以为是线路出问题了 结果 没了 没了 真耍猴 然后各种推迟 小米你的信用哪去了 内测规则改动虽然我没进入内测区 但我好歹在开发板区里面 来看看规则吧 这不是 强行打工么 真拿米粉当屌丝 结语我之前喜欢魅族,现在依旧喜欢,虽然魅族管理也是瞎搞,但手机颜值和 flyme 真的没得说,从 pro7 的智慧屏开始凉凉,之后就没好过 那天跟室友开玩笑说,魅族从后屏开始凉凉,小米会不会也这样 没想到 一语成谶 就看小米后面的动作了 如果 只是 如果 如果 mix4 让粉丝伤心 那小米真的要走下坡路了 至少数码圈子不行了 就像当年的魅族 慢慢的慢慢的 没了没了 没了 但 如果 mix4 惊艳粉丝 凭一己之力 力压群雄,称霸数码圈 那 小米的未来可期 超越苹果 也不是没有可能 但是 但是 但是 如果 小米用惊艳 mix4 配上 miui 版本 小米的未来 我看不到 至少 无法 超越 苹果 就这 希望 MIX4 能 足够惊艳 小米 未来可期","tags":["Life"],"categories":["🔖Life"]},{"title":"AHK脚本","path":"/posts/a583/","content":"关于ahk语言请百度，这里只是记录常用改键代码。 AHK按键参考表鼠标概述tt\tLButton\t鼠标左键RButton\t鼠标右键MButton\t鼠标中键或滚轮高级\tXButton1\t鼠标的第四个按钮 一般和 Browser_Back 执行相同功能XButton2\t鼠标的第五个按钮 一般和 Browser_Forward 执行相同功能Wheel\tWheelDown\t向下转动鼠标滚轮（向您的方向）WheelUp\t向上转动鼠标滚轮（远离您的方向）WheelLeftWheelRight 向左或向右滚动 需要 Windows Vista 或更高版本 这可以用在某些（但并非所有）带第二个滚轮或支持左右滚动的鼠标热键注意: 字母和数字按键的名称和单个字母或数字相同. 例如: b 表示 “b” 键而 5 表示 “5” 键. CapsLock\t大小写锁定键Space\t空格键Tab\tTab 键Enter (或 Return)\t回车键Escape (或 Esc)\t退出键Backspace (或 BS)\t退格键 ScrollLock\t滚动锁定键Delete (或 Del)\t删除键Insert (或 Ins)\t插入改写切换键Home\tHome 键End\tEnd 键PgUp\t向上翻页键PgDn\t向下翻页键Up\t向上方向键Down\t向下方向键Left\t向左方向键Right\t向右方向键 F1 - F24\t在大多数键盘顶部的 12 个或更多的功能键 按键修饰符\tLWin\t左边的 Windows 徽标键 对应的热键前缀为 &lt;#RWin\t右边的 Windows 徽标键 对应的热键前缀为 &gt;#注意：与 Control&#x2F;Alt&#x2F;Shift 不同，没有一般的&#x2F;中性的”Win”键，因为操作系统不支持 不过含 # 修饰符的热键可以被任何一个 Win 键触发 Control ^ Alt ! Shift\t+LControl（或 LCtrl） &lt;^RControl（或 RCtrl） &gt;^LShift\t左 Shift 键 对应的热键前缀为 &lt;+RShift\t右 Shift 键 对应的热键前缀为 &gt;+LAlt\t左 Alt 键 对应的热键前缀为 &lt;!RAlt\t右 Alt 键 对应的热键前缀为 &gt;! Browser_Back\t后退Browser_Forward\t前进Browser_Refresh\t刷新Browser_Stop\t停止Browser_Search\t搜索Browser_Favorites\t收藏夹Browser_Home\t主页Volume_Mute\t静音Volume_Down\t调低音量Volume_Up\t增加音量Media_Next\t下一首Media_Prev\t上一首Media_Stop\t停止Media_Play_Pause\tPlay&#x2F;PauseLaunch_Mail\t打开默认的电子邮件程序Launch_Media\t打开默认的媒体播放器Launch_App1\t打开我的电脑Launch_App2\t打开计算器注：上面列出的每个按键的功能可以通过修改 Windows 注册表进行替换 这个表格中显示的是在 Windows 系统的大多数版本中每个按键的默认功能特别\tAppsKey\t菜单键 这是调用右键上下文菜单的按键PrintScreen\t捕获屏幕CtrlBreak\t暂停\t暂停键中断\t中断键 由于此键和 Pause 含义相同，所以在热键中请使用 ^CtrlBreak 代替 ^Pause 或^Break帮助\t帮助键 此键可能在大多数键盘上不存在 它通常和 F1 不同.Sleep\t休眠键 注意在一些键盘上的 sleep 键可能不是休眠功能SCnnn\t请在 nnn 中指定按键的扫描码 识别上面没有提到的罕见的按键 请参阅特殊按键了解详情VKnn\t请在 nn 中指定十六进制的虚拟按键码 这种极少用的方法还可以避免某些类型的热键需要安装键盘钩子 例如，后面的热键不使用键盘钩子，但副作用是它会在按下 Home 或 NumpadHome 的其中一个时触发：^VK24::MsgBox You pressed Home or NumpadHome while holding down Control.已知限制：强制使用键盘钩子的 VK 热键，例如 *VK24 或 ~VK24，只会触发其中一个热键，而不会触发两者（例如触发 NumpadHome 但不触发 Home） 关于 VKnn 方法的更多细节，请参阅特殊按键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405;=====================================================================o; Feng Ruohang&#x27;s AHK Script | ; CapsLock Enhancement |;---------------------------------------------------------------------o;Description: |; This Script is wrote by Feng Ruohang via AutoHotKey Script. It |; Provieds an enhancement towards the &quot;Useless Key&quot; CapsLock, and |; turns CapsLock into an useful function Key just like Ctrl and Alt |; by combining CapsLock with almost all other keys in the keyboard. |; |;Summary: |;o----------------------o---------------------------------------------o;|CapsLock; | &#123;ESC&#125; Especially Convient for vim user |;|CaspLock + ` | &#123;CapsLock&#125;CapsLock Switcher as a Substituent|;|CapsLock + hjklwb | Vim-Style Cursor Mover |;|CaspLock + uiop | Convient Home/End PageUp/PageDn |;|CaspLock + nm,. | Convient Delete Controller |;|CapsLock + zxcvay | Windows-Style Editor |;|CapsLock + Direction | Mouse Move |;|CapsLock + Enter | Mouse Click |;|CaspLock + &#123;F1&#125;~&#123;F6&#125; | Media Volume Controller |;|CapsLock + qs | Windows &amp; Tags Control |;|CapsLock + ;&#x27;[] | Convient Key Mapping |;|CaspLock + dfert | Frequently Used Programs (Self Defined) |;|CaspLock + 123456 | Dev-Hotkey for Visual Studio (Self Defined) |;|CapsLock + 67890-= | Shifter as Shift |;-----------------------o---------------------------------------------o;|Use it whatever and wherever you like. Hope it help |;=====================================================================o;=====================================================================o; CapsLock Initializer ;|;---------------------------------------------------------------------oSetCapsLockState, AlwaysOff ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Switcher: ;|;---------------------------------o-----------------------------------o; CapsLock + ` | &#123;CapsLock&#125; ;|;---------------------------------o-----------------------------------oCapsLock &amp; `:: ;|GetKeyState, CapsLockState, CapsLock, T ;|if CapsLockState = D ;| SetCapsLockState, AlwaysOff ;|else ;| SetCapsLockState, AlwaysOn ;|KeyWait, `` ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Escaper: ;|;----------------------------------o----------------------------------o; CapsLock | &#123;ESC&#125; ;|;----------------------------------o----------------------------------oCapsLock::Send, &#123;ESC&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Direction Navigator ;|;-----------------------------------o---------------------------------o; CapsLock + h | Left ;|; CapsLock + j | Down ;|; CapsLock + k | Up ;|; CapsLock + l | Right ;|; Ctrl, Alt Compatible ;|;-----------------------------------o---------------------------------oCapsLock &amp; h:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Left&#125; ;| else ;| Send, +&#123;Left&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Left&#125; ;| else ;| Send, +^&#123;Left&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; j:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Down&#125; ;| else ;| Send, +&#123;Down&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Down&#125; ;| else ;| Send, +^&#123;Down&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; k:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Up&#125; ;| else ;| Send, +&#123;Up&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Up&#125; ;| else ;| Send, +^&#123;Up&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; l:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Right&#125; ;| else ;| Send, +&#123;Right&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Right&#125; ;| else ;| Send, +^&#123;Right&#125; ;| return ;|&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Home/End Navigator ;|;-----------------------------------o---------------------------------o; CapsLock + i | Home ;|; CapsLock + o | End ;|; Ctrl, Alt Compatible ;|;-----------------------------------o---------------------------------oCapsLock &amp; i:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;Home&#125; ;| else ;| Send, +&#123;Home&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;Home&#125; ;| else ;| Send, +^&#123;Home&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; o:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;End&#125; ;| else ;| Send, +&#123;End&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;End&#125; ;| else ;| Send, +^&#123;End&#125; ;| return ;|&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Page Navigator ;|;-----------------------------------o---------------------------------o; CapsLock + u | PageUp ;|; CapsLock + p | PageDown ;|; Ctrl, Alt Compatible ;|;-----------------------------------o---------------------------------oCapsLock &amp; u:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;PgUp&#125; ;| else ;| Send, +&#123;PgUp&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;PgUp&#125; ;| else ;| Send, +^&#123;PgUp&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; p:: ;|if GetKeyState(&quot;control&quot;) = 0 ;|&#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, &#123;PgDn&#125; ;| else ;| Send, +&#123;PgDn&#125; ;| return ;|&#125; ;|else &#123; ;| if GetKeyState(&quot;alt&quot;) = 0 ;| Send, ^&#123;PgDn&#125; ;| else ;| Send, +^&#123;PgDn&#125; ;| return ;|&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Mouse Controller ;|;-----------------------------------o---------------------------------o; CapsLock + Up | Mouse Up ;|; CapsLock + Down | Mouse Down ;|; CapsLock + Left | Mouse Left ;|; CapsLock + Right | Mouse Right ;|; CapsLock + Enter(Push Release) | Mouse Left Push(Release) ;|;-----------------------------------o---------------------------------oCapsLock &amp; Up:: MouseMove, 0, -10, 0, R ;|CapsLock &amp; Down:: MouseMove, 0, 10, 0, R ;|CapsLock &amp; Left:: MouseMove, -10, 0, 0, R ;|CapsLock &amp; Right:: MouseMove, 10, 0, 0, R ;|;-----------------------------------o ;|CapsLock &amp; Enter:: ;|SendEvent &#123;Blind&#125;&#123;LButton down&#125; ;|KeyWait Enter ;|SendEvent &#123;Blind&#125;&#123;LButton up&#125; ;|return ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Deletor ;|;-----------------------------------o---------------------------------o; CapsLock + n | Ctrl + Delete (Delete a Word) ;|; CapsLock + m | Delete ;|; CapsLock + , | BackSpace ;|; CapsLock + . | Ctrl + BackSpace ;|;-----------------------------------o---------------------------------oCapsLock &amp; ,:: Send, &#123;Del&#125; ;|CapsLock &amp; .:: Send, ^&#123;Del&#125; ;|CapsLock &amp; m:: Send, &#123;BS&#125; ;|CapsLock &amp; n:: Send, ^&#123;BS&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Editor ;|;-----------------------------------o---------------------------------o; CapsLock + z | Ctrl + z (Cancel) ;|; CapsLock + x | Ctrl + x (Cut) ;|; CapsLock + c | Ctrl + c (Copy) ;|; CapsLock + v | Ctrl + z (Paste) ;|; CapsLock + a | Ctrl + a (Select All) ;|; CapsLock + y | Ctrl + z (Yeild) ;|; CapsLock + w | Ctrl + Right(Move as [vim: w]);|; CapsLock + b | Ctrl + Left (Move as [vim: b]);|;-----------------------------------o---------------------------------oCapsLock &amp; z:: Send, ^z ;|CapsLock &amp; x:: Send, ^x ;|CapsLock &amp; c:: Send, ^c ;|CapsLock &amp; v:: Send, ^v ;|CapsLock &amp; a:: Send, ^a ;|CapsLock &amp; y:: Send, ^y ;|CapsLock &amp; w:: Send, ^&#123;Right&#125; ;|CapsLock &amp; b:: Send, ^&#123;Left&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Media Controller ;|;-----------------------------------o---------------------------------o; CapsLock + F1 | Volume_Mute ;|; CapsLock + F2 | Volume_Down ;|; CapsLock + F3 | Volume_Up ;|; CapsLock + F3 | Media_Play_Pause ;|; CapsLock + F5 | Media_Next ;|; CapsLock + F6 | Media_Stop ;|;-----------------------------------o---------------------------------oCapsLock &amp; F1:: Send, &#123;Volume_Mute&#125; ;|CapsLock &amp; F2:: Send, &#123;Volume_Down&#125; ;|CapsLock &amp; F3:: Send, &#123;Volume_Up&#125; ;|CapsLock &amp; F4:: Send, &#123;Media_Play_Pause&#125; ;|CapsLock &amp; F5:: Send, &#123;Media_Next&#125; ;|CapsLock &amp; F6:: Send, &#123;Media_Stop&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Window Controller ;|;-----------------------------------o---------------------------------o; CapsLock + s | Ctrl + Tab (Swith Tag) ;|; CapsLock + q | Ctrl + W (Close Tag) ;|; (Disabled) Alt + CapsLock + s | AltTab (Switch Windows) ;|; Alt + CapsLock + q | Ctrl + Tab (Close Windows) ;|; CapsLock + g | AppsKey (Menu Key) ;|;-----------------------------------o---------------------------------oCapsLock &amp; s::Send, ^&#123;Tab&#125; ;|;-----------------------------------o ;|CapsLock &amp; q:: ;|if GetKeyState(&quot;alt&quot;) = 0 ;|&#123; ;| Send, ^w ;|&#125; ;|else &#123; ;| Send, !&#123;F4&#125; ;| return ;|&#125; ;|return ;|;-----------------------------------o ;|CapsLock &amp; g:: Send, &#123;AppsKey&#125; ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Self Defined Area ;|;-----------------------------------o---------------------------------o; CapsLock + d | Alt + d(Dictionary) ;|; CapsLock + f | Alt + f(Search via Everything);|; CapsLock + e | Open Search Engine ;|; CapsLock + r | Open Shell ;|; CapsLock + t | Open Text Editor ;|;-----------------------------------o---------------------------------oCapsLock &amp; d:: Send, !d ;|CapsLock &amp; f:: Send, !f ;|CapsLock &amp; e:: Run http://cn.bing.com/ ;|CapsLock &amp; r:: Run Powershell ;|CapsLock &amp; t:: Run C:\\Program Files (x86)\\Notepad++ otepad++.exe ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Char Mapping ;|;-----------------------------------o---------------------------------o; CapsLock + ; | Enter (Cancel) ;|; CapsLock + &#x27; | = ;|; CapsLock + [ | Back (Visual Studio) ;|; CapsLock + ] | Goto Define (Visual Studio) ;|; CapsLock + / | Comment (Visual Studio) ;|; CapsLock + \\ | Uncomment (Visual Studio) ;|; CapsLock + 1 | Build and Run(Visual Studio) ;|; CapsLock + 2 | Debuging (Visual Studio) ;|; CapsLock + 3 | Step Over (Visual Studio) ;|; CapsLock + 4 | Step In (Visual Studio) ;|; CapsLock + 5 | Stop Debuging(Visual Studio) ;|; CapsLock + 6 | Shift + 6 ^ ;|; CapsLock + 7 | Shift + 7 &amp; ;|; CapsLock + 8 | Shift + 8 * ;|; CapsLock + 9 | Shift + 9 ( ;|; CapsLock + 0 | Shift + 0 ) ;|;-----------------------------------o---------------------------------oCapsLock &amp; `;:: Send, &#123;Enter&#125; ;|CapsLock &amp; &#x27;:: Send, = ;|CapsLock &amp; [:: Send, ^- ;|CapsLock &amp; ]:: Send, &#123;F12&#125; ;|;-----------------------------------o ;|CapsLock &amp; /:: ;|Send, ^e ;|Send, c ;|return ;|;-----------------------------------o ;|CapsLock &amp; \\:: ;|Send, ^e ;|Send, u ;|return ;|;-----------------------------------o ;|CapsLock &amp; 1:: Send,^&#123;F5&#125; ;|CapsLock &amp; 2:: Send,&#123;F5&#125; ;|CapsLock &amp; 3:: Send,&#123;F10&#125; ;|CapsLock &amp; 4:: Send,&#123;F11&#125; ;|CapsLock &amp; 5:: Send,+&#123;F5&#125; ;|;-----------------------------------o ;|CapsLock &amp; 6:: Send,+6 ;|CapsLock &amp; 7:: Send,+7 ;|CapsLock &amp; 8:: Send,+8 ;|CapsLock &amp; 9:: Send,+9 ;|CapsLock &amp; 0:: Send,+0 ;|;---------------------------------------------------------------------o 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217^RButton:: Run D:\\Windows\\Snipaste-2.5.1-Beta-x64\\Snipaste.exe snip#WheelDown:: Send, &#123;Volume_Down&#125;#WheelUp:: Send, &#123;Volume_Up&#125;;~LControl:: ;if ( A_PriorHotkey=A_ThisHotkey &amp;&amp; A_TimeSincePriorHotkey &lt; 400 &amp;&amp; A_TimeSincePriorHotkey &gt; 100) ;If WinExist(&quot;搜索&quot;);WinHide ; 使用前面找到的窗口;If !WinExist(&quot;搜索&quot;) ;else\t;\tsend +!F; returnCapsLock &amp; space:: Send, &#123;Enter&#125; CapsLock &amp; 1:: Send,&#123;Enter&#125; CapsLock &amp; v:: Send, ^!&#123;u&#125;Sleep,2000Send, &#123;right&#125;ReturnPgUp:: Send, ^&#123;c&#125;Send, &#123;TAB&#125;Send, ^&#123;v&#125;Send, &#123;ENTER&#125;Return CapsLock &amp; a:: Send, &#123;Left&#125; CapsLock &amp; s:: Send, &#123;Down&#125;CapsLock &amp; d:: Send, &#123;Right&#125;CapsLock &amp; w:: Send, &#123;Up&#125; CapsLock &amp; r:: Send, &#123;F5&#125; CapsLock &amp; Up:: MouseMove, 0, -10, 0, R CapsLock &amp; Down:: MouseMove, 0, 10, 0, R CapsLock &amp; Left:: MouseMove, -10, 0, 0, R CapsLock &amp; Right:: MouseMove, 10, 0, 0, R CapsLock &amp; RShift:: Send, / CapsLock &amp; x:: Send, &#123;Del&#125; CapsLock &amp; z:: Send, &#123;BS&#125; CapsLock &amp; q:: Send, &#123;PrintScreen&#125; ;CapsLock &amp; 3:: CapsLock &amp; F:: Send, +&#123;;&#125; CapsLock &amp; 4:: Send,&#123;F11&#125; CapsLock &amp; 5:: Run https://www.52pojie.cn/ CapsLock &amp; 6:: Send,+6 CapsLock &amp; 7:: Send,+7 ^&amp;&amp; CapsLock &amp; 8:: Send,+8 CapsLock &amp; 9:: Run D:\\onedrive\\XXQG\\123.ahkSleep, 1500Send, &#123;F3&#125; return CapsLock &amp; 0:: Run D:\\onedrive\\XXQG\\XXQG.ahkSleep, 1500Send, &#123;F2&#125; return ;---------------------------------------------------------------------o CapsLock &amp; c:: Run Powershell CapsLock &amp; t:: Run C:\\WINDOWS\\system32 otepad.exe /* ;-----------------------------------o CapsLock &amp; /:: Send, ^e Send, c return ;-----------------------------------o CapsLock &amp; \\:: Send, ^e Send, u return -----------------------------------o */ ;上下左右 wasd/*CapsLock &amp; a:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Left&#125; else Send, +&#123;Left&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Left&#125; else Send, +^&#123;Left&#125; return &#125; return ;-----------------------------------o CapsLock &amp; s:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Down&#125; else Send, +&#123;Down&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Down&#125; else Send, +^&#123;Down&#125; return &#125; return ;-----------------------------------o CapsLock &amp; w:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Up&#125; else Send, +&#123;Up&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Up&#125; else Send, +^&#123;Up&#125; return &#125; return ;-----------------------------------o CapsLock &amp; d:: if GetKeyState(&quot;control&quot;) = 0 &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, &#123;Right&#125; else Send, +&#123;Right&#125; return &#125; else &#123; if GetKeyState(&quot;alt&quot;) = 0 Send, ^&#123;Right&#125; else Send, +^&#123;Right&#125; return &#125; return /*CapsLock &amp; 1:: ;|if GetKeyState(&quot;alt&quot;) = 1 ;|&#123; ;| Send,`#`# return ;|&#125; ;| ;| Send,`#`# return ;| ;|return */SetCapsLockState, AlwaysOff ;|;---------------------------------------------------------------------o;=====================================================================o; CapsLock Switcher: ;|;---------------------------------o-----------------------------------o; CapsLock + ` | &#123;CapsLock&#125; ;|;---------------------------------o-----------------------------------oCapsLock &amp; `:: ;|GetKeyState, CapsLockState, CapsLock, T ;|if CapsLockState = D ;| SetCapsLockState, AlwaysOff ;|else ;| SetCapsLockState, AlwaysOn ;|KeyWait, `` ;|return */","tags":["💻Code","⌨AHK"],"categories":["💻Code"]},{"title":"冰球 背景","path":"/posts/c6bd/","content":"%%% tip home %%%- 首先感谢大佬的开源项目 %%% ghcard teachtyler&#x2F;Icosahedron-Geometry %%%- 还有店长的教程糖果屋微调合集 | Akilar の糖果屋 Custom Beautify | Akilar の糖果屋 %%% span red, 未实现：冰球跟随音乐振动 %%%- 希望有大佬来解决这个问题，我这个小菜鸡实在搞不定。 有建议请评论区留言，欢迎！！ 7.27 更新：关闭移动端并根据屏幕大小判断是否引入并开启 %%% endtip %%%- 最终效果 引入 js只针对 butterfly 主题，其他主题请自己根据情况调整 icebg.js 代码在最下面 在_config.butterfly.yml中inject的bottom:插入代码 1-(&lt;script data-pjax src=&quot;你自己icebg.js的地址&quot;&gt;&lt;/script&gt;); 建议修改合适后再通过 jsd 加速插入，因为每个人需求不一样，如果你想要本站一样的效果就改成这样,如果需要自定义请接着看。 当然，建议读者把代码存到自己仓库 如果只需要当背景，而不是头图，到这里就够了，如果想要跟本站一样，参考店长头图透明教程在costom.css文件中加入 1234/* 头图透明 */#page-header&#123; background: transparent!important;&#125; 注意：因为 butterfly 版本迭代，店长教程中的配置手机 PC 页面白天黑夜共四个背景图的第一步请按diff代码块配置。因为我就掉坑了 店长教程点这里Custom Beautify | Akilar の糖果屋,建议配合糖果屋微调合集 | Akilar の糖果屋配置手机 PC 页面白天黑夜共四个背景图食用，效果更佳。 然后 然后就没了，就这，对，就这。 自定义建议有一定基础的朋友进行自定义修改，比如把球改到侧边栏 icebg.js 我放在了source博客根目录，方便调试，读者可以根据情况修改。 1-(&lt;script data-pjax src=&quot;/icebg.js&quot;&gt;&lt;/script&gt;); 自定义只需要修改icebg.js内的代码就可以了，代码还是挺长的，其他的我也不会了，大家看着办吧，有大佬改记得评论区告诉我一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366// document.write(&quot;&lt;script src=&#x27;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&#x27;&gt;&lt;/script&gt;&quot;);var renderer, scene, camera, composer, lights, circle, skelet, particle, planet, planet2, audioArray, user_audio_amp, audio_wireframe = true, primaryColor = null, secondaryColor = null, thirdColor = null, bg_file, move_bg, bass_wireframe;function loadScript(src, callback) &#123; var script = document.createElement(&quot;script&quot;), head = document.getElementsByTagName(&quot;head&quot;)[0]; script.type = &quot;text/javascript&quot;; script.charset = &quot;UTF-8&quot;; script.src = src; if (script.addEventListener) &#123; script.addEventListener( &quot;load&quot;, function () &#123; callback(); &#125;, false ); &#125; else if (script.attachEvent) &#123; script.attachEvent(&quot;onreadystatechange&quot;, function () &#123; var target = window.event.srcElement; if (target.readyState == &quot;loaded&quot;) &#123; callback(); &#125; &#125;); &#125; head.appendChild(script);&#125;function loadlived() &#123; if (document.body.clientWidth &gt; 900) &#123; document.onreadystatechange = function () &#123; if (document.readyState == &quot;complete&quot;) &#123; loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&quot;, function () &#123;&#125; ); loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/three.min.js&quot;, function () &#123; init(); animate(); &#125; ); &#125; &#125;; &#125;&#125;loadlived();// if (document.body.clientWidth &gt; 768) &#123;// init();// animate();// &#125;;// document.write(&quot;&lt;script src=&#x27;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&#x27;&gt;&lt;/script&gt;&quot;);var renderer, scene, camera, composer, lights, circle, skelet, particle, planet, planet2, audioArray, user_audio_amp, audio_wireframe = true, primaryColor = null, secondaryColor = null, thirdColor = null, bg_file, move_bg, bass_wireframe;function loadScript(src, callback) &#123; var script = document.createElement(&quot;script&quot;), head = document.getElementsByTagName(&quot;head&quot;)[0]; script.type = &quot;text/javascript&quot;; script.charset = &quot;UTF-8&quot;; script.src = src; if (script.addEventListener) &#123; script.addEventListener( &quot;load&quot;, function () &#123; callback(); &#125;, false ); &#125; else if (script.attachEvent) &#123; script.attachEvent(&quot;onreadystatechange&quot;, function () &#123; var target = window.event.srcElement; if (target.readyState == &quot;loaded&quot;) &#123; callback(); &#125; &#125;); &#125; head.appendChild(script);&#125;function loadlived() &#123; if (document.body.clientWidth &gt; 900) &#123; document.onreadystatechange = function () &#123; if (document.readyState == &quot;complete&quot;) &#123; loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/simplex-noise.min.js&quot;, function () &#123;&#125; ); loadScript( &quot;https://cdn.jsdelivr.net/gh/wxydejoy/wxy_bg@main/vendor/three.min.js&quot;, function () &#123; init(); animate(); &#125; ); &#125; &#125;; &#125;&#125;loadlived();// if (document.body.clientWidth &gt; 768) &#123;// init();// animate();// &#125;;function rgb2hex(rgb) &#123; rgb = rgb.match( /^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i ); return rgb &amp;&amp; rgb.length === 4 ? &quot;&quot; + (&quot;0&quot; + parseInt(rgb[1], 10).toString(16)).slice(-2) + (&quot;0&quot; + parseInt(rgb[2], 10).toString(16)).slice(-2) + (&quot;0&quot; + parseInt(rgb[3], 10).toString(16)).slice(-2) : &quot;&quot;;&#125;function init() &#123; var noise = new SimplexNoise(); renderer = new THREE.WebGLRenderer(&#123; antialias: true, alpha: true &#125;); renderer.setSize(document.body.clientWidth, document.body.clientHeight); // renderer.autoClear = false; // renderer.setClearColor(0x000000, 0.0); document.getElementById(&quot;web_bg&quot;).appendChild(renderer.domElement); scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.z = 400; scene.add(camera); circle = new THREE.Object3D(); skelet = new THREE.Object3D(); particle = new THREE.Object3D(); scene.add(circle); scene.add(skelet); scene.add(particle); var geometry = new THREE.TetrahedronGeometry(2, 0); // random particles var geom = new THREE.IcosahedronGeometry(7, 1); // center planet geom.verticesNeedUpdate = true; var geom2 = new THREE.IcosahedronGeometry(15, 1); // wireframe var material = new THREE.MeshPhongMaterial(&#123; color: 0xffffff, shading: THREE.FlatShading, &#125;); // 碎片数量 for (var i = 0; i &lt; 100; i++) &#123; var mesh = new THREE.Mesh(geometry, material); mesh.position .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5) .normalize(); mesh.position.multiplyScalar(90 + Math.random() * 700); mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2); particle.add(mesh); &#125; var mat = new THREE.MeshPhongMaterial(&#123; color: 0x99cccc, shading: THREE.FlatShading, &#125;); var mat2 = new THREE.MeshPhongMaterial(&#123; color: 0xffffff, wireframe: true, side: THREE.DoubleSide, &#125;); planet = new THREE.Mesh(geom, mat); planet.verticesNeedUpdate = true; planet.scale.x = planet.scale.y = planet.scale.z = 16; circle.add(planet); planet2 = new THREE.Mesh(geom2, mat2); planet2.scale.x = planet2.scale.y = planet2.scale.z = 10; skelet.add(planet2); var ambientLight = new THREE.AmbientLight(0x999999); scene.add(ambientLight); lights = []; lights[0] = new THREE.DirectionalLight(0xffffff, 1); lights[0].position.set(1, 0, 0); lights[1] = new THREE.DirectionalLight(0x01183c, 1); lights[1].position.set(0.75, 1, 0.5); lights[2] = new THREE.DirectionalLight(0x00436f, 1); lights[2].position.set(-0.75, -1, 0.5); scene.add(lights[0]); scene.add(lights[1]); scene.add(lights[2]);&#125;function moveObject(prop, math, num, timer = 0) &#123; if (math === &quot;add&quot;) &#123; prop += num; &#125; if (math === &quot;subtract&quot;) &#123; prop -= num; &#125; if (math === &quot;bounce&quot;) &#123; prop.x += num; prop.y += num; prop.z += num; setTimeout(() =&gt; &#123; prop.x -= num; prop.y -= num; prop.z -= num; &#125;, timer); &#125;&#125;function animate() &#123; requestAnimationFrame(animate); if (audio_wireframe) &#123; var planets = [planet, planet2]; &#125; else &#123; var planets = [planet]; &#125; if (audioArray !== undefined) &#123; // var random = Math.floor(Math.random() * audioArray.length - 100) var amp = 1.1; var user_amp = eval(&quot;1.&quot;.concat(user_audio_amp || &quot;80&quot;)); var bass_user_amp = eval(&quot;0.&quot;.concat(user_audio_amp || &quot;80&quot;)); // var user_amp = 1.99 var baseAmp = eval(&quot;0.&quot;.concat(user_audio_amp)) planet planets.map(function (planet) &#123; planet.geometry.vertices.forEach(function (vertex, i) &#123; var beat = audioArray[i]; var volume = audioArray.reduce(function (a, b) &#123; return a + b; &#125;); if (volume &lt;= 2) &#123; beat = beat * 10; &#125; var offset = planet.geometry.parameters.radius; vertex.normalize(); var distance; if (user_audio_amp === 100) &#123; beat = beat * 2; bass_user_amp = 1; distance = offset + beat * user_amp; // distance = offset + beat &#125; else &#123; beat = beat * user_amp; var time = Date.now(); var noiseX = vertex.x + time * 0.0005; var noiseY = vertex.y + time * 0.0005; var noiseZ = vertex.z + time * 0.0005; var planetNoise = noise.noise3D(noiseX, noiseY, noiseZ); distance = offset + planetNoise * beat; // if (turn_liquid) &#123; // distance = offset + beat + user_amp * planetNoise // turns liquid!? // &#125; // if (distance &gt; 15)&#123; // distance = offset + (beat / 2) * 1.1 // debug(distance) // &#125; &#125; // var bass_amp = (bass_user_amp &lt; 0.3) ? 0.3 : (1 - bass_user_amp) var bass_amp = 1 - bass_user_amp; if (bass_amp &lt;= 0.3) &#123; bass_amp = 0.3; &#125; if (i &lt;= 3 &amp;&amp; beat &gt; bass_amp) &#123; if (audio_wireframe === false &amp;&amp; bass_wireframe) &#123; audio_wireframe = true; setTimeout(function () &#123; audio_wireframe = false; &#125;, 250); &#125; if (move_bg) &#123; particle.rotation.x += Math.random() * 0.0005; particle.rotation.y -= Math.random() * 0.004; circle.rotation.x += 0.002; circle.rotation.y -= 0.004; var timer = (beat * 100) / 0.2; moveObject(skelet.position, &quot;bounce&quot;, 0.05, timer); moveObject(planet.position, &quot;bounce&quot;, 0.05, timer); moveObject(particle.position, &quot;bounce&quot;, 0.05, timer); &#125; &#125; vertex.multiplyScalar(distance &lt;= 0.1 ? 1 : distance); &#125;); planet.geometry.verticesNeedUpdate = true; planet.geometry.normalsNeedUpdate = true; planet.geometry.computeVertexNormals(); planet.geometry.computeFaceNormals(); &#125;); &#125; particle.rotation.x += 0.0; particle.rotation.y -= 0.001; circle.rotation.x -= 0.002; circle.rotation.y -= 0.003; skelet.rotation.x -= 0.001; skelet.rotation.y += 0.002; renderer.clear(); renderer.render(scene, camera);&#125;","tags":["💻Hexo"],"categories":["💻Code"]},{"title":"词云图","path":"/posts/40a1/","content":"微词云 微词云 · 简单强大的文字云艺术生成器 (weiciyun.com) %%% folding green, 共享账号、来自吾爱破解论坛 %%%- 15838146089 wang@6089 %%% endfolding %%%- 图悦图悦-在线词频分析工具-词云图制作软件 (picdata.cn) 优词云能用且免费，但不是很好看，有广告但可以跳过。 优词云|词云|标签云|专业强大的在线词云制作工具|在线标签云制作 (uciyun.com) WordItOut EdWordle比较适用于英文文章，中文可以但不好用。 Create word clouds WordItOut EdWordle WordArt.com很慢，慢到我还没用过 Edit word art - WordArt.com","tags":["🌨️词云图"]},{"title":"使用又拍云加速后的HTTPS访问和DNS设置","path":"/posts/ce44/","content":"%%% tip home %%%-https 折腾好久，就是搞不定，最后是自己配置有问题，所以来写个教程 域名以我自己的为例 wxydejoy.top 注：本教程适用于有一定折腾基础的朋友，主要是裸域名的访问，有建议可以评论。 %%% endtip %%%- 最终效果记得 cmdipconfig /flushdns 记得 cmdipconfig /flushdns 记得 cmdipconfig /flushdns 记得 cmdipconfig /flushdns 怎么样，不错吧 Gitpage 设置其实之前有的就不用修改，只是确认一下 Page 设置这个其实是用来检测你的其他设置有没有问题 CNAME 文件 DNS 解析这里答案不唯一，多种方案都行，推荐设置，此处感谢 @哔(bì)哗(huá) 大佬的帮助 尽量照抄。 原理(不一定对，但能用) DNS 设置 又拍云 CDN 加速CDN 怎么开启这里不讲了，只讲关键配置 服务名称随意 裸域名的 CDN 配置 www 域名的 CDN 配置 建议不得不说我现在 typora 配合 picgo 和又拍云写教程很香，之前 GitHub 图床上传超慢，现在秒上传 可以开个存储仓库用来做图床，很香。 另外设置好 cdn 加速之后，可以打开静态资源加速，很不错。 SSL 证书申请这一步最为关键，我这里是阿里的 ssl 免费证书，哪家都可以，建议在自己购买域名的地方申请，可以一键设置 dns 解析，方便快捷。 到这里就可以点击验证，当然如果是其他地方申请的参照各个服务商的设置。 域名验证成功，域名验证记录在证书签发后再删除，否则会因没有解析记录导致证书签发失败。 这里可以看到证书对www.wxydejoy.top和wxydejoy.top是都可用的，接下来会提到。 签发后等一下可以删掉 别忘了在申请证书那地方下载证书 又拍云的 HTTPS 访问设置然后到又拍云 填入刚才下好的证书（文本格式），全部复制就好，全部复制！！！ %%% tip home %%%-一定要记得两个域名(www 和裸域名)都要打开强制 https，不然 www 是打不开的 %%% endtip %%%- 到这里就结束了 记得把签发验证的 dns 解析删掉，不删也问题不大 检验建议用手机开流量访问测试，电脑延迟还是蛮久的，或者重启(有路由器的重启路由器，尤其是闪讯) 记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns记得 cmdipconfig /flushdns","tags":["💻Hexo"],"categories":["💻Code"]},{"title":"AKKO3068说明书","path":"/posts/cd88/","content":"","tags":["⌨️键盘","📃说明书"],"categories":["💻Code"]},{"title":"建站的\"心路历程\"","path":"/posts/fa1d/","content":"在听讲座，有点无聊，所以把昨天的感想写一写 太难了，踩过的坑都忘记了，这。。。。。。。 初衷建设这个网站的目的是为了记录自己学习过程、学习笔记，以便在未来能够复习、反思、回味。 另外这还是一个可以释放压力，可以倾述的平台没人会看我叨叨的，甚至还可以看看自己收藏的电影 起因这学期做了一个项目[课程设计]，是视觉识别和机械臂的综合，所以就想存到 GitHub 上面，偶遇到了 HEXO，第一个主题是 Keep，也实现了自动部署，后面换了Butterfly也就是现在的主题，非常不错 搭建、域名购买、域名解析搭建是参考的知乎找的教程，但还是踩了很多，这里不再赘述，推荐店长教程。 主题选择主题选择有很多，萝卜青菜各有所爱，这里就不讲了 主题魔改魔改必须推店长，yyds，教程直接去店里翻，不会做就去加群。 讲一讲我自己的魔改吧，首先我是不喜欢侧边栏的，虽然我开了，但是只是为了能有个目录，方便翻阅。魔改内容还是蛮多的，想到什么就讲什么吧！ butterfly 主题内置的就不再赘述了(pwa 快把我折磨死了) 先讲动效吧！ 加载动画是我自己魔改的，应该不会放出源码很简单的 动效(就是那些会动的)，置顶轮播，分类，标签外挂(文章里面比较好玩的东西)这些都是店长或者冰老师的插件点这 什么时候有空把源码放上来，需要请评论，没人会看的吧 服务器搭建、备案在国内建站，肯定是要备案的，还得买服务器一点都不合理，没办法，买三个月备份，肝!教程？教程是什么？ 百度一下，你就知道! 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 看教程要仔细，有些教程不全，那就去百度，或者干脆换一篇教程!耐心!仔细!认真![滑稽][菜狗]","tags":["💻Code"],"categories":["💻Code"]},{"title":"Ubuntu常用命令及软件","path":"/posts/3qcul6d/","content":"Ubuntu常用命令系统自带12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# 关机sudo shutdown -h now# 我常用 shutdown now# 重启reboot# 查看当前路径pwd# 查看当前路径下的文件ls# 查看当前路径下的文件，包括隐藏文件ls -a# 查看当前路径下的文件，包括隐藏文件，详细信息ls -al# 列出文件的内容cat# 创建文件夹mkdir# 切换到目录cd# 删除文件rm# 删除文件夹及其子文件夹rm -rf# 移动或者重命名文件mv# 创建文件touch # 查找某个文件find find /home/ -name notes.txt# 进程查找ps -ef | grep python# 解压tar -zxvf xxx.tar.gz# 压缩tar -zcvf # 权限更改chmod# 注意 .ssh 文件夹权限为 700 rsa 文件权限为 600 chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsachmod 644 ~/.ssh/id_rsa.pub chmod 600 ~/.ssh/authorized_keys# 查看端口占用netstat -tunlp | grep 8080# 查看端口占用lsof -i:8080# 查看文件夹大小du -sh# 查看文件夹大小du -h --max-depth=1 v4l2-ctl1234567891011121314# 安装sudo apt-get install v4l-utils# 查看摄像头信息v4l2-ctl --list-devices# 查看摄像头支持的格式v4l2-ctl --list-formats-ext# 查看摄像头支持的分辨率v4l2-ctl --list-formats-ext --device=/dev/video0 常用脚本12345678910111213141516171819202122232425262728# 换源bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh)# ROS 安装 鱼香ROS # 一键安装:ROS(支持ROS和ROS2,树莓派Jetson) 贡献@小鱼 # 一键安装:VsCode(支持amd64和arm64) 贡献@小鱼 # 一键安装:github桌面版(小鱼常用的github客户端) 贡献@小鱼 # 一键安装:nodejs开发环境(通过nodejs可以预览小鱼官网噢 贡献@小鱼 # 一键配置:rosdep(小鱼的rosdepc,又快又好用) 贡献@小鱼 # 一键配置:ROS环境(快速更新ROS环境设置,自动生成环境选择) 贡献@小鱼 # 一键配置:系统源(更换系统源,支持全版本Ubuntu系统) 贡献@小鱼 # 一键安装:Docker(支持amd64和arm64) 贡献@alyssa # 一键安装:cartographer 贡献@小鱼&amp;Catalpa # 一键安装:微信客户端 贡献@小鱼wget http://fishros.com/install -O fishros &amp;&amp; . fishros# 一键更新 GitHub Hostsed -i &quot;/# GitHub520 Host Start/Q&quot; /etc/hosts &amp;&amp; curl https://raw.hellogithub.com/hosts &gt;&gt; /etc/hosts 常用软件旭日x3PI常用命令https://developer.horizon.ai/api/v1/fileData/doc/cn/common_doc_cn/xj3_board_command.html 12345678910hrut_boardid # 查看板子ID 相关hrut_bpuprofile # bpu 相关 hrut_mac # 查看mac地址 设置mac地址hrut_somstatus # 查看板子状态 温度 频率hrut_ddr # 设置 DDR Qos","tags":["💻Code","Ubuntu"],"categories":["💻Code"]},{"title":"py tkinter 学习笔记","path":"/posts/e778/","content":"Python gui 设计之 Tkinter 学习笔记前言其实我之前有用过 QT 写 gui 比如这样 找这玩意花了一小会，很久之前的视觉作业，整体来说还是很方便的，但是 QT 打包起来会很大，不知道是因为 QT，还是因为 opencv，估计是后者，但是我还是想学一下这个 tkinter，至少了解一下，恰好在图书馆又看到了这本书 还有 csdn 的一个博主就下面这个的学习笔记，可以复制！！！所以我来了，有空 fork 一下，防止丢失。 注：本文代码部分来自敲代码的小风 这本书我之前想自学 Python 的时候看过电子版虽然看的不多，感觉还行作者洪锦魁 所以我来学习啦！！！！！！！ 第一章 这两行缺一不可，不知道为什么书上就写了一个，注释掉了另一个 红黄绿真是亮瞎眼，不知道还有没有其他颜色（可以使用 RGB，随便试试） 1234567891011121314151617181920212223242526272829303132333435363738&#x27;&#x27;&#x27;设置窗口的属性&#x27;&#x27;&#x27;from tkinter import *# import tkinterroot = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称root = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称root.title(&quot;!!!&quot;) # 窗口的标题root.geometry(&quot;300x160&quot;) # 窗口的大小root.configure(bg=&#x27;yellow&#x27;) # 窗口的背景颜色screenWidth = root.winfo_screenwidth() # 屏幕宽度screenHeight = root.winfo_screenheight() # 屏幕高度# print(&quot;# 屏幕宽度&quot;,screenWidth) # 屏幕宽度 1536# print(&quot;# 屏幕高度&quot;,screenHeight) # 屏幕高度 864root.iconbitmap(&quot;snake.ico&quot;) # 正常显示# root.iconphoto(False, PhotoImage(file=&#x27;1.png&#x27;)) # 可以正常显示png图片# root.iconphoto(False, PhotoImage(file=&#x27;1.jpg&#x27;)) # 程序报错： _tkinter.TclError: couldn&#x27;t recognize data in image file &quot;1.jpg&quot;w = 300 # 窗口宽h = 160 # 窗口高x = (screenWidth - w)/2 # 窗口左上角x轴位置y = (screenHeight - h)/2 # 窗口左上角y轴位置root.geometry(&quot;%dx%d+%d+%d&quot; % (w,h,x,y)) # 表示距离屏幕左上角(400,200)# +x表示窗口左侧距离屏幕左侧距离, -x表示窗口右侧距离屏幕右侧的距离# +y与-y的含义类似，窗口上侧(下侧)距离屏幕上侧(下侧)的距离root.mainloop() # 让程序继续运行，同时进入等待与处理窗口事件，放在程序最后一行 先去存一下文档，fork 一下 因为各种事耽误了 10 分钟，咕咕咕，有空改改caplos 明天今天展示一下我的 ansys 技能，可能已经忘干净了，[点这里](轴的简单 ANSYS 分析 | WXY_JOY (wxydejoy.top)) 第二章噔噔噔！！ 12345678910111213from tkinter import *root = Tk()root.title(&quot;ch2_1&quot;)label = Label(root,text=&quot;我喜欢使用tkinter！！！&quot;)label.pack() # 包装与定位组件print(type(label)) # &lt;class &#x27;tkinter.Label&#x27;&gt;#也可以用一行 #label = Label(root,text=&quot;我喜欢使用tkinter！！！&quot;).pack()&lt;class &#x27;NoneType&#x27;&gt;可能会引起后续错误#Label(root,text=&quot;我喜欢使用tkinter！！！&quot;).pack() &lt;class &#x27;type&#x27;&gt;所以最好还是分开#当然如果后面用不着了那就随便root.mainloop() 大概看了看，太困了 来了来了，按照目录学有点没动力，那就先找点事情，有目的的学 比如 给之前的那个 markdown 改格式的代码加个界面，go 1234567891011f = open(&#x27;main.txt&#x27;)lines = f.readlines()f.close()print(lines)for i in range(len(lines)): #lines[i] = &quot;![](&quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) + &#x27;)&#x27; + &#x27; &#x27; #lines[i] = &quot;- ![&quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) + &quot;](&quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) + &#x27;)&#x27; +&#x27; &#x27; lines[i] = &quot;- &quot; + lines[i].replace(&#x27; &#x27;,&#x27;&#x27;) +&#x27; &#x27;f = open(&#x27;main.txt&#x27;,&#x27;w&#x27;)f.writelines(lines) 就是这个，一个很简单的代码 先改图标 不知道为什么就是改不成 最后搬来了珍藏的图标 首先需要几个文本 目标界面 到点了，改天再说来了来了，昨天睡觉，趁今天不怎么想学习写一会 这里要用到前几章的知识 Label, Button,Entry,还有窗口管理员 先来 Label 12345678label=Label(root,text=&quot;前缀&quot;,fg=&quot;black&quot;,bg=&quot;#FFEDDF&quot;)label.pack(anchor=N,side=LEFT,padx=10,pady=10)label=Label(root,text=&quot;后缀&quot;,fg=&quot;black&quot;,bg=&quot;#FFEDDF&quot;)label.pack(anchor=N,side=LEFT,padx=50,pady=10)label=Label(root,text=&quot;自动序号&quot;,fg=&quot;black&quot;,bg=&quot;#FFEDDF&quot;)label.pack(anchor=N,side=LEFT,padx=0,pady=10)label=Label(root,text=&quot;-wxy&quot;,fg=&quot;blue&quot;,bg=&quot;#FFEDDF&quot;)label.pack(side=BOTTOM,padx=10,pady=10) 其实有点不很懂，但先这样 然后加入按钮和文本框 到这里，界面基本完成 下面才是重点 1234567def get_url(): urlformer = former.get() urllatter = latter.get() url = main.get(1.0,END) md = urlformer + url.replace(&#x27; &#x27;,&#x27;&#x27;) + urllatter main.delete(1.0,END) main.insert(END,md) 不是很熟悉这些函数，所以搞得有点慢，这书也不好用，东西不给全，还是靠百度 多行 自动排序 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# import tkinterfrom tkinter import *root = Tk() # 建立根窗口 自定义的Tk对象名称，也可以取其它名称root.title(&quot;url-md&quot;)root.config(bg=&#x27;#FFEDDF&#x27;)root.iconbitmap(&quot;hhh.ico&quot;) # 不知道为什么，png和bmp无法显示，或许是我图片问题，但就先这样吧def mwindow(): screenWidth = root.winfo_screenwidth() # 屏幕宽度 screenHeight = root.winfo_screenheight() # 屏幕高度 w = 300 # 窗口宽 h = 160 # 窗口高 x = (screenWidth - w) / 2 # 窗口左上角x轴位置 y = (screenHeight - h) / 2 # 窗口左上角y轴位置 root.geometry(&quot;%dx%d+%d+%d&quot; % (w, h, x, y)) # 表示距离屏幕左上角(400,200) # +x表示窗口左侧距离屏幕左侧距离, -x表示窗口右侧距离屏幕右侧的距离 # +y与-y的含义类似，窗口上侧(下侧)距离屏幕上侧(下侧)的距离 # 练习改函数def windowset(): # label = Label(root,text=&quot;前缀&quot;) # label.pack() label = Label(root, text=&quot;前缀&quot;, fg=&quot;black&quot;, bg=&quot;#FFEDDF&quot;) label.pack(anchor=N, side=LEFT, padx=10, pady=10) label = Label(root, text=&quot;后缀&quot;, fg=&quot;black&quot;, bg=&quot;#FFEDDF&quot;) label.pack(anchor=N, side=LEFT, padx=50, pady=10) label = Label(root, text=&quot;自动序号&quot;, fg=&quot;black&quot;, bg=&quot;#FFEDDF&quot;) label.pack(anchor=N, side=LEFT, padx=0, pady=10) label = Label(root, text=&quot;-wxy&quot;, fg=&quot;blue&quot;, bg=&quot;#FFEDDF&quot;) label.pack(side=BOTTOM, padx=10, pady=10) btn = Button(root, padx=0, pady=0, bd=2,relief=GROOVE, bg=&quot;white&quot;, text=&quot;转换&quot;, command=get_url) # btn.pack(side=BOTTOM,padx=10,pady=10) btn.place(x=130, y=120) global former, latter, main,var former = Entry(root,width=6,bd=2,relief=GROOVE) latter = Entry(root,width=6,bd=2,relief=GROOVE) main = Text(root,width=6,bd=2,relief=GROOVE) former.place(x=45,y=10) latter.place(x=133, y=10) main.place(x=50,y=40,width=200,height=60) var =IntVar() select = Checkbutton(root,bg=&quot;#FFEDDF&quot;,variable=var) select.place(x=230,y=8) root.mainloop() # 让程序继续运行，同时进入等待与处理窗口事件，放在程序最后一行1def get_url(): urlformer = former.get() urllatter = latter.get() url = main.get(1.0,END) if url[-2] == &#x27; &#x27;: url = url[0:-1] # 这里有点迷 md = &#x27;&#x27; if var.get() == 0: md = urlformer + url.replace(&#x27; &#x27;, urllatter + &#x27; &#x27; + urlformer) l = len(urlformer) main.delete(1.0, END) main.insert(END, md[0:-l]) else: md = urlformer + url.replace(&#x27; &#x27;, urllatter + &#x27; &#x27; + urlformer) ran = md.count(&#x27;$&#x27;) for i in range(ran): md = md.replace(&#x27;$&#x27;,str(i),1) l = len(urlformer) main.delete(1.0, END) main.insert(END, md[0:-l])mwindow()windowset() 完成 123完成","tags":["Python","Tkinter"],"categories":["💻Code"]},{"title":"你并不是一无所有","path":"/posts/289b/","content":"","tags":["🔖Life"],"categories":["🔖Life"]},{"title":"气阀板使用说明","path":"/posts/e8f42309/","content":"物料准备 气阀控制板 气阀（smc 比例阀,需自备） 电源 蓝牙模块 若干接线端子 硬件安装比例阀接线（已经接好）注意判断比例阀反馈信号是否为电压型 5V，如果不是不要接黑色线。如果不确定，请联系我!! 根据线缆颜色根据图片接线，注意正反！ 蓝牙模块连接（已经接好）这里需要接 4 跟线：3.3V GND 根据控制板上的标识和蓝牙模块上的标识一一对应。 RX TX 需要根据串口协议进行反接，只需要这四根 软件安装与使用软件下载链接 https://wekko.lanzout.com/ikSh82071ila 连接蓝牙系统设置 -&gt; 蓝牙和其他设备 -&gt; 添加设备 单击蓝牙 找到设备 ITV 配对密码 1234 配对成功即可 连接蓝牙打开软件单击 查看蓝牙对应的串口 找到蓝牙模块对应的串口号 选择对应的串口，单击打开串口，程序按钮文字会变为关闭窗口，此时即为连接成功 有时会有这种弹窗点击后输入 pin 1234 即可 软件使用若不使用蓝牙，串口配置如下： 每个比例阀都由一个模块控制，这里的值只有在敲回车或者点击空白处才会生效，而进度条即时生效。 右侧可以简单编程后运行 12345// 命令以行分隔D100 // 延时100msA00B1000 // 通道0设置为1000A99B0000 // 读取ADC支持读取和保存为txt文件 底部有一些按钮可以辅助编程 通信协议注：&#x2F;&#x2F; 后为注释 上位机 -&gt; 控制板 12A00B0000 // 通道0气压值0A01B1000 // 通道1气压值0.1MPa 控制板 -&gt; 上位机 1T: 时间戳 ch：各个通道的值，这里对应的电压值","tags":["🔖Life"],"categories":["🔖Life"]},{"title":"Fluent Search","path":"/posts/d0da/","content":"ttddww 顶顶顶 zai%%% tip home %%%-可能是第一次正儿八经的的测一款软件，说是测，其实是把官网翻译一下，然后再讲讲自己的使用感受。很多内容都是搬运自官网。侵删！ 另外，虽然这个软件有github，但只是用来反馈问题，闭源，但免费。 另外，无中文。Ces %%% endtip %%%- %%% p center logo large, Fluent Search %%%- With Fluent Search, you can search for running apps, browser tabs, in-app content, files and more. Available for Windows 10&#x2F;11 only.不会吧不会吧，不会有人还没换win10吧 微软商店链接点这 Fluent 搜索功能指南使用 Fluent Search，您可以立即搜索计算机上可用的各种资源并访问它们。Fluent Search 有很多功能，在本指南中，我们将介绍一些主要功能。 进程搜索听起来，进程搜索可让您轻松找到计算机上的任何活动进程。 进程是具有窗口的活动应用程序，您可以通过搜索窗口标题或进程名称来找到它。 此外，Fluent Search 可以在进程内找到应用内元素，例如选项卡、按钮和超链接，以立即访问它们。 屏幕搜索有些人发现使用鼠标会降低工作效率，尤其是在编程等非常面向键盘的工作中。 如果您是这些人中的一员，Fluent Search 可以满足您的需求。屏幕搜索功能可让您使用键盘轻松控制计算机。 搜索标签如上所述，Fluent Search 会搜索您计算机中的各种资源，包括但不限于 - 文件、应用程序、进程、书签、历史结果等。 为了帮助您轻松获得最相关的结果，Fluent Search 提供了一项名为”搜索标签”的功能。 Fluent Search 中的每个结果可能包含多个描述此结果的标签，使用这些标签您可以轻松过滤您的搜索以找到最相关的结果。 网络搜索是否需要立即搜索网络而无需打开浏览器并创建新标签？ 然后你明白了，使用 Fluent Search，你可以轻松地在你最喜欢的搜索引擎中进行搜索。 自定义Fluent Search 的构建考虑到了现代设计，但最重要的是能够让您自定义它。 你喜欢简约风格吗？您想在屏幕上获得尽可能多的信息吗？Fluent Search 助您一臂之力。您可以根据需要轻松缩放搜索窗口并更改其外观。 导航简单性是 Fluent Search 非常重要的方面。 在提供丰富的搜索结果的同时尽量保持简单是 Fluent Search 的一个持续挑战。 我的介绍最小外观 外观是那种磨砂透明玻璃的感觉，非常不错。 设置界面 写不动了，再说吧�","tags":["💻Software"],"categories":["💻Software"]},{"title":"python + QT + 📄 Opencv 学习笔记","path":"/posts/d364/","content":"部分功能展示这是视觉识别课程做的一个小软件 主要功能：通过 opencv 模块识别物体中心坐标，计算物体姿态角度，计算叶子面积和形心，支持文件上传识别以及摄像头采集。 目前已开源，GitHub 仓库here 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390import sysimport cv2import mathimport numpy as npfrom PyQt5 import QtCore, QtGui, QtWidgetsfrom PyQt5.QtCore import *from PyQt5.QtGui import *from PyQt5.QtWidgets import QFileDialog, QMainWindowfrom untitled import Ui_MainWindowfrom PyQt5 import QtCore, QtGui, QtWidgets#UIclass Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(&quot;MainWindow&quot;) MainWindow.resize(1125, 595) self.centralwidget = QtWidgets.QWidget(MainWindow) self.centralwidget.setObjectName(&quot;centralwidget&quot;) self.labelCamera = QtWidgets.QLabel(self.centralwidget) self.labelCamera.setGeometry(QtCore.QRect(0, 0, 200, 200)) self.labelCamera.setObjectName(&quot;labelCamera&quot;) self.labelCapture = QtWidgets.QLabel(self.centralwidget) self.labelCapture.setGeometry(QtCore.QRect(200, 0, 400, 400)) self.labelCapture.setObjectName(&quot;labelCapture&quot;) self.btnOpenCamera = QtWidgets.QPushButton(self.centralwidget) self.btnOpenCamera.setGeometry(QtCore.QRect(80, 490, 75, 23)) self.btnOpenCamera.setObjectName(&quot;btnOpenCamera&quot;) self.btnCapture = QtWidgets.QPushButton(self.centralwidget) self.btnCapture.setGeometry(QtCore.QRect(200, 490, 75, 23)) self.btnCapture.setObjectName(&quot;btnCapture&quot;) self.btnReadImage= QtWidgets.QPushButton(self.centralwidget) self.btnReadImage.setGeometry(QtCore.QRect(330, 490, 75, 23)) self.btnReadImage.setObjectName(&quot;btnReadImage &quot;&quot;&quot;) self.btnGray = QtWidgets.QPushButton(self.centralwidget) self.btnGray.setGeometry(QtCore.QRect(460, 490, 75, 23)) self.btnGray.setObjectName(&quot;btnGray&quot;) self.btnThreshold = QtWidgets.QPushButton(self.centralwidget) self.btnThreshold.setGeometry(QtCore.QRect(570, 490, 75, 23)) self.btnThreshold.setObjectName(&quot;btnThreshold&quot;) self.labelResult = QtWidgets.QLabel(self.centralwidget) self.labelResult.setGeometry(QtCore.QRect(600, 0, 400, 400)) self.labelResult.setObjectName(&quot;labelResult&quot;) self.btnCalculate = QtWidgets.QPushButton(self.centralwidget) self.btnCalculate.setGeometry(QtCore.QRect(680, 490, 75, 23)) self.btnCalculate.setObjectName(&quot;btnCalculate&quot;) self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget) self.textBrowser.setGeometry(QtCore.QRect(20, 420, 131, 31)) self.textBrowser.setObjectName(&quot;textBrowser&quot;) self.btnRectangle = QtWidgets.QPushButton(self.centralwidget) self.btnRectangle.setGeometry(QtCore.QRect(870, 490, 75, 23)) self.btnRectangle.setObjectName(&quot;btnRectangle&quot;) self.btnDenoise = QtWidgets.QPushButton(self.centralwidget) self.btnDenoise.setGeometry(QtCore.QRect(770, 490, 75, 23)) self.btnDenoise.setObjectName(&quot;btnDenoise&quot;) self.lineEdit = QtWidgets.QLineEdit(self.centralwidget) self.lineEdit.setGeometry(QtCore.QRect(20, 380, 113, 20)) self.lineEdit.setObjectName(&quot;lineEdit&quot;) MainWindow.setCentralWidget(self.centralwidget) self.statusbar = QtWidgets.QStatusBar(MainWindow) self.statusbar.setObjectName(&quot;statusbar&quot;) MainWindow.setStatusBar(self.statusbar) self.retranslateUi(MainWindow) self.btnOpenCamera.clicked.connect(MainWindow.btnOpenCamera_Clicked) self.btnCapture.clicked.connect(MainWindow.btnCapture_Clicked) self.btnReadImage.clicked.connect(MainWindow.btnReadImage_Clicked) self.btnGray.clicked.connect(MainWindow.btnGray_Clicked) self.btnThreshold.clicked.connect(MainWindow.btnThreshold_Clicked) self.btnCalculate.clicked.connect(MainWindow.btnCalculate_Clicked) self.btnDenoise.clicked.connect(MainWindow.btnDenoise_Clicked) self.btnRectangle.clicked.connect(MainWindow.btnRectangle_Clicked) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;)) self.labelCamera.setText(_translate(&quot;MainWindow&quot;, &quot;摄像头&quot;)) self.labelCapture.setText(_translate(&quot;MainWindow&quot;, &quot;捕获图&quot;)) self.btnOpenCamera.setText(_translate(&quot;MainWindow&quot;, &quot;摄像头&quot;)) self.btnCapture.setText(_translate(&quot;MainWindow&quot;, &quot;捕获图片&quot;)) self.btnReadImage.setText(_translate(&quot;MainWindow&quot;, &quot;打开图片&quot;)) self.btnGray.setText(_translate(&quot;MainWindow&quot;, &quot;灰度化&quot;)) self.btnThreshold.setText(_translate(&quot;MainWindow&quot;, &quot;阈值分割&quot;)) self.labelResult.setText(_translate(&quot;MainWindow&quot;, &quot;结果图&quot;)) self.btnCalculate.setText(_translate(&quot;MainWindow&quot;, &quot;绿叶形心&quot;)) self.btnRectangle.setText(_translate(&quot;MainWindow&quot;, &quot;计算面积&quot;)) self.btnDenoise.setText(_translate(&quot;MainWindow&quot;, &quot;方块角度&quot;))class PyQtMainEntry(QMainWindow, Ui_MainWindow): def __init__(self): super().__init__() self.setupUi(self) self.camera = cv2.VideoCapture(0) self.is_camera_opened = False # 摄像头有没有打开标记 # 定时器：30ms捕获一帧 self._timer = QtCore.QTimer(self) self._timer.timeout.connect(self._queryFrame) self._timer.setInterval(30) def btnOpenCamera_Clicked(self): &#x27;&#x27;&#x27; 打开和关闭摄像头 &#x27;&#x27;&#x27; self.is_camera_opened = ~self.is_camera_opened if self.is_camera_opened: self.btnOpenCamera.setText(&quot;关闭摄像头&quot;) self._timer.start() else: self.btnOpenCamera.setText(&quot;打开摄像头&quot;) self._timer.stop() def btnCapture_Clicked(self): &#x27;&#x27;&#x27; 捕获图片 &#x27;&#x27;&#x27; # 摄像头未打开，不执行任何操作 if not self.is_camera_opened: return self.captured = self.frame # 后面这几行代码几乎都一样，可以尝试封装成一个函数 rows, cols, channels = self.captured.shape bytesPerLine = channels * cols # Qt显示图片时，需要先转换成QImgage类型 QImg = QImage(self.captured.data, cols, rows, bytesPerLine, QImage.Format_RGB888) self.labelCapture.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelCapture.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnReadImage_Clicked(self): &#x27;&#x27;&#x27; 从本地读取图片 文件路径不能有中文 &#x27;&#x27;&#x27; # 打开文件选取对话框 filename, _ = QFileDialog.getOpenFileName(self, &#x27;打开图片&#x27;) if filename: self.captured = cv2.imread(str(filename)) self.frame = cv2.imread(str(filename)) # OpenCV图像以BGR通道存储，显示时需要从BGR转到RGB self.captured = cv2.cvtColor(self.captured, cv2.COLOR_BGR2RGB) rows, cols, channels = self.captured.shape bytesPerLine = channels * cols QImg = QImage(self.captured.data, cols, rows, bytesPerLine, QImage.Format_RGB888) self.labelCapture.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelCapture.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnGray_Clicked(self): &#x27;&#x27;&#x27; 灰度化 &#x27;&#x27;&#x27; # 如果没有捕获图片，则不执行操作 if not hasattr(self, &quot;captured&quot;): return self.cpatured = cv2.cvtColor(self.captured, cv2.COLOR_RGB2GRAY) rows, columns = self.cpatured.shape bytesPerLine = columns # 灰度图是单通道，所以需要用Format_Indexed8 QImg = QImage(self.cpatured.data, columns, rows, bytesPerLine, QImage.Format_Indexed8) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnThreshold_Clicked(self): &#x27;&#x27;&#x27; Otsu自动阈值分割 &#x27;&#x27;&#x27; #self.textBrowser.setText(&quot;dadad&quot;) if not hasattr(self, &quot;captured&quot;): return _, self.cpatured = cv2.threshold( self.cpatured, 0, 250, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) rows, columns = self.cpatured.shape bytesPerLine = columns # 阈值分割图也是单通道，也需要用Format_Indexed8 QImg = QImage(self.cpatured.data, columns, rows, bytesPerLine, QImage.Format_Indexed8) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) #self.wxy.setText(&quot;%d&quot;, 11) def btnRectangle_Clicked(self): img = self.frame m=0 n=0 for i in range(1, img.shape[0]): for j in range(1, img.shape[1]): # b = 2*img.item(i, j, 1) - img.item(i, j, 0) - img.item(i, j, 2) a = 5 if (img.item(i, j, 0) &gt; 40) and (img.item(i, j,0) &lt; 70 ) and (img.item(i, j, 1) &gt; 40) and (img.item(i, j,1) &lt; 70 ) and (img.item(i, j, 2) &gt; 40) and (img.item(i, j,2) &lt; 70 ) : for k in range(0, 3): img.itemset((i, j, k), 0) n = n + 1 if (img.item(i, j, 1) - img.item(i, j, 0) &gt; a) and (img.item(i, j, 1) - img.item(i, j, 2) &gt; a): for k in range(0, 3): img.itemset((i, j, k), 0) m = m + 1 else: for k in range(0, 3): img.itemset((i, j, k), 255) s = m/n*25 self.lineEdit.setText(&quot;%s&quot; % s ) img = cv2.blur(img, (3, 3)) img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) img = cv2.medianBlur(img, 5) img = cv2.blur(img, (3, 3)) ret, img = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) img = cv2.bilateralFilter(img, 5, 75, 75) img = cv2.medianBlur(img, 5) img = cv2.Canny(img, 100, 200) img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) self.frame = img img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnDenoise_Clicked(self): img = self.frame img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) a = 0 b = 0 for i in range(1, len(contours)): cnt = contours[i] M = cv2.moments(cnt) c = int(M[&#x27;m00&#x27;]) if c &gt; a: a = c b = i cv2.drawContours(img, contours, b, (0, 0, 255), 3) cnt = contours[b] M = cv2.moments(cnt) cx = int(M[&#x27;m10&#x27;] / M[&#x27;m00&#x27;]) cy = int(M[&#x27;m01&#x27;] / M[&#x27;m00&#x27;]) cv2.circle(img, (cx, cy), 2, (0, 255, 0), -1) (x, y), (MA, ma), angle = cv2.fitEllipse(cnt) leftmost = tuple(cnt[cnt[:, :, 0].argmin()][0]) rightmost = tuple(cnt[cnt[:, :, 0].argmax()][0]) topmost = tuple(cnt[cnt[:, :, 1].argmin()][0]) bottommost = tuple(cnt[cnt[:, :, 1].argmax()][0]) cv2.circle(img, (leftmost[0], leftmost[1]), 2, (0, 255, 0), -1) cv2.circle(img, (rightmost[0], rightmost[1]), 2, (0, 255, 0), -1) dy = rightmost[1]-leftmost[1] dx = rightmost[0]-leftmost[0] temp = math.sqrt(dx * dx + dy * dy) angle_cos = dx / temp; angle = math.acos(angle_cos) * 180 / 3.14 if dy &lt; 0: angle = -angle self.lineEdit.setText(&quot;%s&quot; % angle) img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) &#x27;&#x27;&#x27; a = 1 img = self.frame img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) #a = self.lineEdit.text() #self.textBrowser.setText(a) lower_blue = np.array([110,50,50]) upper_blue = np.array([130,255,255]) img = cv2.inRange(img, lower_blue, upper_blue) #self.textBrowser.setText(&quot;%d,%d,a&quot; % a/1000 % a) #a = self.textBrowser.text() # 提取颜色 #img = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # ret,thresh = cv.threshold(gray,255,255,60) # ret,thresh1 = cv.threshold(gray,127,255,cv.THRESH_BINARY) img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) #den = cv2.fastNlMeansDenoisingColor(img, None, 10, 10, 7, 21) #img_rows, img_cols, channels = denoise.shape #bytesPerLine = channels * img_cols #QImg = QImage(denoise.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) #self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( # self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) &#x27;&#x27;&#x27; @QtCore.pyqtSlot() def _queryFrame(self): &#x27;&#x27;&#x27; 循环捕获图片 &#x27;&#x27;&#x27; ret, self.frame = self.camera.read() img_rows, img_cols, channels = self.frame.shape bytesPerLine = channels * img_cols cv2.cvtColor(self.frame, cv2.COLOR_BGR2RGB, self.frame) QImg = QImage(self.frame.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelCamera.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelCamera.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)) def btnCalculate_Clicked(self): img = self.frame m = 0 for i in range(1, img.shape[0]): for j in range(1, img.shape[1]): # b = 2*img.item(i, j, 1) - img.item(i, j, 0) - img.item(i, j, 2) a = 5 #绿色bgr if (img.item(i, j, 1) - img.item(i, j, 0) &gt; a) and (img.item(i, j, 1) - img.item(i, j, 2) &gt; a): for k in range(0, 3): img.itemset((i, j, k), 0) m = m + 1 else: for k in range(0, 3): img.itemset((i, j, k), 255) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) #a = max(contours) area = [] a = 0 b = 0 for i in range(1,len(contours)): cnt = contours[i] M = cv2.moments(cnt) c = int(M[&#x27;m00&#x27;]) if c &gt; a: a = c b = i cv2.drawContours(img, contours, b, (0, 0, 255), 3) cnt = contours[b] M = cv2.moments(cnt) cx = int(M[&#x27;m10&#x27;] / M[&#x27;m00&#x27;]) cy = int(M[&#x27;m01&#x27;] / M[&#x27;m00&#x27;]) cv2.circle(img,(cx,cy), 2, (0,255,0), -1) (x, y), (MA, ma), angle = cv2.fitEllipse(cnt) self.lineEdit.setText(&quot;%s&quot; % angle) img_rows, img_cols, channels = img.shape bytesPerLine = channels * img_cols QImg = QImage(img.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888) self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled( self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))if __name__ == &quot;__main__&quot;: app = QtWidgets.QApplication(sys.argv) window = PyQtMainEntry() window.show() sys.exit(app.exec_())","tags":["💻Code","📃Study"],"categories":["💻Code"]},{"title":"404","path":"/404.html","content":"您访问的页面已经丢失访问原站访问镜像站"},{"path":"/css/font.css","content":"@font-face{ font-family:'lxk' ; /* 字体名自定义即可 */ src:url('/fontdest/LXGWWenKai-Regular.ttf'); /* 字体文件路径 */ font-display : swap; } @font-face{ font-family:'lxks' ; /* 字体名自定义即可 */ src:url('/fontdest/LXGWWenKaiScreen.ttf'); /* 字体文件路径 */ font-display : swap; } /* body{ font-family: 'lxk'; } */"},{"path":"/css/mtime.css","content":".mtime-movie_card { font-family: 'Montserrat', helvetica, arial, sans-serif; font-size: 14px; font-weight: 400; font-weight: 400; position: relative; display: block; width: 100%; box-sizing: border-box; margin: 30px auto; overflow: hidden; border-radius: 10px; transition: all 0.4s; box-shadow: 0px 0px 120px -25px rgba(0, 0, 0, 0.5); } .mtime-movie_card:hover { -webkit-transform: scale(1.02); transform: scale(1.02); box-shadow: 0px 0px 80px -25px rgba(0, 0, 0, 0.5); transition: all 0.4s; } .mtime-movie_card .mtime-info_section { position: relative; width: 100%; height: 100%; background-blend-mode: multiply; z-index: 2; border-radius: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header { position: relative; padding: 25px; height: 40%; } .mtime-movie_card .mtime-info_section .mtime-movie_header h1 { color: black; font-weight: 400; margin: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header h4 { color: #555; font-weight: 400; margin: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header .mtime-minutes { display: inline-block; margin-top: 5px; color: #555; padding: 5px; border-radius: 5px; border: 1px solid rgba(0, 0, 0, 0.05); } .mtime-movie_card .mtime-info_section .mtime-movie_header .mtime-type { display: inline-block; color: #959595; margin-left: 10px; } .mtime-movie_card .mtime-info_section .mtime-movie_header .mtime-locandina { position: relative; float: left; margin-right: 20px; height: 170px; box-shadow: 0 0 20px -10px rgba(0, 0, 0, 0.5); } .mtime-name{ font-size: 25px; font-weight: 600; } .mtime-movie_card .mtime-info_section .mtime-movie_desc { padding: 0 25px 15px 25px; height: 100%; } .mtime-movie_card .mtime-info_section .mtime-movie_desc .mtime-text { color: #545454; } .mtime-movie_card .mtime-blur_back { position: absolute; top: 0; z-index: 1; height: 100%; right: 0; background-size: cover; border-radius: 11px; } @media screen and (min-width: 768px) { .mtime-movie_header { width: 65%; } .mtime-movie_desc { width: 50%; } .mtime-info_section { background: linear-gradient(to right, #e5e6e6 50%, transparent 80%); } .mtime-blur_back { width: 50%; background-position: -100% 10% !important; } } @media screen and (max-width: 768px) { .mtime-movie_card { width: 95%; margin: 70px auto; min-height: 350px; height: auto; } .mtime-blur_back { width: 100%; background-position: 50% 50% !important; } .mtime-movie_header { width: 100%; margin-top: 50px; } .mtime-movie_desc { padding: 0 5% !important; width: 90%; } .mtime-info_section { background: linear-gradient(to top, #e5e6e6 50%, transparent 100%); display: inline-grid; } }"},{"path":"/css/my.css","content":"/* 微博边框 */ #start>aside>div>div.widgets>widget.widget-wrapper.timeline>div.widget-body.fs14>div>div>div.body>a { border: none; } /* 微博点赞 */ #start>aside>div>div.widgets>widget.widget-wrapper.timeline>div.widget-body.fs14>div>div>div.body>div.footer { display: none; } .widget-wrapper.timeline .tag-plugin.timeline .timenode .body .justified-gallery .body { display: none; } /* 图片圆角 */ .tag-plugin.timeline[api] .body a img { border-radius: 10px; } #main > div.post-list.post > a > div > div > div{ display: none; }"},{"title":"Filecodebox","path":"/file/index.html","content":"Filecodebox网上采集的一些站点,临时使用,不定期更新,配合js脚本进行验证 js脚本:验证网站列表是否可用,并输出可用的网站列表 这是一个用来检测网址是否可访问的 JavaScript 代码片段：这是一个用来检测网址是否可访问的 JavaScript 代码片段： 检测 const urls = ['https://www.googddle.com', 'https://www.baidddu.com', 'https://www.giddthub.com']; const proxyUrl = 'https://green-dew-5e83.wxydejoy.workers.dev/'; async function checkUrl(url) { try { const response = await fetch(proxyUrl + url); return response.ok; } catch (error) { return false; } } async function checkUrls() { const resultDiv = document.getElementById('result'); resultDiv.innerHTML = '正在检测，请稍候...'; const results = await Promise.all(urls.map(url => checkUrl(url))); const table = '网址状态' + results.map((result, index) => `${urls[index]}${result ? '可访问' : '不可访问'}`).join('') + ''; resultDiv.innerHTML = table; }"},{"path":"/file/x.html","content":"Website Checker Website Checker Check function checkWebsite(url) { return new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload = () => { if (xhr.status === 200) { resolve(true); } else { resolve(false); } }; xhr.onerror = () => reject(new Error('Failed to load website.')); xhr.send(); }); } async function checkWebsiteWithProxy(url) { const proxyUrl = 'https://green-dew-5e83.wxydejoy.workers.dev/'; const apiUrl = proxyUrl + url; try { const response = await fetch(apiUrl); if (response.ok) { return true; } else { return false; } } catch (error) { throw new Error('Failed to load website.'); } } // 使用示例 checkWebsiteWithProxy('https://www.ulaz.cn/') .then((result) => { if (result) { console.log('Website is accessible.'); } else { console.log('Website is not accessible.'); } }) .catch((error) => console.error(error)); const urlInput = document.getElementById('url-input'); const checkButton = document.getElementById('check-button'); const resultText = document.getElementById('result-text'); checkButton.addEventListener('click', () => { const url = urlInput.value; checkWebsitew(url) .then((result) => { if (result) { resultText.innerText = 'Website is accessible.'; } else { resultText.innerText = 'Website is not accessible.'; } }) .catch((error) => console.error(error)); });"},{"path":"/file/x.js","content":"// 验证网址是否可以访问 function isUrlAvailable(url) { var xhr = new XMLHttpRequest(); xhr.open('HEAD', url, false); xhr.send(); return xhr.status == 200; } // 如果网站可以访问,文字背景变绿 function checkUrl() { var url = document.getElementById(\"url\").value; if (isUrlAvailable(url)) { document.getElementById(\"url\").style.backgroundColor = \"green\"; } else { document.getElementById(\"url\").style.backgroundColor = \"red\"; } } // 对列表中的网址进行验证 function checkUrls() { // 获取网址列表 var result = \"\"; for (var i = 0; i < urls.length; i++) { if (isUrlAvailable(urls[i])) { result += urls[i] + \" is available\"; } else { result += urls[i] + \" is not available\"; } } document.getElementById(\"result\").value = result; }"},{"title":"friend","path":"/friend/index.html","content":"申请要求：文章数量大于 10 篇 &amp;&amp; 建站时间大于 6 个月 1234- name: 沐印小站 url: https://undf.top avatar: https://c.undf.top/icon/android-chrome-144x144.png desc: 时间不在于你拥有多少，而在于你如何使用! RSS 葱苓sama思宁HEREEurkon贰猹的小窝杜老师说Vian木木木木木L1nSn0w’s Blog NORSS Android圣奇宝枣"},{"title":"life","path":"/life/index.html","content":"9.1 whj 显示器 1080-&gt;2k-&gt;1080 2022.9 下载地址 new"},{"title":"淘宝购物车生成word","path":"/life/淘宝购物车生成word.html","content":"效果预览 前置条件 你的浏览器安装了油猴插件 准备好我写的小软件 下载地址密码:9if6 使用步骤 打开软件 单击小软件中的油猴脚本按钮，会打开一个浏览器窗口 在弹出的浏览器窗口中单击安装此脚本进行安装，此时会弹出窗口再次点击安装 打开淘宝购物车页面 勾选需要购买的商品 单击浏览器右上角Get Cart Info按钮，数据会自动写入到剪切板 回到小软件，单击获取剪切板内容按钮，即可在程序所在目录生成word文件 大概率会遇到无法获取到图片（淘宝反爬虫）,请手动补充"},{"title":"more","path":"/more/index.html","content":"动态周记 fetch('https://cdn.undf.top/weekly/weekly.md') .then(response => response.text()) .then(data => { var element = document.getElementById(\"myUniqueID\"); data = data.replace(/### (.*$)/gim, '$1'); data = data.replace(/## (.*$)/gim, '$1'); data = data.replace(/# (.*$)/gim, '$1'); // --- data = data.replace(/---/g, ''); // 将 --- 替换为 element.innerHTML = data; });"},{"title":"Movies","path":"/movies/index.html","content":"周一 从红月开始周二 吞噬星空-炼气十万年周三周四 神印王座-近战法师周五 完美世界-恶魔法则周六 炼气十万年-大王饶命周日 仙王"},{"title":"Mine","path":"/self-host/index.html","content":"Self-Host AList Bitwarden Hexo Gitlab"},{"title":"server","path":"/server/index.html","content":""},{"title":"Toys","path":"/toys/index.html","content":"这些年来做的小玩具、小项目，也是一个回忆录。 又拍云数据备份 将又拍云存储的数据下载到本地，并且上传到一个新的存储空间内。 为保证数据完整，禁止删除任意文件。 支持同步 upyun 详情见站内文章 NPM自动化工具 Feature npm 图床自动化 自动更新npm包版本 自动获取最新npm包版本并替换文件中的jsd链接 自动推送图床仓库 只需配置一次 配置文件config.ini可修改 后续有时间再去加功能 自动喷淋系统上位机2021.11 MFC 视频里的程序就是我写的啦 当然还要感谢指导老师的帮助。 还有我画的PCB，很丑，能用就行系列~~~能不能用也不好说~~~。 自动布线，比较杂乱。 折腾服务器2021.11 双11买了三年服务器 这两个项目我只是搭建并没有进行任何修改。 code - server线上编辑器（可以跑程序的） qq机器人玩一下，很开心 学什么？MFC 2021.9写的，解决选择困难症 代码很简单，但很实用。 下载链接 2.0 是在1.0的基础上增加更多内容，但因为后来用不上就没有继续开发 2021.10 吃什么，学什么 这是一个网页，也是为了解决选择困难症 第二个个人网站2021.9也就是现在这个了，换了域名，改了主题。 简单 大方 我的主页2021.8 主页 很显然，不是我原创，是在巨人的肩膀上自己修改的。做了移动端适配，虽然还有bug但问题不大 url - md2021.7 python tkinter 文本 小工具 发在了52 还被列成置顶，也是没想到，非常开心。 52 仓库 快乐星球2021.3-2021.8 搭建的第一个网站&#x2F;博客 5.0 5.0 就是分站的样子啦！ 4.0 开始搞玻璃效果，确实好看。背景也不错。 而且还折腾出来了自动打开侧边栏效果。 挺费劲的 3.0 这个版本应该是比较好看的，而且也很简洁 动效该在的也在，这好像是7月底的版本 还有罗小黑，安装方法见这篇文章 2.0 开始自己折腾加载动画，还有冰球背景 1.02021.3-2021.7 发布的第一个release 那会刚开始折腾，网站还是很简洁的。 平面三轴机械臂视觉识别课程设计 视觉识别部分 平面机械臂模拟 2021.5 Feature： 根据坐标及姿态计算物块位置和合适的抓取角度 通过opencv模块进行视觉识别，计算物块的四个端点及其偏转角度 通过计算对应颜色像素点的数量计算叶片面积 支持摄像头拍摄图片和文件导入 DIY2021.3 自己比较满意的作品 图片没了。。。 大概就是把一个平面无线充电改成立式的，支持横竖放置 原材料： 小米平面无线充电器 一次性筷子 502"},{"title":"闲言碎语","path":"/xy/index.html","content":"留言 window.onload = function () { var xhr = new XMLHttpRequest(); xhr.open(\"get\", \"https://api.undf.top/api/xysy/api/getdata/\", true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) { var data = xhr.responseText; var dataObj = JSON.parse(data); var htmlStr = \"\"; for (var i = 0; i < dataObj.length; i++) { if ( dataObj[i].value.indexOf(\"http\") != -1 && (dataObj[i].value.indexOf(\".png\") != -1 || dataObj[i].value.indexOf(\".jpg\") != -1) ) { htmlStr += \"\" + dataObj[i].time + \"\"; } else { htmlStr += \"\" + dataObj[i].time + \"\" + dataObj[i].value + \"\"; } } document.getElementById(\"comments-list\").innerHTML = htmlStr; } } } hace 20 minutos 加载中请稍后..."},{"title":"闲言碎语","path":"/xy/indexx.html","content":"Click Me /* 设置全局样式 */ * { box-sizing: border-box; margin: 0; padding: 0; } /* 设置居中样式 */ .container { display: flex; justify-content: center; align-items: center; height: 30vh; background-image: url(\"https://img.undf.top/rand/3.png!max\"); background-size: cover; background-position: center; border-radius: 15px; } /* 设置表单样式 */ .form { display: flex; flex-direction: column; align-items: center; background-color: rgba(255, 255, 255, 0.8); width: 40%; padding: 20px; border-radius: 5px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); } /* 设置输入框样式 */ .form input[type=\"textt\"] { padding: 10px; width: 100%; margin-bottom: 10px; border-radius: 5px; border: none; background-color: #fff; box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1); } /* 设置按钮样式 */ .form button { padding: 10px 20px; background-color: #2196f3; color: #fff; border-radius: 5px; border: none; cursor: pointer; font-size: 16px; } /* 设置响应式样式 */ @media only screen and (max-width: 600px) { .form { width: 90%; } } // 监听按钮的点击事件 // 获取输入框的内容 // 根据输入的内容发送请求 // 获取响应 // 显示响 // 1. 监听按钮的点击事件 var button = document.querySelector('button'); button.addEventListener('click', function () { // 2. 获取输入框的内容 var input = document.querySelector('input'); var name = input.value; // 3. 根据输入的内容发送请求 var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://api.undf.top/api/xysy/api/postdata/?v=' + name); xhr.send(); // 4. 获取响应 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status === 200) { // 5. 显示响应 var response = xhr.responseText; alert(response); //跳转到首页 window.location.href = \"https://c.undf.top/xy/\"; console.log(response); } } } });"}]