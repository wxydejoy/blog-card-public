<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="shortcut icon" href="/icon/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/icon/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/icon/favicon-32x32.png"><link rel="apple-touch-icon" sizes="180x180" href="/icon/apple-touch-icon-180x180.png"><link rel="mask-icon" href="/icon/apple-touch-icon-180x180.png"><title>Python_study | 沐印小站</title><meta name="keywords" content="沐印"><meta name="description" content="虽然之前学过不少 python 的知识，但是还是没有系统的学习过一些基础知识，补一下。参考书 Python 基础教程(第 3 版)_百度百科 丑话说在前面只记一下易错点和之前不会的点吧，个人向。 大量 复制粘贴 不喜勿看 快速上手：基础知识数和表达式1234567# 取余10 % 3# 整除10 &#x2F;&#x2F; 3# 幂运算2 ** 3  12345678&gt;&gt;&gt; 10 &#x2F;&#x2F; 33&gt;&amp;"><meta property="og:type" content="article"><meta property="og:title" content="Python_study"><meta property="og:url" content="https://c.undf.top/posts/3ahvaci/index.html"><meta property="og:site_name" content="沐印小站"><meta property="og:description" content="虽然之前学过不少 python 的知识，但是还是没有系统的学习过一些基础知识，补一下。参考书 Python 基础教程(第 3 版)_百度百科 丑话说在前面只记一下易错点和之前不会的点吧，个人向。 大量 复制粘贴 不喜勿看 快速上手：基础知识数和表达式1234567# 取余10 % 3# 整除10 &#x2F;&#x2F; 3# 幂运算2 ** 3  12345678&gt;&gt;&gt; 10 &#x2F;&#x2F; 33&gt;&amp;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://c.undf.top/images/others/Python_study.md/2022-08-01-09-56-59.png"><meta property="article:published_time" content="2022-08-01T01:56:24.000Z"><meta property="article:modified_time" content="2022-08-14T05:31:01.191Z"><meta property="article:author" content="wxy"><meta property="article:tag" content="沐印"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://c.undf.top/images/others/Python_study.md/2022-08-01-09-56-59.png"><link rel="stylesheet" href="/css/style/main.css"><link rel="stylesheet" id="hl-default-theme" href="/css/highlight/atom-one-dark.css" media="none" onload='this.media="all"'><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="沐印小站" type="application/atom+xml"></head><body><div id="app"><header class="header"><div class="header__left"> <a href="/" class="button"><span class="logo__text">Hi</span></a></div><div class="header__right"><div class="navbar__menus"> <a href="/" class="navbar-menu button">首页</a> <a href="/tags/" class="navbar-menu button">标签</a> <a href="/search/" class="navbar-menu button">搜索</a> <a href="/movies/" class="navbar-menu button">影单</a> <a href="/friends/" class="navbar-menu button">友链</a> <a href="/toys/" class="navbar-menu button">玩具</a></div> <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="24" height="24" fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314 4.8h13.372c.41 0 .743-.333.743-.743 0-.41-.333-.743-.743-.743H3.314c-.41 0-.743.333-.743.743C2.571 4.467 2.904 4.8 3.314 4.8zM16.686 15.2H3.314c-.41 0-.743.333-.743.743s.333.743.743.743h13.372c.41 0 .743-.333.743-.743S17.096 15.2 16.686 15.2zM16.686 9.257H3.314c-.41 0-.743.333-.743.743s.333.743.743.743h13.372c.41 0 .743-.333.743-.743S17.096 9.257 16.686 9.257z"></path></svg></a><div class="dropdown-menus" id="dropdown-menus"> <a href="/" class="dropdown-menu button">首页</a> <a href="/tags/" class="dropdown-menu button">标签</a> <a href="/search/" class="dropdown-menu button">搜索</a> <a href="/movies/" class="dropdown-menu button">影单</a> <a href="/friends/" class="dropdown-menu button">友链</a> <a href="/toys/" class="dropdown-menu button">玩具</a></div></div></header><main class="main"><aside class="post-side"><div class="post-side__date"> <a href="/archives/2022/08/" class="post-meta__date button">　文章写于2022-08-01</a></div><div class="post-side__toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%91%E8%AF%9D%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">丑话说在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">快速上手：基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">数和表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-number">2.2.</span> <span class="toc-text">获取用户输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmath-%E5%92%8C%E5%A4%8D%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">cmath 和复数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">保存并执行程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">列表和元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%AD%A5%E9%95%BF"><span class="toc-number">3.1.</span> <span class="toc-text">更大的步长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%9A-Python-%E7%9A%84%E4%B8%BB%E5%8A%9B"><span class="toc-number">3.3.</span> <span class="toc-text">列表： Python 的主力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">列表方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%EF%BC%9A%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%BA%8F%E5%88%97-%E5%85%83%E7%BB%84"><span class="toc-number">3.5.</span> <span class="toc-text">元组：不可修改的序列 (元组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F-%E7%B2%BE%E7%AE%80%E7%89%88"><span class="toc-number">4.1.</span> <span class="toc-text">设置字符串的格式 精简版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F-%E5%AE%8C%E6%95%B4%E7%89%88"><span class="toc-number">4.2.</span> <span class="toc-text">设置字符串的格式 完整版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">字符串方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">4.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-%E5%BD%93%E7%B4%A2%E5%BC%95%E8%A1%8C%E4%B8%8D%E9%80%9A%E6%97%B6"><span class="toc-number">5.</span> <span class="toc-text">字典 当索引行不通时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">字典方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">5.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E3%80%81%E5%BE%AA%E7%8E%AF%E5%8F%8A%E5%85%B6%E4%BB%96%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">条件、循环及其他语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E9%AD%94%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">赋值魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%BA%BA%E8%A1%8C"><span class="toc-number">6.3.</span> <span class="toc-text">三人行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">7.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E6%8A%BD%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">再谈抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%AD%94%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">对象魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">创建自定义类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">8.3.</span> <span class="toc-text">深入探讨继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="toc-number">8.4.</span> <span class="toc-text">关于面向对象设计的一些思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">8.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82-%E5%B8%B8"><span class="toc-number">9.</span> <span class="toc-text">异 常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.1.</span> <span class="toc-text">异常是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E4%BA%8B%E6%83%85%E6%B2%BF%E4%BD%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%A8%E9%81%93%E5%87%BA%E9%94%99"><span class="toc-number">9.2.</span> <span class="toc-text">让事情沿你指定的轨道出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">异常和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B9%8B%E7%A6%85-%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.4.</span> <span class="toc-text">异常之禅(异常与循环)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%82%A3%E4%B9%88%E5%BC%82%E5%B8%B8%E7%9A%84%E6%83%85%E5%86%B5-%E8%AD%A6%E5%91%8A"><span class="toc-number">9.5.</span> <span class="toc-text">不那么异常的情况(警告)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">9.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">魔法方法、特性和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INIT"><span class="toc-number">10.1.</span> <span class="toc-text">INIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">10.2.</span> <span class="toc-text">元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">其他魔法方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-1"><span class="toc-number">10.4.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">10.6.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">10.7.</span> <span class="toc-text">八皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-number">10.8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%91%8A"><span class="toc-number">10.9.</span> <span class="toc-text">预告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">开箱即用</span></a></li></ol></div></aside> <a class="btn-toc button" id="btn-toc" tabindex="0"><svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg"><path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path></svg></a><div class="toc-menus" id="toc-menus"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%91%E8%AF%9D%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">丑话说在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">快速上手：基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">数和表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-number">2.2.</span> <span class="toc-text">获取用户输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmath-%E5%92%8C%E5%A4%8D%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">cmath 和复数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">保存并执行程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">列表和元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%AD%A5%E9%95%BF"><span class="toc-number">3.1.</span> <span class="toc-text">更大的步长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%9A-Python-%E7%9A%84%E4%B8%BB%E5%8A%9B"><span class="toc-number">3.3.</span> <span class="toc-text">列表： Python 的主力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">列表方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%EF%BC%9A%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%BA%8F%E5%88%97-%E5%85%83%E7%BB%84"><span class="toc-number">3.5.</span> <span class="toc-text">元组：不可修改的序列 (元组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F-%E7%B2%BE%E7%AE%80%E7%89%88"><span class="toc-number">4.1.</span> <span class="toc-text">设置字符串的格式 精简版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F-%E5%AE%8C%E6%95%B4%E7%89%88"><span class="toc-number">4.2.</span> <span class="toc-text">设置字符串的格式 完整版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">字符串方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">4.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-%E5%BD%93%E7%B4%A2%E5%BC%95%E8%A1%8C%E4%B8%8D%E9%80%9A%E6%97%B6"><span class="toc-number">5.</span> <span class="toc-text">字典 当索引行不通时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">字典方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">5.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E3%80%81%E5%BE%AA%E7%8E%AF%E5%8F%8A%E5%85%B6%E4%BB%96%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">条件、循环及其他语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E9%AD%94%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">赋值魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%BA%BA%E8%A1%8C"><span class="toc-number">6.3.</span> <span class="toc-text">三人行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">7.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E6%8A%BD%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">再谈抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%AD%94%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">对象魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">创建自定义类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">8.3.</span> <span class="toc-text">深入探讨继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="toc-number">8.4.</span> <span class="toc-text">关于面向对象设计的一些思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">8.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82-%E5%B8%B8"><span class="toc-number">9.</span> <span class="toc-text">异 常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.1.</span> <span class="toc-text">异常是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E4%BA%8B%E6%83%85%E6%B2%BF%E4%BD%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%A8%E9%81%93%E5%87%BA%E9%94%99"><span class="toc-number">9.2.</span> <span class="toc-text">让事情沿你指定的轨道出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">异常和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B9%8B%E7%A6%85-%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.4.</span> <span class="toc-text">异常之禅(异常与循环)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%82%A3%E4%B9%88%E5%BC%82%E5%B8%B8%E7%9A%84%E6%83%85%E5%86%B5-%E8%AD%A6%E5%91%8A"><span class="toc-number">9.5.</span> <span class="toc-text">不那么异常的情况(警告)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">9.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">魔法方法、特性和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INIT"><span class="toc-number">10.1.</span> <span class="toc-text">INIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">10.2.</span> <span class="toc-text">元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">其他魔法方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-1"><span class="toc-number">10.4.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">10.6.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">10.7.</span> <span class="toc-text">八皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-number">10.8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%91%8A"><span class="toc-number">10.9.</span> <span class="toc-text">预告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">开箱即用</span></a></li></ol></div><article class="post post__with-toc content-card"><div class="post__header"><a href="/posts/3ahvaci/"><div class="post-thumbnail" style="background-image:url(/images/others/Python_study.md/2022-08-01-09-56-59.png)"></div></a><div class="post__expire" id="post-expired-notify"><p> 本文最后更新于 &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; 天前，文中部分描述可能已经过时。</p></div><script>
        (() => {
            var update = Date.parse("2022-08-14"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script></div><div class="post__content"><p>虽然之前学过不少 python 的知识，但是还是没有系统的学习过一些基础知识，补一下。<br>参考书 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89/49977580?fr=aladdin">Python 基础教程(第 3 版)_百度百科</a></p><h2 id="丑话说在前面"><a href="#丑话说在前面" class="headerlink" title="丑话说在前面"></a>丑话说在前面</h2><p>只记一下易错点和之前不会的点吧，个人向。</p><p>大量 复制粘贴 不喜勿看</p><h2 id="快速上手：基础知识"><a href="#快速上手：基础知识" class="headerlink" title="快速上手：基础知识"></a>快速上手：基础知识</h2><h3 id="数和表达式"><a href="#数和表达式" class="headerlink" title="数和表达式"></a>数和表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取余</span></span><br><span class="line"><span class="number">10</span> % <span class="number">3</span></span><br><span class="line"><span class="comment"># 整除</span></span><br><span class="line"><span class="number">10</span> // <span class="number">3</span></span><br><span class="line"><span class="comment"># 幂运算</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // -<span class="number">3</span></span><br><span class="line">-<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">10</span> // <span class="number">3</span></span><br><span class="line">-<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">10</span> // -<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>对于整除运算，需要明白的一个重点是它向下圆整结果。因此在结果为负数的情况下，圆整后将离 0 更远。这意味着对于-10 &#x2F;&#x2F; 3， 将向下圆整到-4，而不是向上圆整到-3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">3</span>     <span class="comment"># pow(2, 3)</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">3</span> ** <span class="number">2</span></span><br><span class="line">-<span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(-<span class="number">3</span>) ** <span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，乘方运算符的优先级比求负(单目减)高，因此<code>-3**2</code>等价于<code>-(3**2)</code>。如果你要计<br>算的是<code>(-3)**2</code>，必须明确指出。</p><p>十六进制、八进制和二进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10</span> <span class="comment"># 十六进制</span></span><br><span class="line"><span class="number">0o10</span> <span class="comment"># 八进制</span></span><br><span class="line"><span class="number">0b10</span> <span class="comment"># 二进制</span></span><br></pre></td></tr></table></figure><p>这些表示法都以 0 打头。</p><h3 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">input</span>(<span class="string">&quot;The meaning of life: &quot;</span>)</span><br><span class="line">The meaning of life: <span class="number">42</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span></span><br></pre></td></tr></table></figure><p>这里在交互式解释器中执行了第一行(input( ))，它打印字符串”The meaning of life:”，<br>提示用户输入相应的信息。我输入 42 并按回车。这个数被 input(以文本或字符串的方式)返回， 并在最后一行被自动打印出来。</p><h3 id="cmath-和复数"><a href="#cmath-和复数" class="headerlink" title="cmath 和复数"></a>cmath 和复数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">3j</span>) * (<span class="number">9</span> + <span class="number">4j</span>)</span><br><span class="line">(-<span class="number">3</span> + <span class="number">31j</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="保存并执行程序"><a href="#保存并执行程序" class="headerlink" title="保存并执行程序"></a>保存并执行程序</h3><p>在有些情况下，你希望能够像执行其他程序(如 Web 浏览器或文本编辑器)一样执行 Python 脚本，而无需显式地使用 Python 解释器。</p><p>UNIX 提供了实现这种目标的标准方式：让脚本的第一 行以字符序列#!(称为 pound bang 或 shebang)开始，并在它后面指定用于对脚本进行解释的程序 (这里是 Python)的绝对路径。</p><p>即便你对这一点不太明白，只需将下面的代码作为脚本的第一行， 就可在 UNIX 中轻松运行脚本：<br><code>#!/usr/bin/env python</code><br>不管 Python 库位于什么地方，这都将让你能够像运行普通程序一样运行脚本。<br>如果你安装了多个版本的 Python，可用更具体的可执行文件名(如 python3)替换 python。<br>要像普通程序一样运行脚本，还必须将其变成可执行的：<br><code>$ chmod a+x hello.py</code><br>现在，可以像下面这样来运行它(假定当前目录包含在执行路径中)：<br><code>$ hello.py</code><br>如果这不管用，请尝试使用<code>./hello.py</code>，这在当前目录(.)未包含在执行路径中时也管用(负责的系统管理员会告诉你执行路径是什么)。</p><p>如果你愿意，可对文件进行重命名并删除扩展名<code>.py</code>，使其看起来更像普通程序。</p><p>如果双击会如何呢 在 Windows 中，扩展名<code>.py</code>是让脚本像普通程序一样的关键所在。请尝试双击前一节保存的文件<code>hello.py</code>。如果正确地安装了<code>Python</code>，这将打开一个 DOS 窗口，其中包含提示信息 What is your name?。然而，这样运行程序存在一个问题：输入名字后，程序窗口将立即关闭，你根本来不及 看清结果。这是因为程序结束后窗口将立即关闭。尝试修改脚本，在末尾添加如下代码行： <code>input(&quot;Press &lt;enter&gt;&quot;)</code> 现在运行这个程序并输入名字后，DOS 窗口将包含如下内容：</p><p><code>What is your name? Gumby Hello, Gumby! Press &lt;enter&gt;</code></p><p>等你按回车键后，窗口将立即关闭，因为程序结束了。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="string">&#x27;Hello, world!&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，有一点可能让你颇感意外：Python 在打印字符串时，用单引号将其括起，而 我们使用的是双引号。这有什么差别吗？其实没有任何差别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Let&#x27;s go!&quot;</span></span><br><span class="line"><span class="string">&quot;Let&#x27;s go!&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Hello, world!&quot; she said&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Hello, world!&quot; she said&#x27;</span></span><br></pre></td></tr></table></figure><p>第二个字符串包含双引号，因此必须使用单引号将整个字符串括起，原因和前面一样。实际上，并非必须这样做(这样做只是出于方便考虑)。可使用反斜杠()对引号进行转义，如 下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Let\&#x27;s go!&#x27;</span></span><br><span class="line"><span class="string">&quot;Let&#x27;s go!&quot;</span></span><br></pre></td></tr></table></figure><p>Python 打印所有的字符串时，都用引号将其括起。你可能通过前面的示例发现了这一点。</p><p>因为 Python 打印值时，保留其在代码中的样子，而不是你希望用户看到的样子。但如果你使用 print，结果将不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello,\nworld!&quot;</span></span><br><span class="line"><span class="string">&#x27;Hello,\nworld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello,\nworld!&quot;</span>)</span><br><span class="line">Hello,</span><br><span class="line">world!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过两种不同的机制将值转换成了字符串。你可通过使用函数 str 和 repr① 直接使用这两种机制。使用 str 能以合理的方式将值转换为用户能够看懂的字符串。例如，尽可能将特殊字符编码 转换为相应的字符。然而，使用 repr 时，通常会获得值的合法 Python 表达式表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="string">&quot;Hello,\nworld!&quot;</span>))</span><br><span class="line"><span class="string">&#x27;Hello,\nworld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="string">&quot;Hello,\nworld!&quot;</span>))</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ol><li>长字符串</li></ol><p>要表示很长的字符串(跨越多行的字符串)，可使用三引号(而不是普通引号)。<br>print(‘’’This is a very long string. It continues here.<br>And it’s not over yet.<br>“Hello, world!” Still here.’’’)</p><p>还可使用三个双引号，如”””like this”””。</p><p>请注意，这让解释器能够识别表示字符串开始 和结束位置的引号，因此字符串本身可包含单引号和双引号，无需使用反斜杠进行转义</p><p>三个引号也是注释的一种写法。</p><ol start="2"><li>原始字符串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">&#x27;C:\nowhere&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path</span><br><span class="line"><span class="string">&#x27;C:\nowhere&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这好像没问题，但如果将其打印出来，就会出现问题。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(path)</span><br><span class="line">C:</span><br><span class="line">owhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串用前缀r表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\nowhere&#x27;</span>)</span><br><span class="line">C:\nowhere</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外，原始字符串不能以单个反斜杠结尾。换而言之，原始字符串的最后一个字符不能是反斜杠，除非你对其进行转义(但进行转义时，用于转义的反斜杠也将是字符串的一部分)。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\Program Files\foo\bar&#x27;</span> <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">C:\Program Files\foo\bar\</span><br></pre></td></tr></table></figure><ol start="3"><li>Unicode、bytes 和 bytearray</li></ol><p>每个 Unicode 字符都用一个码点(code point)表示，而码点是 Unicode 标准给每个字符指定的数字。</p><blockquote><blockquote><blockquote><p>“\u00C6”<br>‘Æ’<br>“\U0001F60A”<br>‘☺ ‘<br>“This is a cat: \N{Cat}”<br>‘This is a cat: ‘</p></blockquote></blockquote></blockquote><div class="spoiler collapsed"><div class="spoiler-title"> 篇幅较长 点击展开</div><div class="spoiler-content"><p>Unicode 的理念很简单，却带来了一些挑战，其中之一是编码问题。在内存和磁盘中，所有对象都是以二进制数字(0 和 1)表示的(这些数字每 8 个为一组，即 1 字节)，字符串也不例外。 在诸如 C 等编程语言中，这些字节完全暴露，而字符串不过是字节序列而已。为与 C 语言互操作 以及将文本写入文件或通过网络套接字发送出去，Python 提供了两种类似的类型：不可变的 bytes 和可变的 bytearray。如果需要，可直接创建 bytes 对象(而不是字符串)，方法是使用前缀 b：</p><p><code>&gt;&gt;&gt; b&#39;Hello, world!&#39; b&#39;Hello, world!&#39;</code></p><p>然而，1 字节只能表示 256 个不同的值，离 Unicode 标准的要求差很远。Python bytes 字面量只支持 ASCII 标准中的 128 个字符，而余下的 128 个值必须用转义序列表示，如\xf0 表示十六进制值 0xf0(即 240)。 唯一的差别好像在于可用的字母表规模，但实际上并非完全如此。乍一看，好像 ASCII 和 Unicode 定义的都是非负整数和字符之间的映射，但存在细微的差别：Unicode 码点是使用整数定义的，而 ASCII 字符是使用对应的数及其二进制编码定义的。</p><p>这一点好像无关紧要，原因之一是 整数 0 ～ 255 和 8 位二进制数之间的映射是固定的，几乎没有任何机动空间。问题是超过 1 字节后， 情况就不那么简单了：直接将每个码点表示为相应的二进制数可能不再可行。这是因为不仅存在字节顺序的问题(即便对整数值进行编码，也会遇到这样的问题)，而且还可能浪费空间：如果对于每个码点都使用相同数量的字节进行编码，就必须考虑到文本可能包含安那托利亚象形文字 或皇家亚兰字母。有一种 Unicode 编码标准是基于这种考虑的，它就是 UTF-32(32 位统一编码转换格式，Unicode Transformation Format 32 bits)，但如果你主要处理的是使用互联网上常见语言书写的文本，那么使用这种编码标准将很浪费空间。</p><p>然而，有一种非常巧妙的替代方式：不使用全部 32 位，而是使用变长编码，即对于不同的字符，使用不同数量的字节进行编码。这种编码方式主要出自计算机先锋 Kenneth Thompson 之手。 通过使用这种编码，可节省占用的空间，就像摩尔斯码使用较少的点和短线表示常见的字母，从 而减少工作量一样 ①。</p><p>具体地说，进行单字节编码时，依然使用 ASCII 编码，以便与较旧的系统兼容；但对于不在这个范围内的字符，使用多个字节(最多为 6 个)进行编码。</p><p>下面来使用 ASCII、 UTF-8 和 UTF-32 编码将字符串转换为 bytes。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello, world!&quot;</span>.encode(<span class="string">&quot;ASCII&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;Hello, world!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello, world!&quot;</span>.encode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;Hello, world!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello, world!&quot;</span>.encode(<span class="string">&quot;UTF-32&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xff\xfe\x00\x00H\x00\x00\x00e\x00\x00\x00l\x00\x00\x00l\x00\x00\x00o\x00\x00\x00,\x00\ x00\x00 \x00\x00\x00w\x00\x00\x00o\x00\x00\x00r\x00\x00\x00l\x00\x00\x00d\x00\x00\x00!\x00\ x00\x00&#x27;</span></span><br></pre></td></tr></table></figure><p>从中可知，使用前两种编码的结果相同，但使用最后一种编码的结果长得多。再来看一个 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&quot;How long is this?&quot;</span>.encode(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&quot;How long is this?&quot;</span>.encode(<span class="string">&quot;UTF-32&quot;</span>))</span><br><span class="line"><span class="number">72</span></span><br></pre></td></tr></table></figure><p>只要字符串包含较怪异的字符，ASCII 和 UTF-8 之间的差别便显现出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hællå, wørld!&quot;</span>.encode(<span class="string">&quot;ASCII&quot;</span>) Traceback (most recent call last):    </span><br><span class="line"></span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode character &#x27;</span>\xe6<span class="string">&#x27; in position 1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure><p>斯堪的纳维亚字母没有对应的 ASCII 编码。如果必须使用 ASCII 编码(这样的情况肯定会遇到)，可向 encode 提供另一个实参，告诉它如何处理错误。这个参数默认为 strict，但可将其指定为其他值，以忽略或替换不在 ASCII 表中的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hællå, wørld!&quot;</span>.encode(<span class="string">&quot;ASCII&quot;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;Hll, wrld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hællå, wørld!&quot;</span>.encode(<span class="string">&quot;ASCII&quot;</span>, <span class="string">&quot;replace&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;H?ll?, w?rld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hællå, wørld!&quot;</span>.encode(<span class="string">&quot;ASCII&quot;</span>, <span class="string">&quot;backslashreplace&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;H\\xe6ll\\xe5, w\\xf8rld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hællå, wørld!&quot;</span>.encode(<span class="string">&quot;ASCII&quot;</span>, <span class="string">&quot;xmlcharrefreplace&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;H&amp;#230;ll&amp;#229;, w&amp;#248;rld!&#x27;</span></span><br></pre></td></tr></table></figure><p>几乎在所有情况下，都最好使用 UTF-8。事实上，它也是默认使用的编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hællå, wørld!&quot;</span>.encode()</span><br><span class="line"><span class="string">b&#x27;H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!&#x27;</span></span><br></pre></td></tr></table></figure><p>这相比于 Hello, world!，编码结果要长些；但使用 UTF-32 编码时，结果一样长。 可将字符串编码为 bytes，同样也可将 bytes 解码为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!&#x27;</span>.decode()</span><br><span class="line"><span class="string">&#x27;Hællå, wørld!&#x27;</span></span><br></pre></td></tr></table></figure><p>与前面一样，默认编码也是 UTF-8。你可指定其他编码，但如果指定的编码不正确，将出现错误消息或得到一堆乱码。bytes 对象本身并不知道使用的是哪种编码，因此你必须负责跟踪这 一点。可不使用方法 encode 和 decode，而直接创建 bytes 和 str(即字符串)对象，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(<span class="string">&quot;Hællå, wørld!&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="string">b&#x27;H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">&#x27;Hællå, wørld!&#x27;</span></span><br></pre></td></tr></table></figure><p>这种方法更通用一些，在你不知道类似于字符串或 bytes 的对象属于哪个类时，使用这种方法也更管用。</p><p>一个通用规则是，不要做过于严格的假设。 编码和解码的最重要用途之一是，将文本存储到磁盘文件中。然而，Python 提供的文件读写机制通常会替你完成这方面的工作！</p><p>只要文件使用的是 UTF-8 编码，就无需操心编码和解码的问 题。</p><p>但如果原本正常的文本变成了乱码，就说明文件使用的可能是其他编码。</p><p>在这种情况下，对 导致这种问题的原因有所了解将大有裨益。</p><p>如果你想更详细地了解 Python 中的 Unicode，请参阅 在线文档中有关该主题的 HOWTO 部分 ①。</p><p>注意 源代码也将被编码，且默认使用的也是 UTF-8 编码。如果你想使用其他编码(例如，如果 你使用的文本编辑器使用其他编码来存储源代码)，可使用特殊的注释来指定。 # -*- coding: encoding name -*请将其中的 encoding name 替换为你要使用的编码(大小写都行)，如 utf-8 或 latin-1。<br>最后，Python 还提供了 bytearray，它是 bytes 的可变版。从某种意义上说，它就像是可修改 的字符串——常规字符串是不能修改的。然而，bytearray 其实是为在幕后使用而设计的，因此 作为类字符串使用时对用户并不友好。例如，要替换其中的字符，必须将其指定为 0 ～ 255 的值。 因此，要插入字符，必须使用 ord 获取其序数值(ordinal value)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">bytearray</span>(<span class="string">b&quot;Hello!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>] = <span class="built_in">ord</span>(<span class="string">b&quot;u&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Hullo!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章介绍的内容很多，先来看看你都学到了什么，再接着往下讲。</p><ul><li>算法：算法犹如菜谱，告诉你如何完成特定的任务。从本质上说，编写计算机程序就是 使用计算机能够理解的语言(如 Python)描述一种算法。这种对机器友好的描述被称为程序，主要由表达式和语句组成。</li><li>表达式：表达式为程序的一部分，结果为一个值。例如，2 + 2 就是一个表达式，结果为 4。简单表达式是使用运算符(如+或%)和函数(如 pow)将字面值(如 2 或”Hello”)组 合起来得到的。通过组合简单的表达式，可创建复杂的表达式，如(2 + 2) *(3 - 1)。表 达式还可能包含变量。</li><li>变量：变量是表示值的名称。通过赋值，可将新值赋给变量，如 x &#x3D; 2。赋值是一种语句。</li><li><ul><li>语句：语句是让计算机执行特定操作的指示。这种操作可能是修改变量(通过赋值)、将 信息打印到屏幕上(如 print(“Hello, world!”))、导入模块或执行众多其他任务。</li></ul></li><li>函数：Python 函数类似于数学函数，它们可能接受参数，并返回结果(在第 6 章学习编写 自定义函数时，你将发现函数实际上可以在返回前做很多事情)。</li><li>模块：模块是扩展，可通过导入它们来扩展 Python 的功能。例如，模块 math 包含多个很有 用的函数。</li><li>程序：你通过练习学习了如何编写、保存和运行 Python 程序。 - 字符串：字符串非常简单。它们其实就是一段文本，其中的字符是用 Unicode 码点表示的。 然而，对于字符串，需要学习的知识有很多。本章介绍了很多表示字符串的方式，第 3 章 将介绍众多字符串用法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">abs</span>(number)                             <span class="comment"># 返回指定数的绝对值</span></span><br><span class="line"><span class="built_in">bytes</span>(string, encoding[, errors])       <span class="comment"># 对指定的字符串进行编码，并以指定的方式处理错误</span></span><br><span class="line">cmath.sqrt(number)                      <span class="comment"># 返回平方根；可用于负数</span></span><br><span class="line"><span class="built_in">float</span>(<span class="built_in">object</span>)                           <span class="comment"># 将字符串或数字转换为浮点数</span></span><br><span class="line"><span class="built_in">help</span>([<span class="built_in">object</span>])                          <span class="comment"># 提供交互式帮助</span></span><br><span class="line"><span class="built_in">input</span>(prompt)                           <span class="comment"># 以字符串的方式获取用户输入</span></span><br><span class="line"><span class="built_in">int</span>(<span class="built_in">object</span>)                             <span class="comment"># 将字符串或数转换为整数</span></span><br><span class="line">math.ceil(number)                       <span class="comment"># 以浮点数的方式返回向上圆整的结果</span></span><br><span class="line">math.floor(number)                      <span class="comment"># 以浮点数的方式返回向下圆整的结果</span></span><br><span class="line">math.sqrt(number)                       <span class="comment"># 返回平方根；不能用于负数</span></span><br><span class="line"><span class="built_in">pow</span>(x, y[, z])                          <span class="comment"># 返回x的y次方对z求模的结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>,    )                      <span class="comment"># 将提供的实参打印出来，并用空格分隔</span></span><br><span class="line"><span class="built_in">repr</span>(<span class="built_in">object</span>)                            <span class="comment"># 返回一个对象的字符串表示形式</span></span><br><span class="line"><span class="built_in">round</span>(number[, ndigits])                <span class="comment"># 四舍五入为指定的精度，正好为5时舍入到偶数</span></span><br><span class="line"><span class="built_in">str</span>(<span class="built_in">object</span>)                             <span class="comment"># 将指定的值转换为字符串。用于转换bytes时，可指定编码和错误处理方式</span></span><br></pre></td></tr></table></figure><h2 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h2><p>索引 <code>tag[0]</code></p><p>切片 <code>tag[32:-4]</code></p><h3 id="更大的步长"><a href="#更大的步长" class="headerlink" title="更大的步长"></a>更大的步长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在这个示例中，指定了另一个数。你可能猜到了，这显式地指定了步长。如果指定的步长大于<span class="number">1</span>，将跳过一些元素。例如，步长为<span class="number">2</span>时，将从起点和终点之间每隔一个元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">10</span>:<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">提取一个元素显式地指定步长时，也可使用前述简写。例如，要从序列中每隔<span class="number">3</span>个元素提取<span class="number">1</span>个，只需提供步长<span class="number">4</span>即可</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">numbers[<span class="number">3</span>:<span class="number">6</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">当然，步长不能为<span class="number">0</span>，否则无法向前移动，但可以为负数，即从右向左提取元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>将序列与数 x 相乘时，将重复这个序列 x 次来创建一个新序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;python&#x27;</span> * <span class="number">5</span></span><br><span class="line"><span class="string">&#x27;pythonpythonpythonpythonpython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">42</span>] * <span class="number">10</span></span><br><span class="line">[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure><p>None、空列表和初始化</p><p>空列表是使用不包含任何内容的两个方括号表示的。如果要创建一个可包含 10 个元素的列表，但没有任何有用的内容，可像前面那样使用<code>[42]*10</code>。但更准确的做法是使用<code>[0]*10</code>，这将创建一个包含 10 个零的列表。然而，在有些情况下，你可能想使用表示“什么都没有”的值，如表示还没有在列表中添加任何内容。在这种情况下，可使用 None。在 Python 中， None 表示什么都没有。因此，要将列表的长度初始化为 10，可像下面这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sequence = [<span class="literal">None</span>] * <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sequence</span><br><span class="line">[<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure><h3 id="列表：-Python-的主力"><a href="#列表：-Python-的主力" class="headerlink" title="列表： Python 的主力"></a>列表： Python 的主力</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要将字符列表(如前述代码中的字符列表)转换为字符串，可使用下面的表达式：<br><code>&#39;&#39;.join(somelist)</code></p><ol><li>给切片赋值<br>切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="built_in">list</span>(<span class="string">&#x27;Perl&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line">[<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">2</span>:] = <span class="built_in">list</span>(<span class="string">&#x27;ar&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line">[<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]</span><br></pre></td></tr></table></figure><p>从上述代码可知，可同时给多个元素赋值。你可能认为，这有什么大不了的，分别给每个元<br>素赋值不是一样的吗？确实如此，但通过使用切片赋值，可将切片替换为长度与其不同的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="built_in">list</span>(<span class="string">&#x27;Perl&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">1</span>:] = <span class="built_in">list</span>(<span class="string">&#x27;ython&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line">[<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br></pre></td></tr></table></figure><p>使用切片赋值还可在不替换原有元素的情况下插入新元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>在这里，我“替换”了一个空切片，相当于插入了一个序列。你可采取相反的措施来删除切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>你可能猜到了，上述代码与 del numbers[1:4]等效。现在，你可自己尝试执行步长**不为 1(乃至为负)**的切片赋值了。</p><h3 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">append()</span><br><span class="line">clear()</span><br><span class="line">copy()</span><br><span class="line">count()</span><br><span class="line">extend()</span><br><span class="line">index()</span><br><span class="line">insert()</span><br><span class="line">pop()  <span class="comment">#从列尾删除一个元素，并返回该元素的值</span></span><br><span class="line">remove()  <span class="comment">#删除第一个值</span></span><br><span class="line">reverse()  <span class="comment">#反转列表中的元素</span></span><br><span class="line">sort()  <span class="comment">#排序列表中的元素 就地排序意味着对原来的列表进行修改，而不是创建一个新的列表。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>要让 a 和 b 指向不同的列表，就必须将 b 关联到 a 的副本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="Extend"><a href="#Extend" class="headerlink" title="Extend()"></a>Extend()</h4><p>方法 extend 让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提<br>供给方法 extend。换而言之，你可使用一个列表来扩展另一个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.extend(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>这可能看起来类似于拼接，但存在一个重要差别，那就是将修改被扩展的序列(这里是 a)。<br>在常规拼接中，情况是返回一个全新的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="sort-高级排序"><a href="#sort-高级排序" class="headerlink" title="sort() 高级排序"></a>sort() 高级排序</h4><p>方法 sort 接受两个可选参数： key 和 reverse。</p><p>方法 sort 接受两个可选参数： key 和 reverse。这两个参数通常是按名称指定的，称为关键字<br>参数，将在第 6 章详细讨论。参数 key 类似于参数 cmp：你将其设置为一个用于排序的函数。然而，<br>不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个<br>键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，可将参数 key 设置为函数 len。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="string">&#x27;aardvark&#x27;</span>, <span class="string">&#x27;abalone&#x27;</span>, <span class="string">&#x27;acme&#x27;</span>, <span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;aerate&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.sort(key=<span class="built_in">len</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;acme&#x27;</span>, <span class="string">&#x27;aerate&#x27;</span>, <span class="string">&#x27;abalone&#x27;</span>, <span class="string">&#x27;aardvark&#x27;</span>]</span><br></pre></td></tr></table></figure><p>对于另一个关键字参数 reverse，只需将其指定为一个真值( True 或 False，将在第 5 章详细介绍)，以指出是否要按相反的顺序对列表进行排序。</p><h3 id="元组：不可修改的序列-元组"><a href="#元组：不可修改的序列-元组" class="headerlink" title="元组：不可修改的序列 (元组)"></a>元组：不可修改的序列 (元组)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>下面来回顾一下本章介绍的一些最重要的概念。</p><ul><li><p>序列：序列是一种数据结构，其中的元素带编号(编号从 0 开始)。列表、字符串和元组<br>都属于序列，其中列表是可变的(你可修改其内容)，而元组和字符串是不可变的(一旦<br>创建，内容就是固定的)。要访问序列的一部分，可使用切片操作：提供两个指定切片起<br>始和结束位置的索引。要修改列表，可给其元素赋值，也可使用赋值语句给切片赋值。</p></li><li><p>成员资格：要确定特定的值是否包含在序列(或其他容器)中，可使用运算符 in。将运<br>算符 in 用于字符串时情况比较特殊——这样可查找子串。</p></li><li><p>方法：一些内置类型(如列表和字符串，但不包括元组)提供了很多有用的方法。方法<br>有点像函数，只是与特定的值相关联。方法是面向对象编程的一个重要方面，这将在第 7<br>章介绍。</p></li></ul><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="设置字符串的格式-精简版"><a href="#设置字符串的格式-精简版" class="headerlink" title="设置字符串的格式 精简版"></a>设置字符串的格式 精简版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from c</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span> = <span class="string">&quot;Hello, s. s enough for ya?&quot;</span> % %</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = (<span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;Hot&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span> values %</span><br><span class="line"><span class="string">&#x27;Hello, world. Hot enough for ya?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from shell</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmpl = Template(<span class="string">&quot;Hello, $who! $what enough for ya?&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmpl.substitute(who=<span class="string">&quot;Mars&quot;</span>, what=<span class="string">&quot;Dusty&quot;</span>)</span><br><span class="line"><span class="string">&#x27;Hello, Mars! Dusty enough for ya?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new and improved</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;&#125;, &#123;&#125; and &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span>)</span><br><span class="line"><span class="string">&#x27;first, second and third&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125;, &#123;1&#125; and &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span>)</span><br><span class="line"><span class="string">&#x27;first, second and third&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;3&#125; &#123;0&#125; &#123;2&#125; &#123;1&#125; &#123;3&#125; &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;be&quot;</span>, <span class="string">&quot;not&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;to&quot;</span>)</span><br><span class="line"><span class="string">&#x27;to be or not to be&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;name&#125; is approximately &#123;value:.2f&#125;.&quot;</span>.<span class="built_in">format</span>(value=pi, name=<span class="string">&quot;π &quot;</span>)</span><br><span class="line"><span class="string">&#x27;π is approximately 3.14.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，在Python 3.6中，如果变量与替换字段同名，还可使用一种简写。在这种情况下，可使用f字符串——在字符串前面加上f。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> e</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;Euler&#x27;s constant is roughly <span class="subst">&#123;e&#125;</span>.&quot;</span></span><br><span class="line"><span class="string">&quot;Euler&#x27;s constant is roughly 2.718281828459045.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Euler&#x27;s constant is roughly &#123;e&#125;.&quot;</span>.<span class="built_in">format</span>(e=e)</span><br><span class="line"><span class="string">&quot;Euler&#x27;s constant is roughly 2.718281828459045.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置字符串的格式-完整版"><a href="#设置字符串的格式-完整版" class="headerlink" title="设置字符串的格式 完整版"></a>设置字符串的格式 完整版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;&#123;ceci n&#x27;est pas une replacement field&#125;&#125;&quot;</span>.<span class="built_in">format</span>()</span><br><span class="line"><span class="string">&quot;&#123;ceci n&#x27;est pas une replacement field&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>在格式字符串中，最激动人心的部分为替换字段。替换字段由如下部分组成，其中每个部分<br>都是可选的。</p><ul><li>字段名：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段。除指定值<br>外，还可指定值的特定部分，如列表的元素。</li><li>转换标志：跟在叹号后面的单个字符。当前支持的字符包括 r(表示 repr)、 s(表示 str)<br>和 a(表示 ascii)。如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使<br>用指定的函数将对象转换为字符串，再做进一步的格式设置。</li><li>格式说明符：跟在冒号后面的表达式(这种表达式是使用微型格式指定语言表示的)。格<br>式说明符让我们能够详细地指定最终的格式，包括格式类型(如字符串、浮点数或十六<br>进制数)，字段宽度和数的精度，如何显示符号和千位分隔符，以及各种对齐和填充方式。<br>下面详细介绍其中的一些要素。</li></ul><h4 id="替换字段名"><a href="#替换字段名" class="headerlink" title="替换字段名"></a>替换字段名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;foo&#125; &#123;&#125; &#123;bar&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1</span>, <span class="number">2</span>, bar=<span class="number">4</span>, foo=<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;3 1 4 2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;foo&#125; &#123;1&#125; &#123;bar&#125; &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1</span>, <span class="number">2</span>, bar=<span class="number">4</span>, foo=<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;3 2 4 1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fullname = [<span class="string">&quot;Alfred&quot;</span>, <span class="string">&quot;Smoketoomuch&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Mr &#123;name[1]&#125;&quot;</span>.<span class="built_in">format</span>(name=fullname)</span><br><span class="line"><span class="string">&#x27;Mr Smoketoomuch&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmpl = <span class="string">&quot;The &#123;mod.__name__&#125; module defines the value &#123;mod.pi&#125; for π &quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmpl.<span class="built_in">format</span>(mod=math)</span><br><span class="line"><span class="string">&#x27;The math module defines the value 3.141592653589793 for π &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本转换"><a href="#基本转换" class="headerlink" title="基本转换"></a>基本转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;&#123;pi!s&#125; &#123;pi!r&#125; &#123;pi!a&#125;&quot;</span>.<span class="built_in">format</span>(pi=<span class="string">&quot;π &quot;</span>))</span><br><span class="line">π <span class="string">&#x27;π &#x27;</span> <span class="string">&#x27;\u03c0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述三个标志( s、 r和a)指定分别使用str、 repr和ascii进行转换。</span></span><br><span class="line"><span class="comment"># 你还可指定要转换的值是哪种类型，更准确地说，是要将其视为哪种类型。例如，你可能提供一个整数，但将其作为小数进行处理。为此可在格式说明(即冒号后面)使用字符f(表示定点数)。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;The number is &#123;num&#125;&quot;</span>.<span class="built_in">format</span>(num=<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;The number is 42&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;The number is &#123;num:f&#125;&quot;</span>.<span class="built_in">format</span>(num=<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;The number is 42.000000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;The number is &#123;num:b&#125;&quot;</span>.<span class="built_in">format</span>(num=<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;The number is 101010&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表 3-1 字符串格式设置中的类型说明符</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>b</td><td>将整数表示为二进制数</td></tr><tr><td>c</td><td>将整数解读为 Unicode 码点</td></tr><tr><td>d</td><td>将整数视为十进制数进行处理，这是整数默认使用的说明符</td></tr><tr><td>e</td><td>使用科学表示法来表示小数(用 e 来表示指数)</td></tr><tr><td>E</td><td>与 e 相同，但使用 E 来表示指数</td></tr><tr><td>f</td><td>将小数表示为定点数</td></tr><tr><td>F</td><td>与 f 相同，但对于特殊值( nan 和 inf)，使用大写表示</td></tr><tr><td>g</td><td>自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有 1 位小数</td></tr><tr><td>G</td><td>与 g 相同，但使用大写来表示指数和特殊值</td></tr><tr><td>n</td><td>与 g 相同，但插入随区域而异的数字分隔符</td></tr><tr><td>o</td><td>将整数表示为八进制数</td></tr><tr><td>s</td><td>保持字符串的格式不变，这是默认用于字符串的说明符</td></tr><tr><td>x</td><td>将整数表示为十六进制数并使用小写字母</td></tr><tr><td>X</td><td>与 x 相同，但使用大写字母</td></tr><tr><td>%</td><td>将数表示为百分比值(乘以 100，按说明符 f 设置格式，再在后面加上%)</td></tr></tbody></table><h5 id="宽度、精度和千位分隔符"><a href="#宽度、精度和千位分隔符" class="headerlink" title="宽度、精度和千位分隔符"></a>宽度、精度和千位分隔符</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#宽度是使用整数指定的，如下所示：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;num:10&#125;&quot;</span>.<span class="built_in">format</span>(num=<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;         3&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;name:10&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line"><span class="string">&#x27;Bob       &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#精度是使用小数指定的，如下所示：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Pi day is &#123;pi:.2f&#125;&quot;</span>.<span class="built_in">format</span>(pi=pi)</span><br><span class="line"><span class="string">&#x27;Pi day is 3.14&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;pi:10.2f&#125;&quot;</span>.<span class="built_in">format</span>(pi=pi)</span><br><span class="line"><span class="string">&#x27; 3.14&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;:.5&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Guido van Rossum&quot;</span>)</span><br><span class="line"><span class="string">&#x27;Guido&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#　千位分隔符　　可使用逗号来指出你要添加千位分隔符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;One googol is &#123;:,&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">10</span>**<span class="number">100</span>)</span><br><span class="line"><span class="string">&#x27;One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时指定其他格式设置元素时，这个逗号应放在宽度和表示精度的句点之间①。</span></span><br></pre></td></tr></table></figure><h5 id="符号、对齐和用-0-填充"><a href="#符号、对齐和用-0-填充" class="headerlink" title="符号、对齐和用 0 填充"></a>符号、对齐和用 0 填充</h5><p>在一栏中同时包含字符串和数时，你可能想修改默认对齐方式。在指定宽<br>度和精度的数前面，可添加一个标志。<br>这个标志可以是零、加号、减号或空格，其中零表示使用 0 来填充数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:010.2f&#125;&#x27;</span>.<span class="built_in">format</span>(pi)</span><br><span class="line"><span class="string">&#x27;0000003.14&#x27;</span></span><br><span class="line">要指定左对齐、右对齐和居中，可分别使用&lt;、 &gt;和^。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&#x27;</span>.<span class="built_in">format</span>(pi))</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">  <span class="number">3.14</span></span><br><span class="line">     <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以使用填充字符来扩充对齐说明符，这样将使用指定的字符而不是默认的空格来填充。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;:$^15&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot; WIN BIG &quot;</span>)</span><br><span class="line"><span class="string">&#x27;$$$ WIN BIG $$$&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有更具体的说明符=，它指定将填充字符放在符号和数字之间。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10.2f&#125;\n&#123;1:10.2f&#125;&#x27;</span>.<span class="built_in">format</span>(pi, -pi))</span><br><span class="line">   <span class="number">3.14</span></span><br><span class="line">   -<span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10.2f&#125;\n&#123;1:=10.2f&#125;&#x27;</span>.<span class="built_in">format</span>(pi, -pi))</span><br><span class="line">   <span class="number">3.14</span></span><br><span class="line">-  <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要给正数加上符号，可使用说明符+(将其放在对齐说明符后面)，而不是默认的-。如果将符号说明符指定为空格，会在正数前面加上空格而不是+。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:-.2&#125;\n&#123;1:-.2&#125;&#x27;</span>.<span class="built_in">format</span>(pi, -pi)) <span class="comment">#默认设置</span></span><br><span class="line"><span class="number">3.1</span></span><br><span class="line">-<span class="number">3.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:+.2&#125;\n&#123;1:+.2&#125;&#x27;</span>.<span class="built_in">format</span>(pi, -pi))</span><br><span class="line">+<span class="number">3.1</span></span><br><span class="line">-<span class="number">3.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0: .2&#125;\n&#123;1: .2&#125;&#x27;</span>.<span class="built_in">format</span>(pi, -pi))</span><br><span class="line"> <span class="number">3.1</span></span><br><span class="line">-<span class="number">3.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要介绍的最后一个要素是井号( #)选项，你可将其放在符号说明符和宽度之间(如果指定了这两种设置)。这个选项将触发另一种转换方式，转换细节随类型而异。例如，对于二进制、八进制和十六进制转换，将加上一个前缀。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;:b&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;101010&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;:#b&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;0b101010&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;:g&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;:#g&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">42</span>)</span><br><span class="line"><span class="string">&#x27;42.0000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据指定的宽度打印格式良好的价格列表</span></span><br><span class="line">width = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter width: &#x27;</span>))</span><br><span class="line">price_width = <span class="number">10</span></span><br><span class="line">item_width = width - price_width</span><br><span class="line">header_fmt = <span class="string">&#x27;&#123;&#123;:&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(item_width, price_width)</span><br><span class="line">fmt = <span class="string">&#x27;&#123;&#123;:&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;.2f&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(item_width, price_width)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * width)</span><br><span class="line"><span class="built_in">print</span>(header_fmt.<span class="built_in">format</span>(<span class="string">&#x27;Item&#x27;</span>, <span class="string">&#x27;Price&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * width)</span><br><span class="line"><span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="string">&#x27;Apples&#x27;</span>, <span class="number">0.4</span>))</span><br><span class="line"><span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="string">&#x27;Pears&#x27;</span>, <span class="number">0.5</span>))</span><br><span class="line"><span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="string">&#x27;Cantaloupes&#x27;</span>, <span class="number">1.92</span>))</span><br><span class="line"><span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="string">&#x27;Dried Apricots (16 oz.)&#x27;</span>, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="string">&#x27;Prunes (4 lbs.)&#x27;</span>, <span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * width)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># result</span></span><br><span class="line"><span class="comment"># 这个程序的运行情况类似于下面这样：</span></span><br><span class="line">Please enter width: <span class="number">35</span></span><br><span class="line">===================================</span><br><span class="line">Item                          Price</span><br><span class="line">-----------------------------------</span><br><span class="line">Apples                         <span class="number">0.40</span></span><br><span class="line">Pears                          <span class="number">0.50</span></span><br><span class="line">Cantaloupes                    <span class="number">1.92</span></span><br><span class="line">Dried Apricots (<span class="number">16</span> oz.)        <span class="number">8.00</span></span><br><span class="line">Prunes (<span class="number">4</span> lbs.)               <span class="number">12.00</span></span><br><span class="line">===================================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>套娃哇！！666</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>字符串的方法太多了，这里只介绍一些最有用的。完整的字符串方法清单请参阅附录 B。这<br>里描述字符串的方法时，将列出其他相关的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串的方法</span></span><br><span class="line"><span class="built_in">str</span>.center(width[, fillchar]) <span class="comment"># 方法center通过在两边添加填充字符(默认为空格)让字符串居中。</span></span><br><span class="line"><span class="built_in">str</span>.find(sub[, start[, end]]) <span class="comment"># 方法find返回子字符串sub在字符串中第一次出现的索引，如果没有找到，则返回-1。</span></span><br><span class="line"><span class="built_in">str</span>.join(seq) <span class="comment"># 方法join将序列seq中的元素用字符串str连接起来，返回连接后的字符串。 所合并序列的元素必须都是字符串</span></span><br><span class="line"><span class="built_in">str</span>.lower() <span class="comment"># 方法lower将字符串转换为小写。</span></span><br><span class="line"><span class="built_in">str</span>.upper() <span class="comment"># 方法upper将字符串转换为大写。</span></span><br><span class="line"><span class="built_in">str</span>.split(sep[, maxsplit]) <span class="comment"># 方法split将字符串按照分隔符sep分割，返回分割后的字符串列表。</span></span><br><span class="line"><span class="built_in">str</span>.strip([chars]) <span class="comment"># 方法strip删除字符串左右两边的空格。</span></span><br><span class="line"><span class="built_in">str</span>.replace(old, new[, <span class="built_in">max</span>]) <span class="comment"># 方法replace将字符串中的old子字符串替换为new子字符串，返回替换后的字符串。</span></span><br><span class="line"><span class="built_in">str</span>.splitlines([keepends]) <span class="comment"># 方法splitlines将字符串按照行分割，返回分割后的字符串列表。</span></span><br><span class="line"><span class="built_in">str</span>.translate(table[, deletechars]) <span class="comment"># 方法translate将字符串中的字符用表table中的对应字符替换，返回替换后的字符串。 方法translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换。这个方法的优势在于能够同时替换多个字符，因此效率比replace高。</span></span><br><span class="line"><span class="built_in">str</span>.isdigit() <span class="comment"># 方法isdigit判断字符串是否只包含数字字符。</span></span><br><span class="line"><span class="built_in">str</span>.isalpha() <span class="comment"># 方法isalpha判断字符串是否只包含字母字符。</span></span><br><span class="line"><span class="built_in">str</span>.isalnum() <span class="comment"># 方法isalnum判断字符串是否只包含字母和数字字符。</span></span><br><span class="line"><span class="built_in">str</span>.islower() <span class="comment"># 方法islower判断字符串是否只包含小写字母。</span></span><br><span class="line"><span class="built_in">str</span>.isupper() <span class="comment"># 方法isupper判断字符串是否只包含大写字母。 isalnum、 isalpha、 isdecimal、 isdigit、 isidentifier、 islower、 isnumeric、isprintable、 isspace、 istitle、 isupper。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="trnaslate"><a href="#trnaslate" class="headerlink" title="trnaslate"></a>trnaslate</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = <span class="built_in">str</span>.maketrans(<span class="string">&#x27;cs&#x27;</span>, <span class="string">&#x27;kz&#x27;</span>)</span><br><span class="line">如果愿意，可查看转换表的内容，但你看到的只是Unicode码点之间的映射。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table</span><br><span class="line">&#123;<span class="number">115</span>: <span class="number">122</span>, <span class="number">99</span>: <span class="number">107</span>&#125;</span><br><span class="line">创建转换表后，就可将其用作方法translate的参数。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;this is an incredible test&#x27;</span>.translate(table)</span><br><span class="line"><span class="string">&#x27;thiz iz an inkredible tezt&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了字符串的两个重要方面。</p><ul><li>字符串格式设置：求模运算符( %)可用于将值合并为包含转换标志(如%s)的字符串，<br>这让你能够以众多方式设置值的格式，如左对齐或右对齐，指定字段宽度和精度，添加<br>符号(正号或负号)以及在左边填充 0 等。</li><li>字符串方法：字符串有很多方法， 有些很有用(如 split 和 join)，有些很少用到(如 istitle<br>和 capitalize)。</li></ul><h2 id="字典-当索引行不通时"><a href="#字典-当索引行不通时" class="headerlink" title="字典 当索引行不通时"></a>字典 当索引行不通时</h2><p><code>phonebook = &#123;&#39;Alice&#39;: &#39;2341&#39;, &#39;Beth&#39;: &#39;9102&#39;, &#39;Cecil&#39;: &#39;3258&#39;&#125;</code></p><p>他的定义有点像结构体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Gumby&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">42</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(items)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">42</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Gumby&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;Gumby&#x27;</span></span><br><span class="line"><span class="comment"># 还可使用关键字实参来调用这个函数，如下所示：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Gumby&#x27;</span>, age=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">42</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Gumby&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变<br>的类型，如浮点数(实数)、字符串或元组。</li><li>自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。<br>然而，如果不使用 append 或其他类似的方法，就不能给列表中没有的元素赋值。</li><li>成员资格：表达式 k in d(其中 d 是一个字典)查找的是键而不是值，而表达式 v in l(其<br>中 l 是一个列表)查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自<br>然。毕竟如果字典包含指定的键，检查相应的值就很容易。</li></ul><blockquote><p>将字符串格式设置功能用于字典</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phonebook</span><br><span class="line">&#123;<span class="string">&#x27;Beth&#x27;</span>: <span class="string">&#x27;9102&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>: <span class="string">&#x27;2341&#x27;</span>, <span class="string">&#x27;Cecil&#x27;</span>: <span class="string">&#x27;3258&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Cecil&#x27;s phone number is &#123;Cecil&#125;.&quot;</span>.format_map(phonebook)</span><br><span class="line"><span class="string">&quot;Cecil&#x27;s phone number is 3258.&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><p>clear：清空字典中的所有项。<br>copy：返回一个字典的浅复制，而不是深复制。deepcopy：返回一个字典的深复制。<br>fromkeys：从指定的键值对创建一个新的字典。<br>get：返回指定键的值，如果值不在字典中返回默认值。方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。使用 get 来访问不存在的键时，没有引发异常，而是返回 None。你可指定“默认”值，这样将返回你指定的值而不是 None。</p><p>items：返回一个包含字典中的所有项的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;Python Web Site&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;http://www.python.org&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;url&#x27;</span>, <span class="string">&#x27;http://www.python.org&#x27;</span>), (<span class="string">&#x27;spam&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Python Web Site&#x27;</span>)])</span><br></pre></td></tr></table></figure><p>返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代(迭代将在第 5 章详细介绍)。<br>另外，你还可确定其长度以及对其执行成员资格检查。</p><p>视图的一个优点是不复制，它们始终是底层字典的反映，即便你修改了底层字典亦如此。</p><p>keys：返回一个包含字典中的所有键的列表。视图<br>pop：删除并返回字典中的一个项。<code>d.pop(&#39;x&#39;)</code><br>popitem：随机删除并返回字典中的一个项。<br>setdefault：如果键不存在于字典中，则为它设置默认值。<br>update：将另一个字典的项添加到字典中。<br>values：返回一个包含字典中的所有值的列表。视图</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了如下内容。</p><ul><li>映射：映射让你能够使用任何不可变的对象(最常用的是字符串和元组)来标识其元素。<br>Python 只有一种内置的映射类型，那就是字典。</li><li>将字符串格式设置功能用于字典：要对字典执行字符串格式设置操作，不能使用 format<br>和命名参数，而必须使用 format_map。</li><li>字典方法：字典有很多方法，这些方法的调用方式与列表和字符串的方法相同。</li></ul><h2 id="条件、循环及其他语句"><a href="#条件、循环及其他语句" class="headerlink" title="条件、循环及其他语句"></a>条件、循环及其他语句</h2><h3 id="赋值魔法"><a href="#赋值魔法" class="headerlink" title="赋值魔法"></a>赋值魔法</h3><ol><li>序列解包</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x, y, z)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = y, x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x, y)</span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可使用星号运算符( *)来收集多余的值，这样无需确保值和变量的个数相同，如下例所示：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rest</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可将带星号的变量放在其他位置。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&quot;Albus Percival Wulfric Brian Dumbledore&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first, *middle, last = name.split()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>middle</span><br><span class="line">[<span class="string">&#x27;Percival&#x27;</span>, <span class="string">&#x27;Wulfric&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是一个列表。在变量和值的个数相同时亦如此。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>链式赋值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 链式赋值是一种快捷方式，用于将多个变量关联到同一个值。这有点像前一节介绍的并行赋值，但只涉及一个值：</span></span><br><span class="line">x = y = somefunction()</span><br><span class="line"><span class="comment"># 上述代码与下面的代码等价：</span></span><br><span class="line">y = somefunction()</span><br><span class="line">x = y</span><br><span class="line"><span class="comment"># 请注意，这两条语句可能与下面的语句不等价：</span></span><br><span class="line">x = somefunction()</span><br><span class="line">y = somefunction()</span><br><span class="line"><span class="comment"># 有关这方面的详细信息，请参阅5.4.6节介绍相同运算符( is)的部分。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>关键字 assert</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">0</span> &lt; age &lt; <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">0</span> &lt; age &lt; <span class="number">100</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">AssertionError</span><br><span class="line"><span class="comment">#如果知道必须满足特定条件，程序才能正确地运行，可在程序中添加assert语句充当检查点，这很有帮助。还可在条件后面添加一个字符串，对断言做出说明。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">0</span> &lt; age &lt; <span class="number">100</span>, <span class="string">&#x27;The age must be realistic&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">AssertionError: The age must be realistic</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>迭代字典</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要遍历字典的所有关键字，可像遍历序列那样使用普通的for语句。</span></span><br><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, d[key])</span><br><span class="line"><span class="comment"># 也可使用keys等字典方法来获取所有的键。如果只对值感兴趣，可使用d.values。你可能还</span></span><br><span class="line"><span class="comment"># 记得， d.items以元组的方式返回键值对。 for循环的优点之一是，可在其中使用序列解包。</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, value)</span><br></pre></td></tr></table></figure><ol start="5"><li>并行迭代</li></ol><p>有时候，你可能想同时迭代两个序列。假设有下面两个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;anne&#x27;</span>, <span class="string">&#x27;beth&#x27;</span>, <span class="string">&#x27;george&#x27;</span>, <span class="string">&#x27;damon&#x27;</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">102</span>]</span><br></pre></td></tr></table></figure><p>如果要打印名字和对应的年龄，可以像下面这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line"><span class="built_in">print</span>(names[i], <span class="string">&#x27;is&#x27;</span>, ages[i], <span class="string">&#x27;years old&#x27;</span>)</span><br></pre></td></tr></table></figure><p>i 是用作循环索引的变量的标准名称。一个很有用的并行迭代工具是内置函数 zip，它将两个<br>序列“缝合”起来，并返回一个由元组组成的序列。返回值是一个适合迭代的对象，要查看其内<br>容，可使用 list 将其转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(names, ages))</span><br><span class="line">[(<span class="string">&#x27;anne&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;beth&#x27;</span>, <span class="number">45</span>), (<span class="string">&#x27;george&#x27;</span>, <span class="number">32</span>), (<span class="string">&#x27;damon&#x27;</span>, <span class="number">102</span>)]</span><br></pre></td></tr></table></figure><p>“缝合”后，可在循环中将元组解包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age <span class="keyword">in</span> <span class="built_in">zip</span>(names, ages):</span><br><span class="line"><span class="built_in">print</span>(name, <span class="string">&#x27;is&#x27;</span>, age, <span class="string">&#x27;years old&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数 zip 可用于“缝合”任意数量的序列。需要指出的是，当序列的长度不同时，函数 zip 将<br>在最短的序列用完后停止“缝合”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">100000000</span>)))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure><ol start="6"><li>迭代时获取索引</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> strings:</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> string:</span><br><span class="line">strings[index] = <span class="string">&#x27;[censored]&#x27;</span></span><br><span class="line">index += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个解决方案虽然可以接受，但看起来也有点笨拙。另一种解决方案是使用内置函数<br>enumerate。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, string <span class="keyword">in</span> <span class="built_in">enumerate</span>(strings):</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> string:</span><br><span class="line">strings[index] = <span class="string">&#x27;[censored]&#x27;</span></span><br></pre></td></tr></table></figure><p>这个函数让你能够迭代索引 值对，其中的索引是自动提供的。</p><ol start="7"><li>循环中的 else 子句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">99</span>, <span class="number">81</span>, -<span class="number">1</span>):</span><br><span class="line">root = sqrt(n)</span><br><span class="line"><span class="keyword">if</span> root == <span class="built_in">int</span>(root):</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Didn&#x27;t find it!&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>在循环中使用 else 子句，可以在循环正常结束时执行，也可以在循环异常结束时执行。</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表推导式是列表创建的另一种方式。</span></span><br><span class="line">squares = [n ** <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x <span class="number">3</span> == <span class="number">0</span>] %</span><br><span class="line">[<span class="number">0</span>, <span class="number">9</span>, <span class="number">36</span>, <span class="number">81</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>girls = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bernice&#x27;</span>, <span class="string">&#x27;clarice&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>boys = [<span class="string">&#x27;chris&#x27;</span>, <span class="string">&#x27;arnold&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[b+<span class="string">&#x27;+&#x27;</span>+g <span class="keyword">for</span> b <span class="keyword">in</span> boys <span class="keyword">for</span> g <span class="keyword">in</span> girls <span class="keyword">if</span> b[<span class="number">0</span>] == g[<span class="number">0</span>]]</span><br><span class="line">[<span class="string">&#x27;chris+clarice&#x27;</span>, <span class="string">&#x27;arnold+alice&#x27;</span>, <span class="string">&#x27;bob+bernice&#x27;</span>]</span><br><span class="line"><span class="comment"># 这些代码将名字的首字母相同的男孩和女孩配对。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = &#123;i:<span class="string">&quot;&#123;&#125; squared is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, i**<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;0 squared is 0&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;1 squared is 1&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;2 squared is 4&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;3 squared is 9&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;4 squared is 16&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;5 squared is 25&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;6 squared is 36&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;7 squared is 49&#x27;</span>, <span class="number">8</span>: <span class="string">&#x27;8 squared is 64&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;9 squared is 81&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 在列表推导中， for前面只有一个表达式，而在字典推导中， for前面有两个用冒号分隔的表</span></span><br><span class="line"><span class="comment"># 达式。这两个表达式分别为键及其对应的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三人行"><a href="#三人行" class="headerlink" title="三人行"></a>三人行</h3><p>pass、 del 和 exec</p><p>pass 可以用来作为占位符，用于空语句块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>del 可以用来删除一个对象的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这看似简单，但有时不太好理解。例如，在下面的示例中， x和y指向同一个列表：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[<span class="number">1</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"><span class="comment"># 你可能认为通过删除x，也将删除y，但情况并非如此。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"><span class="comment">#这是为什么呢？ x和y指向同一个列表，但删除x对y没有任何影响，因为你只删除名称x，而没有删除列表本身(值)。事实上，在Python中，根本就没有办法删除值，而且你也不需要这样</span></span><br><span class="line"><span class="comment"># 做，因为对于你不再使用的值， Python解释器会立即将其删除。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>exec 可以用来执行一段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(<span class="string">&quot;print(&#x27;Hello, world!&#x27;)&quot;</span>)</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line"><span class="comment"># eval</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec执行一系列Python语句，而eval计算用字符串表示</span></span><br><span class="line"><span class="comment"># 的Python表达式的值，并返回结果( exec什么都不返回，因为它本身是条语句)。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter an arithmetic expression: &quot;</span>))</span><br><span class="line">Enter an arithmetic expression: <span class="number">6</span> + <span class="number">18</span> * <span class="number">2</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了多种语句。</p><ul><li>打印语句：你可使用 print 语句来打印多个用逗号分隔的值。如果 print 语句以逗号结尾，<br>后续 print 语句将在当前行接着打印。</li><li>导入语句：有时候，你不喜欢要导入的函数的名称——可能是因为你已将这个名称用作<br>他用。在这种情况下，可使用 import as 语句在本地重命名函数。</li><li>赋值语句：通过使用奇妙的序列解包和链式赋值，可同时给多个变量赋值；而通过使用<br>增强赋值，可就地修改变量。</li><li>代码块：代码块用于通过缩进将语句编组。代码块可用于条件语句和循环中，还可用于<br>函数和类定义中(这将在本书后面介绍)。</li><li>条件语句：条件语句根据条件(布尔表达式)决定是否执行后续代码块。通过使用 if&#x2F;elif&#x2F;<br>else，可将多个条件语句组合起来。条件语句的一个变种是条件表达式，如 a if b else c。</li><li>断言：断言断定某件事(一个布尔表达式)为真，可包含说明为何必须如此的字符串。<br>如果指定的表达式为假，断言将导致程序停止执行(或引发第 8 章将介绍的异常)。最好<br>尽早将错误揪出来，免得它潜藏在程序中，直到带来麻烦。</li><li>循环：你可针对序列中的每个元素(如特定范围内的每个数)执行代码块，也可在条件<br>为真时反复执行代码块。要跳过代码块中余下的代码，直接进入下一次迭代，可使用<br>continue 语句；要跳出循环，可使用 break 语句。另外，你还可在循环末尾添加一个 else<br>子句，它将在没有执行循环中的任何 break 语句时执行。</li><li>推导：推导并不是语句，而是表达式。它们看起来很像循环，因此我将它们放在循环中<br>讨论。通过列表推导，可从既有列表创建出新列表，这是通过对列表元素调用函数、剔<br>除不想要的函数等实现的。推导功能强大，但在很多情况下，使用普通循环和条件语句<br>也可完成任务，且代码的可读性可能更高。使用类似于列表推导的表达式可创建出字典。</li><li>pass、 del、 exec 和 eval： pass 语句什么都不做，但适合用作占位符。 del 语句用于删除变<br>量或数据结构的成员，但不能用于删除值。函数 exec 用于将字符串作为 Python 程序执行。<br>函数 eval 计算用字符串表示的表达式并返回结果。</li></ul><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h4 id="懒惰是一种美德"><a href="#懒惰是一种美德" class="headerlink" title="懒惰是一种美德"></a>懒惰是一种美德</h4><p>这里说的懒不是贬义词，而是说不做无谓的工作。</p><p>在有些语言(如 C++、 Pascal 和 Ada)中，经常需要给参数赋值并让这种修改影响函数外部的变<br>量。在 Python 中，没法直接这样做，只能修改参数对象本身。</p><h4 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h4><p>参数前面的星号将提供的所有值都放在一个元组中，也就是将这些值收集起来。这样的行为<br>我们在 5.2.1 节见过：赋值时带星号的变量收集多余的值。它收集的是列表而不是元组中多余的值，<br>但除此之外，这两种用法很像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_params</span>(<span class="params">*params</span>):</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_params(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_params_2</span>(<span class="params">title, *params</span>):</span><br><span class="line">    <span class="built_in">print</span>(title)</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_params_2(<span class="string">&#x27;Params:&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Params:</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与赋值时一样，带星号的参数也可放在其他位置(而不是最后)，但不同的是，在这种情况<br>下你需要做些额外的工作：使用名称来指定后续参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">in_the_middle</span>(<span class="params">x, *y, z</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, y, z)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_the_middle(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, z=<span class="number">7</span>)</span><br><span class="line"><span class="number">1</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_the_middle(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: in_the_middle() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;z&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 星号不会收集关键字参数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_params_2(<span class="string">&#x27;Hmm   &#x27;</span>, something=<span class="number">42</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: print_params_2() got an unexpected keyword argument <span class="string">&#x27;something&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要收集关键字参数，可使用两个星号。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_params_3</span>(<span class="params">**params</span>):</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_params_3(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">如你所见，这样得到的是一个字典而不是元组。可结合使用这些技术。</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_params_4</span>(<span class="params">x, y, z=<span class="number">3</span>, *pospar, **keypar</span>):</span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br><span class="line"><span class="built_in">print</span>(pospar)</span><br><span class="line"><span class="built_in">print</span>(keypar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其效果与预期的相同。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_params_4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, foo=<span class="number">1</span>, bar=<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_params_4(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了抽象的基本知识以及函数。</p><ul><li>抽象：抽象是隐藏不必要细节的艺术。通过定义处理细节的函数，可让程序更抽象。</li><li>函数定义：函数是使用 def 语句定义的。函数由语句块组成，它们从外部接受值(参数)，<br>并可能返回一个或多个值(计算结果)。</li><li>参数：函数通过参数(调用函数时被设置的变量)接收所需的信息。在 Python 中，参数有<br>两类：位置参数和关键字参数。通过给参数指定默认值，可使其变成可选的。</li><li>作用域：变量存储在作用域(也叫命名空间)中。在 Python 中，作用域分两大类：全局作<br>用域和局部作用域。作用域可以嵌套。</li><li>递归：函数可调用自身，这称为递归。可使用递归完成的任何任务都可使用循环来完成，<br>但有时使用递归函数的可读性更高。</li><li>函数式编程： Python 提供了一些函数式编程工具，其中包括 lambda 表达式以及函数 map、<br>filter 和 reduce。</li></ul><h2 id="再谈抽象"><a href="#再谈抽象" class="headerlink" title="再谈抽象"></a>再谈抽象</h2><h3 id="对象魔法"><a href="#对象魔法" class="headerlink" title="对象魔法"></a>对象魔法</h3><ul><li>多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行。</li><li>封装：对外部隐藏有关对象工作原理的细节。</li><li>继承：可基于通用类创建出专用类。</li></ul><h3 id="创建自定义类"><a href="#创建自定义类" class="headerlink" title="创建自定义类"></a>创建自定义类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, world! I&#x27;m &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TalkingCalculator</span>(Calculator, Talker):</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="深入探讨继承"><a href="#深入探讨继承" class="headerlink" title="深入探讨继承"></a>深入探讨继承</h3><p>要确定一个类是否是另一个类的子类，可使用内置方法 issubclass。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(SPAMFilter, Filter)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Filter, SPAMFilter)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>如果你有一个类，并想知道它的基类，可访问其特殊属性<strong>bases</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>SPAMFilter.__bases__</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="title class_">__main__</span>.Filter at <span class="number">0x171e40</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Filter.__bases__</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;,)</span><br></pre></td></tr></table></figure><h3 id="关于面向对象设计的一些思考"><a href="#关于面向对象设计的一些思考" class="headerlink" title="关于面向对象设计的一些思考"></a>关于面向对象设计的一些思考</h3><p>专门探讨面向对象程序设计的图书很多，虽然这并非本书的重点，但还是要提供一些指南。</p><ul><li>将相关的东西放在一起。如果一个函数操作一个全局变量，最好将它们作为一个类的属<br>性和方法。</li><li>不要让对象之间过于亲密。方法应只关心其所属实例的属性，对于其他实例的状态，让<br>它们自己去管理就好了。</li><li>慎用继承，尤其是多重继承。继承有时很有用，但在有些情况下可能带来不必要的复杂<br>性。要正确地使用多重继承很难，要排除其中的 bug 更难。</li><li>保持简单。让方法短小紧凑。一般而言，应确保大多数方法都能在 30 秒内读完并理解。<br>对于其余的方法，尽可能将其篇幅控制在一页或一屏内。<br>确定需要哪些类以及这些类应包含哪些方法时，尝试像下面这样做。</li></ul><p>(1) 将有关问题的描述(程序需要做什么)记录下来，并给所有的名词、动词和形容词加<br>上标记。<br>(2) 在名词中找出可能的类。<br>(3) 在动词中找出可能的方法。<br>(4) 在形容词中找出可能的属性。<br>(5) 将找出的方法和属性分配给各个类。<br>有了面向对象模型的草图后，还需考虑类和对象之间的关系(如继承或协作)以及它们的职<br>责。为进一步改进模型，可像下面这样做。<br>(1) 记录(或设想)一系列用例，即使用程序的场景，并尽力确保这些用例涵盖了所有的功能。<br>(2) 透彻而仔细地考虑每个场景，确保模型包含了所需的一切。如果有遗漏，就加上；如果<br>有不太对的地方，就修改。不断地重复这个过程，直到对模型满意为止。<br>有了你认为行之有效的模型后，就可以着手编写程序了。你很可能需要修改模型或程序的某<br>些部分，所幸这在 Python 中很容易，请不用担心。只管按这里说的去做就好。(如果你需要更详<br>细的面向对象编程指南，请参阅第 19 章的推荐书目。)</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>本章不仅介绍了有关 Python 语言的知识，还介绍了多个你可能一点都不熟悉的概念。下面来<br>总结一下。</p><ul><li>对象：对象由属性和方法组成。属性不过是属于对象的变量，而方法是存储在属性中的<br>函数。相比于其他函数，(关联的)方法有一个不同之处，那就是它总是将其所属的对象<br>作为第一个参数，而这个参数通常被命名为 self。</li><li>类：类表示一组(或一类)对象，而每个对象都属于特定的类。类的主要任务是定义其<br>实例将包含的方法。</li><li>多态：多态指的是能够同样地对待不同类型和类的对象，即无需知道对象属于哪个类就<br>可调用其方法。</li><li>封装：对象可能隐藏(封装)其内部状态。在有些语言中，这意味着对象的状态(属性)<br>只能通过其方法来访问。在 Python 中，所有的属性都是公有的，但直接访问对象的状态时<br>程序员应谨慎行事，因为这可能在不经意间导致状态不一致。</li><li>继承：一个类可以是一个或多个类的子类，在这种情况下，子类将继承超类的所有方法。<br>你可指定多个超类，通过这样做可组合正交(独立且不相关)的功能。为此，一种常见<br>的做法是使用一个核心超类以及一个或多个混合超类。</li><li>接口和内省：一般而言，你无需过于深入地研究对象，而只依赖于多态来调用所需的方<br>法。然而，如果要确定对象包含哪些方法或属性，有一些函数可供你用来完成这种工作。</li><li>抽象基类：使用模块 abc 可创建抽象基类。抽象基类用于指定子类必须提供哪些功能，却<br>不实现这些功能。</li><li>面向对象设计：关于该如何进行面向对象设计以及是否该采用面向对象设计，有很多不<br>同的观点。无论你持什么样的观点，都必须深入理解问题，进而创建出易于理解的设计。</li></ul><h2 id="异-常"><a href="#异-常" class="headerlink" title="异 常"></a>异 常</h2><p><em>这是重点</em></p><h3 id="异常是什么"><a href="#异常是什么" class="headerlink" title="异常是什么"></a>异常是什么</h3><p>Python 使用异常对象来表示异常状态，并在遇到错误时引发异常。异常对象未被处理(或捕<br>获)时，程序将终止并显示一条错误消息( traceback)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure><p>如果异常只能用来显示错误消息，就没多大意思了。但事实上，每个异常都是某个类(这里<br>是 ZeroDivisionError)的实例。你能以各种方式引发和捕获这些实例，从而逮住错误并采取措施，<br>而不是放任整个程序失败。</p><h3 id="让事情沿你指定的轨道出错"><a href="#让事情沿你指定的轨道出错" class="headerlink" title="让事情沿你指定的轨道出错"></a>让事情沿你指定的轨道出错</h3><p>正如你看到的，出现问题时，将自动引发异常。先来看看如何自主地引发异常，还有如何创<br>建异常，然后再学习如何处理这些异常。</p><h4 id="引发异常"><a href="#引发异常" class="headerlink" title="引发异常"></a>引发异常</h4><p>引发异常的方法是使用 raise 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">Exception</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception(<span class="string">&#x27;hyperdrive overload&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">Exception: hyperdrive overload</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>描述</th></tr></thead><tbody><tr><td>Exception</td><td>几乎所有的异常类都是从它派生而来的</td></tr><tr><td>AttributeError</td><td>引用属性或给它赋值失败时引发</td></tr><tr><td>OSError</td><td>操作系统不能执行指定的任务(如打开文件)时引发，有多个子类</td></tr><tr><td>IndexError</td><td>使用序列中不存在的索引时引发，为 LookupError 的子类</td></tr><tr><td>KeyError</td><td>使用映射中不存在的键时引发，为 LookupError 的子类</td></tr><tr><td>NameError</td><td>找不到名称(变量)时引发</td></tr><tr><td>SyntaxError</td><td>代码不正确时引发</td></tr><tr><td>TypeError</td><td>将内置操作或函数用于类型不正确的对象时引发</td></tr><tr><td>ValueError</td><td>将内置操作或函数用于这样的对象时引发：其类型正确但包含的值不合适</td></tr><tr><td>ZeroDivisionError</td><td>在除法或求模运算的第二个参数为零时引发</td></tr></tbody></table><h5 id="创建自定义异常类"><a href="#创建自定义异常类" class="headerlink" title="创建自定义异常类"></a>创建自定义异常类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCustomException</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>try&#x2F;except 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the first number: &#x27;</span>))</span><br><span class="line">    y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the second number: &#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The second number can&#x27;t be zero!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获多种异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the first number: &#x27;</span>))</span><br><span class="line">    y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the second number: &#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The second number can&#x27;t be zero!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That wasn&#x27;t a number, was it?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获多种异常的另一种方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the first number: &#x27;</span>))</span><br><span class="line">    y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the second number: &#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError, NameError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Your numbers were bogus    &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the first number: &#x27;</span>))</span><br><span class="line">    y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the second number: &#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError, NameError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Your numbers were bogus     &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一网打尽</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the first number: &#x27;</span>))</span><br><span class="line">    y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter the second number: &#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="keyword">except</span> Exceptions <span class="keyword">as</span> e: <span class="comment"># 捕获所有异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Your numbers were bogus     &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(e))</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 没有异常时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK, no errors&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>: <span class="comment"># 最后，还有finally子句，可用于在发生异常时执行清理工作。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;This always executes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常和函数"><a href="#异常和函数" class="headerlink" title="异常和函数"></a>异常和函数</h3><p>异常和函数有着天然的联系。如果不处理函数中引发的异常，它将向上传播到调用函数的地<br>方。如果在那里也未得到处理，异常将继续传播，直至到达主程序(全局作用域)。如果主程序<br>中也没有异常处理程序，程序将终止并显示栈跟踪消息。</p><h3 id="异常之禅-异常与循环"><a href="#异常之禅-异常与循环" class="headerlink" title="异常之禅(异常与循环)"></a>异常之禅(异常与循环)</h3><p>有时候，可使用条件语句来达成异常处理实现的目标，但这样编写出来的代码可能不那么自<br>然，可读性也没那么高。另一方面，有些任务使用 if&#x2F;else 完成时看似很自然，但实际上使用<br>try&#x2F;except 来完成要好得多。下面来看两个示例。</p><p>假设有一个字典，你要在指定的键存在时打印与之相关联的值，否则什么都不做。实现这种<br>功能的代码可能类似于下面这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_person</span>(<span class="params">person</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Description of&#x27;</span>, person[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Age:&#x27;</span>, person[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;occupation&#x27;</span> <span class="keyword">in</span> person:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Occupation:&#x27;</span>, person[<span class="string">&#x27;occupation&#x27;</span>])</span><br></pre></td></tr></table></figure><p>如果你调用这个函数，并向它提供一个包含姓名 Throatwobbler Mangrove 和年龄 42(但不包<br>含职业)的字典，输出将如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Description of Throatwobbler Mangrove</span><br><span class="line">Age: <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你在这个字典中添加职业camper，输出将如下：</span></span><br><span class="line"></span><br><span class="line">Description of Throatwobbler Mangrove</span><br><span class="line">Age: <span class="number">42</span></span><br><span class="line">Occupation: camper</span><br></pre></td></tr></table></figure><p>这段代码很直观，但效率不高(虽然这里的重点是代码简洁)，因为它必须两次查找<br>‘occupation’键：一次检查这个键是否存在(在条件中)，另一次获取这个键关联的值，以便将<br>其打印出来。下面是另一种解决方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_person</span>(<span class="params">person</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Description of&#x27;</span>, person[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Age:&#x27;</span>, person[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Occupation:&#x27;</span>, person[<span class="string">&#x27;occupation&#x27;</span>])</span><br><span class="line">    <span class="keyword">except</span> KeyError: <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这里，函数直接假设存在’occupation’键。如果这种假设正确，就能省点事：直接获取并<br>打印值，而无需检查这个键是否存在。如果这个键不存在，将引发 KeyError 异常，而 except 子句<br>将捕获这个异常。</p><h3 id="不那么异常的情况-警告"><a href="#不那么异常的情况-警告" class="headerlink" title="不那么异常的情况(警告)"></a>不那么异常的情况(警告)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> warnings <span class="keyword">import</span> warn</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>warn(<span class="string">&quot;I&#x27;ve got a bad feeling about this.&quot;</span>)</span><br><span class="line">__main__:<span class="number">1</span>: UserWarning: I<span class="string">&#x27;ve got a bad feeling about this.</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>警告只显示一次。如果再次运行最后一行代码，什么事情都不会发生。<br>如果其他代码在使用你的模块，可使用模块warnings中的函数filterwarnings来抑制你发出<br>的警告(或特定类型的警告)，并指定要采取的措施，如”error”或”ignore”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> warnings <span class="keyword">import</span> filterwarnings</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>warn(<span class="string">&quot;Anyone out there?&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filterwarnings(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>warn(<span class="string">&quot;Something is very wrong!&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UserWarning: Something <span class="keyword">is</span> very wrong!</span><br></pre></td></tr></table></figure><p>如你所见，引发的异常为UserWarning。发出警告时，可指定将引发的异常(即警告类别)，<br>但必须是Warning的子类。如果将警告转换为错误，将使用你指定的异常。另外，还可根据异常<br>来过滤掉特定类型的警告。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filterwarnings(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>warn(<span class="string">&quot;This function is really old   &quot;</span>, DeprecationWarning)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">DeprecationWarning: This function <span class="keyword">is</span> really old   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filterwarnings(<span class="string">&quot;ignore&quot;</span>, category=DeprecationWarning)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>warn(<span class="string">&quot;Another deprecation warning.&quot;</span>, DeprecationWarning)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>warn(<span class="string">&quot;Something else.&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UserWarning: Something <span class="keyword">else</span>.</span><br></pre></td></tr></table></figure><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了如下重要主题。</p><ul><li>异常对象：异常情况(如发生错误)是用异常对象表示的。对于异常情况，有多种处理<br>方式；如果忽略，将导致程序终止。</li><li>引发异常：可使用raise语句来引发异常。它将一个异常类或异常实例作为参数，但你也<br>可提供两个参数(异常和错误消息)。 如果在except子句中调用raise时没有提供任何参数，<br>它将重新引发该子句捕获的异常。</li><li>自定义的异常类：你可通过从Exception派生来创建自定义的异常。</li><li>捕获异常：要捕获异常，可在try语句中使用except子句。在except子句中，如果没有指<br>定异常类，将捕获所有的异常。你可指定多个异常类，方法是将它们放在元组中。如果<br>向except提供两个参数，第二个参数将关联到异常对象。在同一条try&#x2F;except语句中，可<br>包含多个except子句，以便对不同的异常采取不同的措施。</li><li>else子句：除except子句外，你还可使用else子句，它在主try块没有引发异常时执行。</li><li>finally：要确保代码块(如清理代码)无论是否引发异常都将执行，可使用try&#x2F;finally，<br>并将代码块放在finally子句中。</li><li>异常和函数：在函数中引发异常时，异常将传播到调用函数的地方(对方法来说亦如此)。</li><li>警告：警告类似于异常，但(通常)只打印一条错误消息。你可指定警告类别，它们是<br>Warning的子类。</li></ul><h2 id="魔法方法、特性和迭代器"><a href="#魔法方法、特性和迭代器" class="headerlink" title="魔法方法、特性和迭代器"></a>魔法方法、特性和迭代器</h2><p>还是跟C++一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重写普通方法和特殊的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SongBird</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.sound = <span class="string">&#x27;Squawk!&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.sound)</span><br></pre></td></tr></table></figure><h3 id="INIT"><a href="#INIT" class="headerlink" title="INIT"></a>INIT</h3><h4 id="调用未关联的超类构造函数"><a href="#调用未关联的超类构造函数" class="headerlink" title="调用未关联的超类构造函数"></a>调用未关联的超类构造函数</h4><p>本节介绍的方法主要用于解决历史遗留问题。在较新的Python版本中，显然应使用函数<br>super（这将在下一节讨论）。然而，很多既有代码使用的都是本节介绍的方法，因此你必须对<br>其有所了解。另外，这种方法也极具启迪意义，淋漓尽致地说明了关联方法和未关联方法之间<br>的差别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SongBird</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Bird.__init__(self)</span><br><span class="line">        self.sound = <span class="string">&#x27;Squawk!&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.sound)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在SongBird类中，只添加了一行，其中包含代码<code>Bird.__init__(self)。</code>先来证明这确实管用，<br>再解释这到底意味着什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb = SongBird()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb.sing()</span><br><span class="line">Squawk!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb.eat()</span><br><span class="line">Aaaah    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb.eat()</span><br><span class="line">No, thanks!</span><br></pre></td></tr></table></figure><p>这样做为何管用呢？对实例调用方法时，方法的参数self将自动关联到实例（称为关联的方<br>法），这样的示例你见过多个。然而，如果你通过类调用方法（如<code>Bird.__init__</code>），就没有实例<br>与其相关联。在这种情况下，你可随便设置参数self。这样的方法称为未关联的。这就对本节的<br>标题做出了解释。<br>通过将这个未关联方法的self参数设置为当前实例，将使用超类的构造函数来初始化<br>SongBird对象。这意味着将设置其属性hungry。</p><h4 id="使用函数-super"><a href="#使用函数-super" class="headerlink" title="使用函数 super"></a>使用函数 super</h4><p>在Python3中调用函数super时，可不提供任何参数（通常也应该这样做），而它将<br>像变魔术一样完成任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.hungry = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.hungry:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Aaaah    &#x27;</span>)</span><br><span class="line">        self.hungry = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No, thanks!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SongBird</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.sound = <span class="string">&#x27;Squawk!&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.sound)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个新式版本与旧式版本等效：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb = SongBird()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb.sing()</span><br><span class="line">Squawk!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb.eat()</span><br><span class="line">Aaaah    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb.eat()</span><br><span class="line">No, thanks!</span><br></pre></td></tr></table></figure><h4 id="使用函数super有何优点"><a href="#使用函数super有何优点" class="headerlink" title="使用函数super有何优点"></a>使用函数super有何优点</h4><p>在我看来，相比于直接对超类调用未关联方法，使用函数super更直观，但这并非其唯一<br>的优点。实际上，函数super很聪明，因此即便有多个超类，也只需调用函数super一次（条件<br>是所有超类的构造函数也使用函数super）。另外，对于使用旧式类时处理起来很棘手的问题<br>（如两个超类从同一个类派生而来），在使用新式类和函数super时将自动得到处理。你无需知<br>道函数super的内部工作原理，但必须知道的是，使用函数super比调用超类的未关联构造函<br>数（或其他方法）要好得多。<br>函数super返回的到底是什么呢？通常，你无需关心这个问题，只管假定它返回你所需的<br>超类即可。实际上，它返回的是一个super对象，这个对象将负责为你执行方法解析。当你访<br>问它的属性时，它将在所有的超类（以及超类的超类，等等）中查找，直到找到指定的属性或<br>引发AttributeError异常。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><h4 id="基本的序列和映射协议"><a href="#基本的序列和映射协议" class="headerlink" title="基本的序列和映射协议"></a>基本的序列和映射协议</h4><p>序列和映射基本上是元素（ item）的集合，要实现它们的基本行为（协议），不可变对象需<br>要实现2个方法，而可变对象需要实现4个。</p><ul><li><strong>len</strong>(self)：这个方法应返回集合包含的项数，对序列来说为元素个数，对映射来说<br>为键值对数。如果__len__返回零（且没有实现覆盖这种行为的__nonzero__），对象在布<br>尔上下文中将被视为假（就像空的列表、元组、字符串和字典一样）。</li><li><strong>getitem</strong>(self, key)：这个方法应返回与指定键相关联的值。对序列来说，键应该是<br>0~n-1的整数（也可以是负数，这将在后面说明），其中n为序列的长度。对映射来说，<br>键可以是任何类型。</li><li><strong>setitem</strong>(self, key, value)：这个方法应以与键相关联的方式存储值，以便以后能够<br>使用__getitem__来获取。当然，仅当对象可变时才需要实现这个方法。</li><li><strong>delitem</strong>(self, key)：这个方法在对对象的组成部分使用__del__语句时被调用，应<br>删除与key相关联的值。同样，仅当对象可变（且允许其项被删除）时，才需要实现这个<br>方法。<br>对于这些方法，还有一些额外的要求。</li><li>对于序列，如果键为负整数，应从末尾往前数。换而言之， x[-n]应与x[len(x)-n]等效。</li><li>如果键的类型不合适（如对序列使用字符串键），可能引发TypeError异常。</li><li>对于序列，如果索引的类型是正确的，但不在允许的范围内，应引发IndexError异常。</li></ul><h4 id="从-list、-dict-和-str-派生"><a href="#从-list、-dict-和-str-派生" class="headerlink" title="从 list、 dict 和 str 派生"></a>从 list、 dict 和 str 派生</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args)</span><br><span class="line">        self.counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        self.counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(CounterList, self).__getitem__(index)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl = CounterList(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cl[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl.counter</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl[<span class="number">4</span>] + cl[<span class="number">2</span>]</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cl.counter</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他魔法方法"><a href="#其他魔法方法" class="headerlink" title="其他魔法方法"></a>其他魔法方法</h3><p>特殊（魔法）名称的用途很多，前面展示的只是冰山一角。魔法方法大多是为非常高级的用<br>途准备的，因此这里不详细介绍。</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><h4 id="函数-property"><a href="#函数-property" class="headerlink" title="函数 property"></a>函数 property</h4><p>看不懂,再议</p><h4 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h4><p>在Python 2.4中，引入了一种名为装饰器的新语法，<br>可用于像这样包装方法。（实际上，装饰器可用于包装任何可调用的对象，并且可用于方法和函<br>数。）可指定一个或多个装饰器，为此可在方法（或函数）前面使用运算符@列出这些装饰器（指<br>定了多个装饰器时，应用的顺序与列出的顺序相反）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smeth</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a static method&#x27;</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cmeth</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a class method of&#x27;</span>, cls)</span><br><span class="line"><span class="comment"># 定义这些方法后，就可像下面这样使用它们（无需实例化类）：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass.smeth()</span><br><span class="line">This <span class="keyword">is</span> a static method</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass.cmeth()</span><br><span class="line">This <span class="keyword">is</span> a <span class="keyword">class</span> <span class="title class_">method</span> of &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.MyClass&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Python中，静态方法和类方法以前一直都不太重要，主要是因为从某种程度上说，总是可<br>以使用函数或关联的方法替代它们，而且早期的Python版本并不支持它们。因此，虽然较新的代<br>码没有大量使用它们，但它们确实有用武之地（如工厂函数），因此你或许应该考虑使用它们。</p><h4 id="getattr-、-setattr-等方法"><a href="#getattr-、-setattr-等方法" class="headerlink" title="__getattr__、__setattr__等方法"></a><code>__getattr__</code>、<code>__setattr__</code>等方法</h4><p>可以拦截对对象属性的所有访问企图，其用途之一是在旧式类中实现特性（在旧式类中，函<br>数property的行为可能不符合预期）。要在属性被访问时执行一段代码，必须使用一些魔法方法。<br>下面的四个魔法方法提供了你需要的所有功能（在旧式类中，只需使用后面三个）。</p><ul><li><strong>getattribute</strong>(self, name)：在属性被访问时自动调用（只适用于新式类）。</li><li><strong>getattr</strong>(self, name)：在属性被访问而对象没有这样的属性时自动调用。</li><li><strong>setattr</strong>(self, name, value)：试图给属性赋值时自动调用。</li><li><strong>delattr</strong>(self, name)：试图删除属性时自动调用。<br>相比函数property，这些魔法方法使用起来要棘手些（从某种程度上说，效率也更低），但<br>它们很有用，因为你可在这些方法中编写处理多个特性的代码。然而，在可能的情况下，还是使<br>用函数property吧。<br>再来看前面的Rectangle示例，但这里使用的是魔法方法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        self.width = <span class="number">0</span></span><br><span class="line">        self.height = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;size&#x27;</span>:</span><br><span class="line">            self.width, self.height = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self. __dict__[name] = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;size&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.width, self.height</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError()</span><br></pre></td></tr></table></figure> 如你所见，这个版本需要处理额外的管理细节。对于这个代码示例，需要注意如下两点。</li><li>即便涉及的属性不是size，也将调用方法__setattr__。因此这个方法必须考虑如下两种<br>情形：如果涉及的属性为size，就执行与以前一样的操作；否则就使用魔法属性__dict__。<br>__dict__属性是一个字典，其中包含所有的实例属性。之所以使用它而不是执行常规属性<br>赋值，是因为旨在避免再次调用__setattr__，进而导致无限循环。</li><li>仅当没有找到指定的属性时，才会调用方法__getattr__。这意味着如果指定的名称不是<br>size，这个方法将引发AttributeError异常。这在要让类能够正确地支持hasattr和getattr<br>等内置函数时很重要。如果指定的名称为size，就使用前一个实现中的表达式。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>本书前面粗略地提及了迭代器（和可迭代对象），本节将更详细地介绍。对于魔法方法，这<br>里只介绍__iter__，它是迭代器协议的基础。</p><h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4><p>迭代（ iterate）意味着重复多次，就像循环那样。本书前面只使用for循环迭代过序列和字典，<br>但实际上也可迭代其他对象：实现了方法__iter__的对象。</p><p>方法__iter__返回一个迭代器，它是包含方法__next__的对象，而调用这个方法时可不提供<br>任何参数。当你调用方法__next__时，迭代器应返回其下一个值。如果迭代器没有可供返回的值，<br>应引发StopIteration异常。你还可使用内置的便利函数next，在这种情况下， next(it)与<br>it.<strong>next</strong>()等效。</p><p>这有什么意义呢？为何不使用列表呢？因为在很多情况下，使用列表都有点像用大炮打蚊<br>子。例如，如果你有一个可逐个计算值的函数，你可能只想逐个地获取值，而不是使用列表一次<br>性获取。这是因为如果有很多值，列表可能占用太多的内存。但还有其他原因：使用迭代器更通<br>用、更简单、更优雅。下面来看一个不能使用列表的示例，因为如果使用，这个列表的长度必须<br>是无穷大的！</p><p>这个“列表”为斐波那契数列，表示该数列的迭代器如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibs</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>注意到这个迭代器实现了方法__iter__，而这个方法返回迭代器本身。在很多情况下，都在<br>另一个对象中实现返回迭代器的方法__iter__，并在for循环中使用这个对象。但推荐在迭代器<br>中也实现方法__iter__（并像刚才那样让它返回self），这样迭代器就可直接用于for循环中。</p><p>首先，创建一个Fibs对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibs = Fibs()</span><br><span class="line">然后就可在<span class="keyword">for</span>循环中使用这个对象，如找出第一个大于<span class="number">1000</span>的斐波那契数。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> fibs:</span><br><span class="line">    <span class="keyword">if</span> f &gt; <span class="number">1000</span>:</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line"><span class="number">1597</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个循环之所以会停止，是因为其中包含break语句；否则，这个for循环将没完没了地执行。</p><h4 id="从迭代器创建序列"><a href="#从迭代器创建序列" class="headerlink" title="从迭代器创建序列"></a>从迭代器创建序列</h4><p>除了对迭代器和可迭代对象进行迭代（通常这样做）之外，还可将它们转换为序列。在可以<br>使用序列的情况下，大多也可使用迭代器或可迭代对象（诸如索引和切片等操作除外）。一个这<br>样的例子是使用构造函数list显式地将迭代器转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">TestIterator</span>:</span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            self.value += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.value &gt; <span class="number">10</span>: <span class="keyword">raise</span> StopIteration</span><br><span class="line">            <span class="keyword">return</span> self.value</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ti = TestIterator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(ti)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是一个相对较新的Python概念。由于历史原因，它也被称为简单生成器（ simple<br>generator）。生成器和迭代器可能是近年来引入的最强大的功能，但生成器是一个相当复杂的概<br>念，你可能需要花些功夫才能明白其工作原理和用途。虽然生成器让你能够编写出非常优雅的代<br>码，但请放心，无论编写什么程序，都完全可以不使用生成器。<br>生成器是一种使用普通函数语法定义的迭代器。生成器的工作原理到底是什么呢？通过示例<br>来说明最合适。下面先来看看如何创建和使用生成器，然后再看看幕后的情况。</p><h4 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h4><p>生成器创建起来与函数一样简单。你现在肯定厌烦了老套的斐波那契数列，所以下面换换口<br>味，创建一个将嵌套列表展开的函数。这个函数将一个类似于下面的列表作为参数：</p><p><code>nested = [[1, 2], [3, 4], [5]]</code></p><p>换而言之，这是一个列表的列表。函数应按顺序提供这些数字，下面是一种解决方案：160 第 9 章 魔法方法、特性和迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">nested</span>):</span><br><span class="line">    <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> sublist:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure><p>这个函数的大部分代码都很简单。它首先迭代所提供嵌套列表中的所有子列表，然后按顺序<br>迭代每个子列表的元素。倘若最后一行为print(element)，这个函数将容易理解得多，不是吗？</p><p>在这里，你没有见过的是yield语句。包含yield语句的函数都被称为生成器。这可不仅仅是<br>名称上的差别，生成器的行为与普通函数截然不同。差别在于，<em>生成器不是使用return返回一个值，而是可以生成多个值，每次一个。</em>每次使用yield生成一个值后，函数都将冻结，即在此停<br>止执行，等待被重新唤醒。被重新唤醒后，函数将从停止的地方开始继续执行。<br>为使用所有的值，可对生成器进行迭代。</p><blockquote><blockquote><blockquote><p>nested &#x3D; [[1, 2], [3, 4], [5]]<br>for num in flatten(nested):<br>… print(num)<br>…<br>1<br>2<br>3<br>4<br>5<br>或<br>list(flatten(nested))<br>[1, 2, 3, 4, 5]</p></blockquote></blockquote></blockquote><h4 id="递归式生成器"><a href="#递归式生成器" class="headerlink" title="递归式生成器"></a>递归式生成器</h4><p>前一节设计的生成器只能处理两层的嵌套列表，这是使用两个for循环来实现的。如果要处<br>理任意层嵌套的列表，该如何办呢？例如，你可能使用这样的列表来表示树结构（也可以使用特<br>定的树类，但策略是相同的）。对于每层嵌套，都需要一个for循环，但由于不知道有多少层嵌套，<br>你必须修改解决方案，使其更灵活。该求助于递归了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">nested</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> flatten(sublist):</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">yield</span> nested</span><br></pre></td></tr></table></figure><p>调用flatten时，有两种可能性（处理递归时都如此）： 基线条件和递归条件。在基线条件下，<br>要求这个函数展开单个元素（如一个数）。在这种情况下， for循环将引发TypeError异常（因为<br>你试图迭代一个数），而这个生成器只生成一个元素。</p><p>然而，如果要展开的是一个列表（或其他任何可迭代对象），你就需要做些工作：遍历所有<br>的子列表（其中有些可能并不是列表）并对它们调用flatten，然后使用另一个for循环生成展开<br>后的子列表中的所有元素。这可能看起来有点不可思议，但确实可行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(flatten([[[<span class="number">1</span>], <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]], <span class="number">8</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>然而，这个解决方案存在一个问题。如果nested是字符串或类似于字符串的对象，它就属于<br>序列，因此不会引发TypeError异常，可你并不想对其进行迭代。</p><p>要处理这种问题，必须在生成器开头进行检查。要检查对象是否类似于字符串，最简单、最<br>快捷的方式是，尝试将对象与一个字符串拼接起来，并检查这是否会引发TypeError异常①。添加<br>这种检查后的生成器如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">nested</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 不迭代类似于字符串的对象：</span></span><br><span class="line">        <span class="keyword">try</span>: nested + <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">except</span> TypeError: <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">raise</span> TypeError</span><br><span class="line">        <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> flatten(sublist):</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">yield</span> nested</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如你所见，如果表达式nested + ‘’引发了TypeError异常，就忽略这种异常；如果没有引发<br>TypeError异常，内部try语句中的else子句将引发TypeError异常，这样将在外部的excpet子句中<br>原封不动地生成类似于字符串的对象。明白了吗？<br>下面的示例表明，这个版本也可用于字符串：</p><blockquote><blockquote><blockquote><p>list(flatten([‘foo’, [‘bar’, [‘baz’]]]))<br>[‘foo’, ‘bar’, ‘baz’]<br>请注意，这里没有执行类型检查：我没有检查nested是否是字符串，而只是检查其行为是否<br>类似于字符串，即能否与字符串拼接。对于这种检查，一种更自然的替代方案是，使用isinstance<br>以及字符串和类似于字符串的对象的一些抽象超类，但遗憾的是没有这样的标准类。另外，即便<br>是对UserString来说，也无法检查其类型是否为str。</p></blockquote></blockquote></blockquote><h4 id="通用生成器"><a href="#通用生成器" class="headerlink" title="通用生成器"></a>通用生成器</h4><p>如果你按前面的例子做了，就差不多知道了如何使用生成器。你知道，生成器是包含关键字<br>yield的函数，但被调用时不会执行函数体内的代码，而是返回一个迭代器。每次请求值时，都<br>将执行生成器的代码，直到遇到yield或return。 yield意味着应生成一个值，而return意味着生<br>成器应停止执行（即不再生成值；仅当在生成器调用return时，才能不提供任何参数）。</p><p>换而言之，生成器由两个单独的部分组成： 生成器的函数和生成器的迭代器。生成器的函数<br>是由def语句定义的，其中包含yield。生成器的迭代器是这个函数返回的结果。用不太准确的话<br>说，这两个实体通常被视为一个，通称为生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">simple_generator</span>():</span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simple_generator</span><br><span class="line">&lt;function simple_generator at 153b44&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simple_generator()</span><br><span class="line">&lt;generator <span class="built_in">object</span> at <span class="number">15</span>10b0&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于生成器的函数返回的迭代器，可以像使用其他迭代器一样使用它</p><h4 id="生成器的方法"><a href="#生成器的方法" class="headerlink" title="生成器的方法"></a>生成器的方法</h4><p>在生成器开始运行后，可使用生成器和外部之间的通信渠道向它提供值。这个通信渠道包含<br>如下两个端点。</p><ul><li>外部世界：外部世界可访问生成器的方法send，这个方法类似于next， 但接受一个参数（要<br>发送的“消息”，可以是任何对象）。</li><li>生成器：在挂起的生成器内部， yield可能用作表达式而不是语句。换而言之，当生成器重新运行时， yield返回一个值——通过send从外部世界发送的值。如果使用的是next，<br>yield将返回None。<br>请注意，仅当生成器被挂起（即遇到第一个yield）后，使用send（而不是next）才有意义。<br>要在此之前向生成器提供信息，可使用生成器的函数的参数。</li></ul><p>生成器还包含另外两个方法。<br>方法throw：用于在生成器中（ yield表达式处）引发异常，调用时可提供一个异常类型、一<br>个可选值和一个traceback对象。<br>方法close：用于停止生成器，调用时无需提供任何参数。<br>方 法 close （ 由 Python 垃圾收 集 器在 需要 时 调用 ）也 是 基于 异常 的 ：在 yield 处 引 发<br>GeneratorExit异常。因此如果要在生成器中提供一些清理代码，可将yield放在一条try&#x2F;finally<br>语句中。如果愿意，也可捕获GeneratorExit异常，但随后必须重新引发它（可能在清理后）、引<br>发其他异常或直接返回。对生成器调用close后，再试图从它那里获取值将导致RuntimeError异常。</p><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>学习各种魔法方法后，该付诸应用了。本节将演示如何使用生成器来解决一个经典的编程<br>问题。</p><p>对于逐步得到结果的复杂递归算法，非常适合使用生成器来实现。要在不使用生成器的情况<br>下实现这些算法，通常必须通过额外的参数来传递部分结果，让递归调用能够接着往下计算。通<br>过使用生成器，所有的递归调用都只需生成其负责部分的结果。前面的递归版flatten就是这样<br>做的，你可使用这种策略来遍历图结构和树结构。<br>然而，在有些应用程序中，你不能马上得到答案。你必须尝试多次，且在每个递归层级中都<br>如此。打个现实生活中的比方吧，假设你要去参加一个很重要的会议。你不知道会议在哪里召开，<br>但前面有两扇门，而会议室就在其中一扇门的后面。你选择进入左边那扇门后，又看到两扇门。<br>你再次选择进入左边那扇门，但发现走错了。因此你往回走，并进入右边那扇门，但发现也走错<br>了。因此你继续往回走到起点，现在可以尝试进入右边那扇门。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这是一个深受大家喜爱的计算机科学谜题：你需要将8个皇后放在棋盘上，条件是任何一个<br>皇后都不能威胁其他皇后，即任何两个皇后都不能吃掉对方。怎样才能做到这一点呢？应将这些<br>皇后放在什么地方呢？<br>这是一个典型的回溯问题：在棋盘的第一行尝试为第一个皇后选择一个位置，再在第二行尝<br>试为第二个皇后选择一个位置，依次类推。在发现无法为一个皇后选择合适的位置后，回溯到前<br>一个皇后，并尝试为它选择另一个位置。最后，要么尝试完所有的可能性，要么找到了答案。<br>在前面描述的问题中，只有8个皇后，但这里假设可以有任意数量的皇后，从而更像现实世<br>界的回溯问题。如何解决这个问题呢？如果你想自己试一试，就不要再往下读了，因为马上就会<br>提供解决方案。</p><ul><li>注意 对于这个问题，可找到效率高得多的解决方案。如果你想深入了解，在网上搜索就可找到大量的信息。</li></ul><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p>可简单地使用元组（或列表）来表示可能的解（或其一部分），其中每个元素表示相应行中<br>皇后所在的位置（即列）。因此，如果state[0] &#x3D;&#x3D; 3，就说明第1行的皇后放在第4列（还记得吧，<br>我们从0开始计数）。在特定的递归层级（特定的行），你只知道上面各皇后的位置，因此状态元<br>组的长度小于8（即皇后总数）。</p><h4 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h4><p>先来做些简单的抽象。要找出没有冲突（即任何一个皇后都吃不到其他皇后）的位置组合，<br>首先必须定义冲突是什么。为何不使用一个函数来定义呢？<br>函数conflict接受（用状态元组表示的）既有皇后的位置，并确定下一个皇后的位置是否会<br>导致冲突。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conflict</span>(<span class="params">state, nextX</span>):</span><br><span class="line">    nextY = <span class="built_in">len</span>(state)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nextY):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>, nextY - i):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>参数nextX表示下一个皇后的水平位置（ x坐标，即列），而nextY为下一个皇后的垂直位置（ y<br>坐标，即行）。这个函数对既有的每个皇后执行简单的检查：如果下一个皇后与当前皇后的x坐标<br>相同或在同一条对角线上，将发生冲突，因此返回True；如果没有发生冲突，就返回False。比<br>较难理解的是下面的表达式：<br><code>abs(state[i] - nextX) in (0, nextY - i)</code><br>如果下一个皇后和当前皇后的水平距离为0（在同一列）或与它们的垂直距离相等（位于一<br>条对角线上），这个表达式就为真；否则为假。</p><h4 id="基线条件"><a href="#基线条件" class="headerlink" title="基线条件"></a>基线条件</h4><p>八皇后问题解决起来有点棘手，但通过使用生成器并不太难。然而，如果你不熟悉递归，就<br>很难自己想出这里的解决方案。另外，这个解决方案的效率不是特别高，因此皇后非常多时，其<br>速度可能有点慢。<br>下面先来看基线条件：最后一个皇后。对于这个皇后，你想如何处理呢？假设你想找出所有<br>可能的解——给定其他皇后的位置，可将这个皇后放在什么位置（可能什么位置都不行）？可以<br>这样编写代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">queens</span>(<span class="params">num, state</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(state) == num-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</span><br><span class="line">                <span class="keyword">yield</span> pos</span><br></pre></td></tr></table></figure><p>这段代码的意思是，如果只剩下最后一个皇后没有放好，就遍历所有可能的位置，并返回那<br>些不会引发冲突的位置。参数num为皇后总数，而参数state是一个元组，包含已放好的皇后的位<br>置。例如，假设总共有4个皇后，而前3个皇后的位置分别为1、 3和0，如图9-1所示。（现在不用<br>关心白色的皇后。）<br><img src="/images/others/Python_study.md/2022-08-13-15-32-46.png"></p><p>从该图可知，每个皇后都占据一行，而皇后的位置是从0开始编号的（ Python中通常如此）。</p><p><code>&gt;&gt;&gt; list(queens(4, (1, 3, 0)))</code></p><p>代码的效果很好。这里使用list旨在让生成器生成所有的值。在这个示例中，只有一个位置<br>符合条件。在图9-1中，在这个位置放置了一个白色皇后。（请注意，颜色没有什么特殊含义，不<br>是程序的一部分。）</p><h4 id="递归条件"><a href="#递归条件" class="headerlink" title="递归条件"></a>递归条件</h4><p>现在来看看这个解决方案的递归部分。处理好基线条件后，可在递归条件中假设来自更低层级（编号更大的皇后）的结果都是正确的。因此，只需在函数queens的前述实现中给if语句添加<br>一个else子句。<br>你希望递归调用返回什么样的结果呢？你希望它返回当前行下面所有皇后的位置，对吧？假<br>设位置是以元组的方式返回的，因此需要修改基线条件，使其返回一个（长度为1的）元组，但<br>这将在后面处理。<br>因此，对于递归调用，向它提供的是由当前行上面的皇后位置组成的元组。对于当前皇后的<br>每个合法位置，递归调用返回的是由下面的皇后位置组成的元组。为了让这个过程不断进行下去，<br>只需将当前皇后的位置插入返回的结果开头，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> queens(num, state + (pos,)):</span><br><span class="line">                <span class="keyword">yield</span> (pos,) + result</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的for pos和if not conflict部分与前面相同，因此可以稍微简化一下代码。另外，还<br>可给参数指定默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">queens</span>(<span class="params">num=<span class="number">8</span>, state=(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state) == num-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">yield</span> (pos,)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num, state + (pos,)):</span><br><span class="line">                    <span class="keyword">yield</span> (pos,) + result</span><br></pre></td></tr></table></figure><p>如果你觉得这些代码难以理解，用自己的话来描述其作用可能会有所帮助。另外，你可能还<br>记得(pos,)中的逗号必不可少（不能仅用圆括号将pos括起），这样得到的才是元组。<br>生成器queens提供了所有的解（即所有合法的皇后位置组合）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(queens(<span class="number">3</span>))</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(queens(<span class="number">4</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> solution <span class="keyword">in</span> queens(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> solution</span><br><span class="line">...</span><br><span class="line">(<span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">7</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果运行queens时将参数num设置为8，将快速显示大量的解。下面看看有多少个解。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">list</span>(queens(<span class="number">8</span>)))</span><br><span class="line"><span class="number">92</span></span><br></pre></td></tr></table></figure><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>本章介绍的内容很多，下面来总结一下。</p><ul><li>新式类和旧式类： Python类的工作方式在不断变化。较新的Python 2版本有两种类，其中<br>旧式类正在快速退出舞台。新式类是Python 2.2引入的，提供了一些额外的功能，如支持<br>函数super和property，而旧式类不支持。要创建新式类，必须直接或间接地继承object<br>或设置__metaclass__。</li><li>魔法方法： Python中有很多特殊方法，其名称以两个下划线开头和结尾。这些方法的功能<br>各不相同，但大都由Python在特定情况下自动调用。 例如__init__是在对象创建后调用的。</li><li>构造函数：很多面向对象语言中都有构造函数，对于你自己编写的每个类，都可能需要<br>为它实现一个构造函数。构造函数名为__init__，在对象创建后被自动调用。</li><li>重写：类可重写其超类中定义的方法（以及其他任何属性），为此只需实现这些方法即可。<br>要调用被重写的版本，可直接通过超类调用未关联版本（旧式类），也可使用函数super<br>来调用（新式类）。</li><li>序列和映射：要创建自定义的序列或映射，必须实现序列和映射协议指定的所有方法，<br>其中包括__getitem__和__setitem__等魔法方法。通过从list（或UserList）和dict（或<br>UserDict）派生，可减少很多工作量。</li><li>迭代器：简单地说， 迭代器是包含方法__next__的对象，可用于迭代一组值。没有更多的<br>值可供迭代时，方法__next__应引发StopIteration异常。 可迭代对象包含方法__iter__，<br>它返回一个像序列一样可用于for循环中的迭代器。通常，迭代器也是可迭代的，即包含<br>返回迭代器本身的方法__iter__。</li><li>生成器： 生成器的函数是包含关键字yield的函数，它在被调用时返回一个生成器，即一<br>种特殊的迭代器。要与活动的生成器交互，可使用方法send、 throw和close。</li><li>八皇后问题：八皇后问题是个著名的计算机科学问题，使用生成器可轻松地解决它。这<br>个问题要求在棋盘上放置8个皇后，并确保任何两个皇后都不能相互攻击。</li></ul><h3 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h3><p>至此，你学习了Python语言的大部分知识，但为何本书后面还有这么多章呢？因为需要学习<br>的知识还有很多，大都是关于Python如何以各种方式与外部联系的。另外，还有测试、扩展、打<br>包和一些具体项目。本书还远没有到结束的时候。</p><h2 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><div class="post__license"><p> <strong>本文作者：</strong>wxy</p><p> <strong>本文链接：</strong> <a href="https://c.undf.top/posts/3ahvaci/">https://c.undf.top/posts/3ahvaci/</a></p><strong><p>文章默认使用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议进行许可，使用时请注意遵守协议。</p></strong><strong><p>本站不设评论,网站底部邮件图标可以联系博主</p></strong></div><div class="post-entry__tags"></div></article><div class="nav"><div class="nav__prev"></div><div class="nav__next"><a href="/posts/49u3l9/" class="nav__link"><div><div class="nav__label"> Next Post</div><div class="nav__title"> cloudreve配置修复</div></div><div><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg></div></a></div></div></main><footer class="footer"> <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32"><path d="M233.376 722.752 278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path></svg></a><p><img src="https://c.undf.top/cdn/%E5%A4%87%E6%A1%88.png"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602011871">浙公网安备33010602011937号</a></p><p><a target="_blank" href="http://beian.miit.gov.cn/">浙ICP备2021022005号</a></p><p class="footer-copyright"> 2021&nbsp; <a target="_blank" href="mailto:1798923421@qq.com">📧</a> &nbsp;2022</p><p><a href="https://hexo.io" target="_blank">Hexo</a> | <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p><p><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="https://image.wxydejoy.top/image/STM32&Cubeide/又拍云_logo5-2022-05-22.png" style="width:5rem"></a></p></footer></div><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5737bfc954e9ae8ece59f5df2faa6540";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>