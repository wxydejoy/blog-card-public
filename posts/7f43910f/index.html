<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="shortcut icon" href="/icon/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/icon/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/icon/favicon-32x32.png"><link rel="apple-touch-icon" sizes="180x180" href="/icon/apple-touch-icon-180x180.png"><link rel="mask-icon" href="/icon/apple-touch-icon-180x180.png"><title>OMPL开源轨迹规划库 | 沐印小站</title><meta name="keywords" content="🦾ROS2, 沐印"><meta name="description" content="下面列出的所有实现都被视为功能齐全。在OMPL中，规划器分为三类:  几何规划器 基于控制的规划器 基于多层次的规划器  要了解如何对规划器进行基准测试，请单击 此处 。 实例图册部分没图就是当时没求解出来ABITstarFMTLBKPIECE1RRTSPARStwoAITstarinformedRRTstarLBTRRTRRTsharpSSTBFMTKPIECE1PDSTRRTstarSTRID"><meta property="og:type" content="article"><meta property="og:title" content="OMPL开源轨迹规划库"><meta property="og:url" content="https://c.undf.top/posts/7f43910f/index.html"><meta property="og:site_name" content="沐印小站"><meta property="og:description" content="下面列出的所有实现都被视为功能齐全。在OMPL中，规划器分为三类:  几何规划器 基于控制的规划器 基于多层次的规划器  要了解如何对规划器进行基准测试，请单击 此处 。 实例图册部分没图就是当时没求解出来ABITstarFMTLBKPIECE1RRTSPARStwoAITstarinformedRRTstarLBTRRTRRTsharpSSTBFMTKPIECE1PDSTRRTstarSTRID"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.undf.top/image/ros2_urdf/uu-2023-09-28.png"><meta property="article:published_time" content="2023-09-28T11:05:00.000Z"><meta property="article:modified_time" content="2023-09-28T11:05:00.000Z"><meta property="article:author" content="wxy"><meta property="article:tag" content="🦾ROS2"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img.undf.top/image/ros2_urdf/uu-2023-09-28.png"><link rel="stylesheet" href="/css/style/main.css"><link rel="stylesheet" id="hl-default-theme" href="/css/highlight/atom-one-dark.css" media="none" onload='this.media="all"'><script src="https://c.undf.top/cdn/haoke/haoke.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="沐印小站" type="application/atom+xml"></head><body><div id="app"><header class="header"><div class="header__left"> <a href="/" class="button"><span class="logo__text">Hi</span></a></div><div class="header__right"><div class="navbar__menus"> <a href="/" class="navbar-menu button">首页</a> <a href="/tags/" class="navbar-menu button">标签</a> <a href="/search/" class="navbar-menu button">搜索</a> <a href="/movies/" class="navbar-menu button">影单</a> <a href="/xy/" class="navbar-menu button">闲言</a> <a href="/friend/" class="navbar-menu button">友链</a></div> <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="24" height="24" fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314 4.8h13.372c.41 0 .743-.333.743-.743 0-.41-.333-.743-.743-.743H3.314c-.41 0-.743.333-.743.743C2.571 4.467 2.904 4.8 3.314 4.8zM16.686 15.2H3.314c-.41 0-.743.333-.743.743s.333.743.743.743h13.372c.41 0 .743-.333.743-.743S17.096 15.2 16.686 15.2zM16.686 9.257H3.314c-.41 0-.743.333-.743.743s.333.743.743.743h13.372c.41 0 .743-.333.743-.743S17.096 9.257 16.686 9.257z"></path></svg></a><div class="dropdown-menus" id="dropdown-menus"> <a href="/" class="dropdown-menu button">首页</a> <a href="/tags/" class="dropdown-menu button">标签</a> <a href="/search/" class="dropdown-menu button">搜索</a> <a href="/movies/" class="dropdown-menu button">影单</a> <a href="/xy/" class="dropdown-menu button">闲言</a> <a href="/friend/" class="dropdown-menu button">友链</a></div></div></header><main class="main"><aside class="post-side"><div class="post-side__toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%9B%BE%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">实例图册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E8%A7%84%E5%88%92%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">几何规划器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">其他工具:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A7%E5%88%B6%E7%9A%84%E8%A7%84%E5%88%92%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">基于控制的规划器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E8%A7%84%E5%88%92%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">基于多层次的规划器</span></a></li></ol></div></aside> <a class="btn-toc button" id="btn-toc" tabindex="0"><svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg"><path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path></svg></a><div class="toc-menus" id="toc-menus"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%9B%BE%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">实例图册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E8%A7%84%E5%88%92%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">几何规划器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">其他工具:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A7%E5%88%B6%E7%9A%84%E8%A7%84%E5%88%92%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">基于控制的规划器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E8%A7%84%E5%88%92%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">基于多层次的规划器</span></a></li></ol></div><article class="post post__with-toc content-card"><div class="post__header"><a href="/posts/7f43910f/"><div class="post-thumbnail" style="background-image:url(https://img.undf.top/image/ros2_urdf/uu-2023-09-28.png)"></div></a><div class="post__expire" id="post-expired-notify"><p> 本文最后更新于 &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; 天前，文中部分描述可能已经过时。</p></div><script>
        (() => {
            var update = Date.parse("2023-09-28"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script></div><div class="post__content"><p>下面列出的所有实现都被视为功能齐全。在OMPL中，规划器分为三类:</p><ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.html#geometric_planners">几何规划器</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.html#control_planners">基于控制的规划器</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.html#multilevel_planners">基于多层次的规划器</a></li></ul><p>要了解如何对规划器进行基准测试，请单击 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/benchmark.html">此处</a> 。</p><h2 id="实例图册"><a href="#实例图册" class="headerlink" title="实例图册"></a>实例图册</h2><p>部分没图就是当时没求解出来<br>ABITstar<br><img src="https://img.undf.top/ompl/ABITstar.png" alt="ABITstar"><br>FMT<br><img src="https://img.undf.top/ompl/FMT.png" alt="FMT"><br>LBKPIECE1<br><img src="https://img.undf.top/ompl/LBKPIECE1.png" alt="LBKPIECE1"><br>RRT<br><img src="https://img.undf.top/ompl/RRT.png" alt="RRT"><br>SPARStwo<br><img src="https://img.undf.top/ompl/SPARStwo.png" alt="SPARStwo"><br>AITstar<br><img src="https://img.undf.top/ompl/AITstar.png" alt="AITstar"><br>informedRRTstar<br><img src="https://img.undf.top/ompl/informedRRTstar.png" alt="informedRRTstar"><br>LBTRRT<br><img src="https://img.undf.top/ompl/LBTRRT.png" alt="LBTRRT"><br>RRTsharp<br><img src="https://img.undf.top/ompl/RRTsharp.png" alt="RRTsharp"><br>SST<br><img src="https://img.undf.top/ompl/SST.png" alt="SST"><br>BFMT<br><img src="https://img.undf.top/ompl/BFMT.png" alt="BFMT"><br>KPIECE1<br><img src="https://img.undf.top/ompl/KPIECE1.png" alt="KPIECE1"><br>PDST<br><img src="https://img.undf.top/ompl/PDST.png" alt="PDST"><br>RRTstar<br><img src="https://img.undf.top/ompl/RRTstar.png" alt="RRTstar"><br>STRIDE<br><img src="https://img.undf.top/ompl/STRIDE.png" alt="STRIDE"><br>BiEST<br><img src="https://img.undf.top/ompl/BiEST.png" alt="BiEST"><br>lazyLBTRRT<br><img src="https://img.undf.top/ompl/lazyLBTRRT.png" alt="lazyLBTRRT"><br>PRM<br><img src="https://img.undf.top/ompl/PRM.png" alt="PRM"><br>RRTXstatic<br><img src="https://img.undf.top/ompl/RRTXstatic.png" alt="RRTXstatic"><br>TRRT<br><img src="https://img.undf.top/ompl/TRRT.png" alt="TRRT"><br>BITstar<br><img src="https://img.undf.top/ompl/BITstar.png" alt="BITstar"><br>lazyPRM<br>PRMstar<br><img src="https://img.undf.top/ompl/PRMstar.png" alt="PRMstar"><br>SBL<br><img src="https://img.undf.top/ompl/SBL.png" alt="SBL"><br>BKPIECE1<br><img src="https://img.undf.top/ompl/BKPIECE1.png" alt="BKPIECE1"><br>lazyPRMstar<br><img src="https://img.undf.top/ompl/lazyPRMstar.png" alt="lazyPRMstar"><br>ProjEST<br><img src="https://img.undf.top/ompl/ProjEST.png" alt="ProjEST"><br>SORRTstar<br><img src="https://img.undf.top/ompl/SORRTstar.png" alt="SORRTstar"><br>EST<br><img src="https://img.undf.top/ompl/EST.png" alt="EST"><br>lazyRRT<br>RRTconnect<br><img src="https://img.undf.top/ompl/RRTconnect.png" alt="RRTconnect"><br>SPARS<br><img src="https://img.undf.top/ompl/SPARS.png" alt="SPARS"></p><h2 id="几何规划器"><a href="#几何规划器" class="headerlink" title="几何规划器"></a>几何规划器</h2><p>此类别中的规划器仅考虑系统的几何和运动学约束。假设任何可行的路径都可以变成动态可行的轨迹。这些规划器中的任何一个都可用于 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/constrainedPlanning.html">几何约束进行规划</a> 。此类别中的规划器可以分为几个重叠的子类别:</p><ul><li><strong>多查询规划器</strong><br> 这些规划器构建了可用于多个查询的整个环境的路线图。<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1PRM.html#gPRM">概率路线图方法PRM</a><br> 这是基于采样的算法。我们的实现使用一个线程来构建路线图，而另一个线程检查路线图中是否存在开始状态和目标状态之间的路径。OMPL包含许多PRM的变体:<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LazyPRM.html#gLazyPRM">LazyPRM</a><br> 此计划器类似于常规 PRM，但“懒惰”地检查顶点或边的有效性，即仅当它是候选解决方案路径的一部分时。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1PRMstar.html#gPRMstar">PRM*</a><br> 虽然常规 PRM 尝试将状态连接到固定数量的邻居，但 PRM* 会随着路线图的增长而逐渐增加连接尝试的次数，从而向最佳路径提供收敛。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LazyPRMstar.html#gLazyPRMstar">LazyPRM*</a><br> 具有惰性状态有效性检查的 PRM* 版本。</li></ul></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SPARS.html#gSPARS">SPArse 路线图扳手算法 （SPARS）</a><br> SPARS是一个计划器，它提供渐近 <em>near</em> 最优性（在最优解的常数因子内的解决方案），并包括一个有意义的停止准则。虽然（因为？）它不能保证最优性，但它的收敛率往往远高于PRM*。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SPARStwo.html#gSPARStwo">SPARS2</a><br> SPARS2是SPARS算法的变体，它通过类似的机制工作，但使用不同的方法来识别接口和计算通过所述接口的最短路径。</li></ul></li><li><strong>单查询规划器</strong><br> 这些规划者通常会生长一棵由有效运动连接的状态树。这些规划器的不同之处在于他们用于控制 <em>树的扩展位置</em> 和 <em>方式</em> 的启发式方法。一些基于树的规划者种植 <em>两</em> 棵树:一棵从起点开始，一棵从目标开始。此类规划器将尝试将开始树中的一个状态与目标树中的另一个状态连接起来。<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRT.html#gRRT">快速探索随机树 （RRT）</a><br> 这是最早的单个查询规划器之一。该算法易于理解和实现。已经提出了许多很多RRT的变体。OMPL 包含几种 RRT 变体:<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTConnect.html#gRRTC">RRT Connect （RRTConnect）</a><br> 这个规划器是RRT的双向版本（即，它长了两棵树）。它通常优于原始的RRT算法。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTstar.html#gRRTstar">RRT*</a><br> RRT的渐近最优版本:算法收敛于作为时间函数的最优路径。这是第一个可证明的渐近规划器（与PRM一起）。自发布以来，已经出现了其他几种算法，这些算法提高了RRT*的收敛率，例如 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTsharp.html#gRRTsharp">RRT#</a> 和 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTXstatic.html#gRRTXstatic">RRTX</a> 。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LBTRRT.html#gLBTRRT">下限树 RRT （LBTRRT）</a><br> LBTRRT是RRT的渐近最优版本:它保证收敛到最优解的常数因子内的解。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SST.html#gSST">稀疏稳定RRT</a><br> SST 是 RRT 的渐近接近最优增量版本。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1TRRT.html#gTRRT">基于过渡的 RRT （T-RRT）</a><br> T-RRT不提供任何硬性最优性保证，但试图找到短而低成本的路径。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1VFRRT.html#gVFRRT">矢量场RRT</a><br> VF-RRT是一个基于树的运动规划器，试图最小化所谓的路径上游成本。上游成本由用户定义的向量场上的积分定义。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1pRRT.html#gpRRT">平行RRT</a><br> 已经为基于抽样的计划者提出了许多不同的并行化方案，包括RRT。在此实现中，多个线程同时向同一树添加状态。找到解决方案后，所有线程都将终止。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LazyRRT.html#gLazyRRT">Lazy RRT （LazyRRT）</a><br> 此计划器执行惰性状态有效性检查（类似于 LazyPRM）。它不是实验性的，但根据我们的经验，它似乎在任何类别的问题上都没有明显优于其他规划者。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1TSRRT.html#gTSRRT">任务空间RRT （TSRRT）</a><br> TSRRT是RRT的一种变体，其中探索由任务空间指导。它需要一个 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1TaskSpaceConfig.html">ompl::geometric::TaskSpaceConfig</a> 实例，该实例定义如何将配置空间状态投影到任务空间，以及一个将任务空间状态提升到配置空间的反向操作。</li></ul></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1EST.html#gEST">膨胀空间树 （EST）</a><br> 该规划器与RRT大约同时出版。根据我们的经验，它对良好的距离测量并不敏感，这对于复杂的高维状态空间可能很难定义。EST实际上有三个版本: <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1EST.html#gEST">原始</a> 接近第一次发布的 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1BiEST.html#gBiEST">版本，双向版本</a> 和 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1ProjEST.html#gProjEST">基于投影的版本</a> 。低维投影用于跟踪状态空间的探索方式。大多数情况下，OMPL可以自动确定合理的投影。我们已经实施了一些规划器，这些规划器不一定是EST的简单变体，但确实具有相同的扩展策略:<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SBL.html#gSBL">单查询双向延迟碰撞检查计划 （SBL）</a><br> 此计划器本质上是具有惰性状态有效性检查的 EST 的双向版本。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1pSBL.html#gpSBL">并行单查询双向延迟碰撞检查计划 （pSBL）</a><br> 此规划器在 SBL 中并行使用多个线程增长两棵树。</li></ul></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1KPIECE1.html#gKPIECE1">通过内部和外部细胞探索 （KPIECE） 进行运动学规划</a><br> KPIECE是一个基于树的规划器，它使用离散化（通常是多个层次）来指导（连续）状态空间的探索。OMPL的实现是简化的，使用单一级别的离散化:一个网格。网格被强加于 <em>projection</em> 状态空间的投影上。在探索空间时，优先考虑到目前为止已探索的网格部分的边界。边界定义为 <em>在 n 维投影空间中具有少于 2 n</em> 个非对角线非空相邻格网像元的格网像 _n_元集。KPIECE有两种变体:<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1BKPIECE1.html#gBKPIECE1">双向 KPIECE （BKPIECE）</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LBKPIECE1.html#gLBKPIECE1">Lazy Bi-directional KPIECE （LBKPIECE）</a></li></ul></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1STRIDE.html#gSTRIDE">具有分辨率独立密度估计（STRIDE）的搜索树</a><br> 这位规划器的灵感来自 EST。STRIDE 不使用投影，而是使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1NearestNeighborsGNAT.html">几何近邻访问树</a> 直接在状态空间中估计采样密度。STRIDE 对于高维系统非常有用，在这些系统中，自由空间无法通过低维（线性）投影轻松捕获。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1PDST.html#gPDST">路径导向细分树 （PDST）</a><br> PDST 是一个规划器，它完全消除了对距离度量的依赖，这在难以定义良好距离度量的情况下很有用。PDST保持二进制空间分区，以便运动完全包含在分区的一个单元格中。每个单元格的运动密度用于指导树的扩展。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1FMT.html#gFMT">快速行进树算法 （FMT∗）</a><br> FMT∗ 算法对一组概率绘制的样本执行“惰性”动态规划递归，以生长路径树，该路径树在成本空间中向外移动。与所有其他规划器不同，需要事先选择有效样本的数量。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1BFMT.html#gBFMT">双向快速行进树算法（BFMT∗）</a><br> 执行两个 FMT* 树，一个从起点开始，另一个从目标开始，从而在探索更少的空间时使规划器更快。</li></ul></li><li><strong>多层次规划器</strong><br> 可以利用多个抽象级别的规划算法。如果要使用它们，则应使用 <code>[ompl::base::SpaceInformationPtr](https://ompl.kavrakilab.org/core/classompl_1_1base_1_1SpaceInformationPtr.html &quot;ompl::base::SpaceInformation 的共享指针包装器。&quot;)</code>.然后，所有规划器都保证概率完整性，如果提供的抽象是可以接受的。有指南 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/multiLevelPlanning.html">guide</a>， <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/multiLevelPlanningTutorial.html">教程</a> 和 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/group__demos.html">演示</a> 形式的大量文档。<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QRRT">快速探索随机商空间树 （QRRT）</a><br> RRT的推广，以在不同的抽象级别上进行规划。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QRRTstar">快速交货率*</a><br> QRRT 的渐近最优版本</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QMP">商空间路线图规划器 （QMP）</a><br> PRM的泛化，用于在不同的抽象级别上进行规划。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QMPstar">QMP*</a><br> QMP 的渐近最优版本</li></ul></li><li><strong>优化规划器</strong><br> 近年来，已经提出了几种基于抽样的计划算法，这些算法仍然提供了一些最优性保证。通常，假定最优解是最短路径。在OMPL中，我们有一个更通用的框架来表示状态和路径的成本，例如，允许您最大化沿路径的最小间隙，最小化机械功或一些任意用户定义的优化标准。有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/optimalPlanning.html">最佳规划</a> 。下面的一些规划者使用这种一般成本框架，但请记住，当优化路径长度以外的其他内容时，<strong>不能保证</strong>收敛到最优。<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1PRMstar.html#gPRMstar">PRM*</a><br> PRM的渐近最优版本; <em>使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LazyPRMstar.html#gLazyPRMstar">懒惰PRM*</a><br> PRM*的惰性版本; <em>使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTstar.html#gRRTstar">RRT*</a><br> RRT的渐近最优版本; <em>使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTsharp.html#gRRTsharp">RRT#</a><br> RRT* 的一种变体，收敛率更高。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTXstatic.html#gRRTXstatic">RRTX</a><br> RRT* 的一种变体，收敛率更高。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1InformedRRTstar.html#gInformedRRTstar">知情的RRT*</a><br> RRT* 的一种变体，它使用启发式方法来绑定对最佳解决方案的搜索。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1BITstar.html#gBITstar">批处理通知树 （BIT*）</a><br> 一种随时渐近最优算法，它使用启发式算法对最优解的搜索进行排序和绑定。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1ABITstar.html#gABITstar">高级位* （阿比特*）</a><br> BIT* 的扩展，它使用高级图形搜索技术更快地找到初始解决方案。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1AITstar.html#gAITstar">自适应通知树 （AIT*）</a><br> 一种随时渐近优化的算法，可同时估计和利用特定于问题的启发式方法。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LBTRRT.html#gLBTRRT">下限树 RRT （LBTRRT）</a><br> RRT 的渐近接近最优版本。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SST.html#gSST">稀疏稳定RRT</a><br> SST 是 RRT 的渐近接近最优增量版本。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1TRRT.html#gTRRT">基于过渡的 RRT （T-RRT）</a><br> T-RRT不提供任何硬性最优性保证，但试图找到短而低成本的路径。 <em>它使用一般成本框架。</em></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SPARS.html#gSPARS">梁</a><br> 基于渐近最优路线图的规划器。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SPARStwo.html#gSPARStwo">SPARS2</a><br> 基于渐近最优路线图的规划器。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1FMT.html#gFMT">FMT*</a><br> 渐近最优的基于树的规划器。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1STRRTstar.html#gSTRRTstar">ST-RRT*</a><br> 用于时空规划的双向时间优化规划器。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1CForest.html#gCForest">首席财务官</a><br> 一个元规划器，它在不同的线程中运行多个渐近最优规划器实例。当一个线程找到更好的求解路径时，路径上的状态将传递给其他线程。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1AnytimePathShortening.html#gAPS">随时缩短路径 （APS）</a><br> APS 是围绕一个或多个几何运动规划器的通用包装器，它反复将 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1PathSimplifier.html">快捷方式</a> 和 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1PathHybridization.html">混合应用于</a> 一组解决方案路径。可以指定任何数量和计划器的组合，每个计划器都在单独的线程中运行。</li></ul></li></ul><blockquote><p>Attention<br>OMPL 如何选择几何规划器<br>如果使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1SimpleSetup.html" title="创建解决几何问题通常需要的类集。">ompl::geometric::SimpleSetup</a> 类（强烈推荐）来定义和解决运动规划问题，则 OMPL 将自动选择合适的规划器（除非您明确指定了一个）。如果状态空间具有默认投影（如果您使用任何内置状态空间，情况就是如此），那么 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1LBKPIECE1.html#gLBKPIECE1">使用 LBKPIECE</a> 如果可以则它将使用双向规划器 ，否则它将使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1KPIECE1.html#gKPIECE1">KPIECE</a> 。这些规划器已被证明在许多现实世界的运动规划问题上都能很好地工作，这就是为什么这些规划器是默认选择的原因。如果状态空间没有默认投影，则将使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRTConnect.html#gRRTC">RRTConnect</a> 或常规 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1RRT.html#gRRT">RRT</a> ，具体取决于是否可以使用双向规划器。目标的概念在 OMPL 中非常笼统:甚至可能无法对满足目标的状态进行采样，在这种情况下，OMPL 无法在目标状态生长第二棵树。<br>可行性和最优性<br>在实践中，可行和最佳规划者之间的界限并不是那么黑白分明。它们之间的界限可以用适当的 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1base_1_1PlannerTerminationCondition.html">ompl::base::PlannerTerminationCondition</a> 来模糊。例如， <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1base.html#a71261936b94c44c59a9f26168b30ea1f" title="返回一个终止条件，一旦问题定义具有确切的 s...">ompl::base::exactSolnPlannerTerminationCondition</a> 函数返回一个终止条件，该条件导致优化计划程序在找到第一个解决方案后终止。作为另一个示例，使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1base_1_1CostConvergenceTerminationCondition.html" title=":基于成本收敛的停止优化计划程序的终止条件">ompl::base::CostConvergenceTerminationCondition</a> 和参数 <code>solutionsWindow=10</code> 和 <code>epsilon=1</code>，导致优化计划程序 _exactly_在找到 10 个解决方案时终止。您可以使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1base.html#a743743b4754208eb83ecb3ab20e4df4c" title="将两个终止条件合二为一。如果任一终止条件返回 true,...">ompl::base::p lannerOrTerminationCondition</a> 和 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1base.html#a6fe113eda8e4fb7306a5849f392db50b" title="将两个终止条件合二为一。为此，两个终止条件都需要返回 true...">ompl::base::p lannerAndTerminationCondition</a> 来组合计划程序终止条件（例如，“在找到 <strong>10 个解决方案或</strong> 超过 10 秒的时间限制时终止”）。有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/plannerTerminationConditions.html">Planner 终止条件</a> 。</p></blockquote><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具:"></a>其他工具:</h2><ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1HillClimbing.html#HillClimbing">Hill Climbing</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1geometric_1_1GeneticSearch.html#GeneticSearch">Genetic Search</a></li></ul><h2 id="基于控制的规划器"><a href="#基于控制的规划器" class="headerlink" title="基于控制的规划器"></a>基于控制的规划器</h2><p>如果所考虑的系统受到差异约束，则使用基于控制的规划器。这些规划者依靠 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1StatePropagator.html">状态传播</a> 而不是简单的插值来生成运动。这些规划器不需要 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1StatePropagator.html#acc52d20ab1da84b020aa3dbe5579769e">转向功能</a> ，但如果用户实现它，它们（KPIECE除外）都将使用它。下面的前两个规划器是对上面相应几何规划师的基诺动力学改编。</p><ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1RRT.html#cRRT">快速探索随机树 （RRT）</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1SST.html#cSST">稀疏稳定RRT</a><br> SST 是 RRT 的渐近接近最优增量版本。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1EST.html#cEST">膨胀空间树 （EST）</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1KPIECE1.html#cKPIECE1">通过内外细胞探索（KPIECE）进行Kinodynamic规划</a><br> 顾名思义，基于控件的KPIECE版本首先出现，几何版本是从中派生出来的。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1PDST.html#cPDST">路径导向细分树 （PDST）</a><br> 基于控制的PDST版本实际上出现在几何版本之前。鉴于基于控件的版本，也很容易实现几何版本。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1Syclop.html#cSyclop">Syclop，一个元规划器，在较低级别使用其他规划器</a><br> Syclop 是一个元规划器，它将通过状态空间分解计算的高级指南与低级规划算法相结合。低级规划人员所做的进度将反馈给高级规划员，高级规划师使用此信息来更新指南。Syclop 有两种不同版本：<ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1SyclopRRT.html#cSyclopRRT">Syclop使用RRT作为低级规划器</a></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1SyclopEST.html#cSyclopEST">Syclop 使用 EST 作为低级规划器</a></li></ul></li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/planners.htmlclassompl_1_1control_1_1LTLPlanner.html#cLTLPlanner">线性时态逻辑规划器 （LTLPlanner）</a><br> LTLPlanner 为运动规划问题找到解决方案，其中目标由线性时态逻辑 （LTL） 规范指定。<blockquote><p>OMPL 如何选择基于控件的计划员<br>如果使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1control_1_1SimpleSetup.html" title="创建解决控件问题通常需要的类集。">ompl::control::SimpleSetup</a> 类（强烈推荐）来定义和解决运动规划问题，则 OMPL 将自动选择适当的规划器（除非您明确指定了一个）。如果状态空间具有默认投影（如果使用任何内置状态空间，情况就是如此），则它将使用 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1control_1_1KPIECE1.html#cKPIECE1">KPIECE。</a> 该规划器已被证明在许多现实世界的运动规划问题上都能很好地工作，这就是为什么它是默认选择的原因。如果状态空间没有默认投影，则将 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/classompl_1_1control_1_1RRT.html#cRRT">使用 RRT</a> 。请注意，没有基于双向控制的规划器，因为我们不假设有一个转向功能可以精确地连接两个状态 _exactly_。</p></blockquote></li></ul><h2 id="基于多层次的规划器"><a href="#基于多层次的规划器" class="headerlink" title="基于多层次的规划器"></a>基于多层次的规划器</h2><p>为了解决涉及高维状态空间的问题，我们通常可以使用多级抽象来简化状态空间，从而使专门的规划者能够更快地找到解决方案。此类中的规划器支持状态空间序列，可用于具有几何和动态约束的状态空间。有指南 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/multiLevelPlanning.html">guide</a>， <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/multiLevelPlanningTutorial.html">教程</a> 和 <a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/group__demos.html">演示</a> 形式的大量文档。</p><ul><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QRRT">快速探索随机商空间树 （QRRT）</a><br> RRT的推广，以在不同的抽象级别上进行规划。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QRRTstar">快速交货率*</a><br> QRRT 的渐近最优版本</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QMP">商空间路线图规划器 （QMP）</a><br> PRM的泛化，用于在不同的抽象级别上进行规划。</li><li><a target="_blank" rel="noopener" href="https://ompl.kavrakilab.org/core/namespaceompl_1_1multilevel.html#QMPstar">QMP*</a><br> QMP 的渐近最优版本</li><li>稀商空间路线图规划器 （SPQR）*<br> SPARS向多层次规划的推广。</li></ul></div><div class="post__license"><p> <strong>本文作者：</strong>wxy</p><p> <strong>本文链接：</strong> <a href="https://c.undf.top/posts/7f43910f/">https://c.undf.top/posts/7f43910f/</a></p><strong><p>文章默认使用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议进行许可，使用时请注意遵守协议。</p></strong><strong><p>本站不设评论,网站底部邮件图标可以联系博主</p></strong></div><div class="post-footer__meta"><p> <a href="/archives/2023/09/" class="post-meta__date button">文章写于2023-09-28</a> 文章更新于2023-09-28</p></div><div class="post-entry__tags"><a href="/tags/%F0%9F%A6%BEROS2/" class="post-tags__link button">🦾ROS2</a></div></article><div class="nav"><div class="nav__prev"><a href="/posts/ebf2e125/" class="nav__link"><div><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624 310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg></div><div><div class="nav__label"> 上一篇</div><div class="nav__title"> 哔哩哔哩投稿计划</div></div></a></div><div class="nav__next"><a href="/posts/711bc132/" class="nav__link"><div><div class="nav__label"> 下一篇</div><div class="nav__title"> URDF 导出资料（ROS2）</div></div><div><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg></div></a></div></div><div class="post__comments post__with-toc content-card" id="comment"><h4>评论</h4><div id="tcomment" class="twikoo_thread"></div></div></main><footer class="footer"> <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32"><path d="M233.376 722.752 278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path></svg></a><p><img src="https://c.undf.top/cdn/%E5%A4%87%E6%A1%88.png"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602011871">浙公网安备33010602011937号</a></p><p><a target="_blank" href="http://beian.miit.gov.cn/">浙ICP备2021022005号</a></p><p class="footer-copyright"> 2021&nbsp; <a target="_blank" href="mailto:1798923421@qq.com">📧</a> &nbsp;2023</p><p><a href="https://hexo.io" target="_blank">Hexo</a> | <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p><p><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="https://img.undf.top/image/STM32&Cubeide/又拍云_logo5-2022-05-22.png" style="width:5rem"></a></p></footer></div><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5737bfc954e9ae8ece59f5df2faa6540";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>
        function loadComment() {
            let e;
            (e = document.createElement("script")).src = 'https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js',
            document.body.appendChild(e);
            e.onload = () => {
                twikoo.init({
                    envId: 'https://twikoo.undf.top',
                    el: '#tcomment'
                });
            };
        }
    
        var runningOnBrowser = typeof window !== "undefined";
        var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
        var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    
        setTimeout(function () {
            if (!isBot && supportsIntersectionObserver) {
                var comment_observer = new IntersectionObserver(function(entries) {
                    if (entries[0].isIntersecting) {
                        loadComment();
                        comment_observer.disconnect();
                    }
                }, { threshold: [0] });
                comment_observer.observe(document.getElementById('comment'));
            } else {
                loadComment();
            }
        }, 1);
    </script></body></html>