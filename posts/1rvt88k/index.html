
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8" theme-name="Stellar" theme-version="1.26.8">
  
  <meta name="generator" content="Hexo 6.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>FreeRTOS - 沐印小站</title>

  
    <meta name="description" content="大部分内容都为摘抄其实已经看过很多遍，但一直没用过。  内存管理task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。 FreeRTOS的5种内存管理方法   文件 优点">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS">
<meta property="og:url" content="https://c.undf.top/posts/1rvt88k/index.html">
<meta property="og:site_name" content="沐印小站">
<meta property="og:description" content="大部分内容都为摘抄其实已经看过很多遍，但一直没用过。  内存管理task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。 FreeRTOS的5种内存管理方法   文件 优点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.undf.top/utools/1673868627091_5gu53zc58zp8f24k.png">
<meta property="og:image" content="https://img.undf.top/utools/1673876690909_b8vj0bypy78dmygf.png">
<meta property="og:image" content="https://img.undf.top/utools/1673877102733_in4bdyrchoqtnblc.png">
<meta property="og:image" content="https://img.undf.top/utools/1673877501635_dwoab2ksj0cey9be.png">
<meta property="og:image" content="https://img.undf.top/utools/1673877706072_dh293c8je2izndds.png">
<meta property="og:image" content="https://img.undf.top/utools/1673877932075_6txse7co5pok1ngf.png">
<meta property="og:image" content="https://c.undf.top/!%5B%5D(https:/img.undf.top/utools/1673878043754_v3w2rdr4b3udx805.png)">
<meta property="og:image" content="https://img.undf.top/utools/1673878068181_kq43blmv75dwe00z.png">
<meta property="og:image" content="https://c.undf.top/pic/chap10/05_demon_task_priority_higher.png">
<meta property="og:image" content="https://img.undf.top/utools/1673878093734_wd0b1lpwo1bkxt5n.png">
<meta property="og:image" content="https://img.undf.top/utools/1673878165302_vn9b11k5d1g8o3jb.png">
<meta property="og:image" content="https://img.undf.top/utools/1673878428670_9qjlufv5a7dozv2z.png">
<meta property="article:published_time" content="2023-01-18T12:50:28.000Z">
<meta property="article:modified_time" content="2023-01-18T12:50:28.000Z">
<meta property="article:author" content="wxy">
<meta property="article:tag" content="🦾RTOS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.undf.top/utools/1673868627091_5gu53zc58zp8f24k.png">
  
  
  
  <meta name="keywords" content="🦾RTOS">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="沐印小站" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.26.8">

  
    <link rel="shortcut icon" href="/icon/favicon-32x32.png">
  

  

  
  <meta name="msapplication-TileColor" content="#2d89ef"><link rel="stylesheet" href="css/my.css">
</head>
<body>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="sidebar-container sidebar-blur">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.undf.top/placeholder/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://img.undf.top/image/_config/2022-01-28-13-35-03.jpg" onerror="javascript:this.classList.add('error');this.src='https://cdn.undf.top/placeholder/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">沐印小站</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="服务" href="/self-host/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="社交" href="/friend/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a><a class="nav-item" title="探索" href="/more/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a></nav>
</div>
<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOS%E7%9A%845%E7%A7%8D%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">FreeRTOS的5种内存管理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-1-c"><span class="toc-text">heap_1.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-2-c-%E5%BC%83%E7%94%A8"><span class="toc-text">heap_2.c 弃用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-3-c"><span class="toc-text">heap_3.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-4-c"><span class="toc-text">heap_4.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-5-c"><span class="toc-text">heap_5.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">Heap相关的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-text">创建任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">任务的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8CTick"><span class="toc-text">任务优先级和Tick</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">任务优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tick"><span class="toc-text">Tick</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-text">任务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delay%E5%87%BD%E6%95%B0"><span class="toc-text">Delay函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E5%8F%8A%E5%85%B6%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-text">空闲任务及其钩子函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E4%B8%8E%E9%80%9A%E4%BF%A1"><span class="toc-text">同步互斥与通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">队列的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">传输数据的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%98%BB%E5%A1%9E%E8%AE%BF%E9%97%AE"><span class="toc-text">队列阻塞访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">队列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D"><span class="toc-text">复位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%98%9F%E5%88%97"><span class="toc-text">写队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%98%9F%E5%88%97"><span class="toc-text">读队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96-%E5%81%B7%E7%9C%8B"><span class="toc-text">覆盖&#x2F;偷看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C"><span class="toc-text">信号量的常规操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">两种信号量的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-text">信号量函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#give-take"><span class="toc-text">give&#x2F;take</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-2"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-text">其他函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84"><span class="toc-text">事件组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">事件组的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-text">事件组函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-3"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6"><span class="toc-text">设置事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6"><span class="toc-text">等待事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%82%B9"><span class="toc-text">同步点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="toc-text">任务通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%8F%8A%E9%99%90%E5%88%B6"><span class="toc-text">优势及限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E7%8A%B6%E6%80%81%E5%92%8C%E9%80%9A%E7%9F%A5%E5%80%BC"><span class="toc-text">通知状态和通知值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">任务通知的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%B1%BB%E5%87%BD%E6%95%B0"><span class="toc-text">两类函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xTaskNotifyGive-ulTaskNotifyTake"><span class="toc-text">xTaskNotifyGive&#x2F;ulTaskNotifyTake</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xTaskNotify-xTaskNotifyWait"><span class="toc-text">xTaskNotify&#x2F;xTaskNotifyWait</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">软件定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">软件定时器的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">软件定时器的上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">守护任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-text">守护任务的调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">软件定时器的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-4"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-3"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2"><span class="toc-text">启动&#x2F;停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D-1"><span class="toc-text">复位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%91%A8%E6%9C%9F"><span class="toc-text">修改周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8ID"><span class="toc-text">定时器ID</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E5%A5%97API%E5%87%BD%E6%95%B0"><span class="toc-text">两套API函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E5%A5%97API"><span class="toc-text">为什么需要两套API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E5%A5%97API%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">两套API函数列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xHigherPriorityTaskWoken%E5%8F%82%E6%95%B0"><span class="toc-text">xHigherPriorityTaskWoken参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E4%BB%BB%E5%8A%A1"><span class="toc-text">怎么切换任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%A4%84%E7%90%86"><span class="toc-text">中断的延迟处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">中断与任务间的通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-text">屏蔽中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-text">在任务中屏蔽中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8ISR%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-text">在ISR中屏蔽中断</span></a></li></ol></li></ol></li></ol></div></div></widget>







<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/posts/61eef7d7/"><span class="title">生活随笔</span></a><a class="item title" href="/posts/7f43910f/"><span class="title">OMPL开源轨迹规划库</span></a><a class="item title" href="/posts/711bc132/"><span class="title">URDF 导出资料（ROS2）</span></a><a class="item title" href="/posts/5ecf4bea/"><span class="title">旭日x3PI的开发日常</span></a><a class="item title" href="/posts/ca763a9f/"><span class="title">QtCreator 一键打包你的APP</span></a><a class="item title" href="/posts/d444c6c7/"><span class="title">leetcode 刷题记录（倒序）</span></a><a class="item title" href="/posts/6306f887/"><span class="title">旭日 x3PI RealSense人体关键点识别</span></a><a class="item title" href="/posts/3ouvu5p/"><span class="title">MoneyProgress_win</span></a><a class="item title" href="/posts/2llqu4i/"><span class="title">ROS2自定义消息使用记录</span></a><a class="item title active" href="/posts/1rvt88k/"><span class="title">FreeRTOS</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/wxydejoy" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://cdn.undf.top/placeholder/social/08a41b181ce68.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    
<div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-01-18T12:50:28.000Z">2023-01-18</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2023-01-18T12:50:28.000Z">2023-01-18</time></span></div></div>
</div>

    
    <div class="bottom">
      <div class="text-area">
        <h1 class="text title"><span>FreeRTOS</span></h1>
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>大部分内容都为摘抄<br>其实已经看过很多遍，但一直没用过。</p>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p>
<h3 id="FreeRTOS的5种内存管理方法"><a href="#FreeRTOS的5种内存管理方法" class="headerlink" title="FreeRTOS的5种内存管理方法"></a>FreeRTOS的5种内存管理方法</h3><table>
<thead>
<tr>
<th>文件</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>heap_1.c</td>
<td>分配简单，时间确定</td>
<td>只分配、不回收</td>
</tr>
<tr>
<td>heap_2.c</td>
<td>动态分配、最佳匹配</td>
<td>碎片、时间不定</td>
</tr>
<tr>
<td>heap_3.c</td>
<td>调用标准库函数</td>
<td>速度慢、时间不定</td>
</tr>
<tr>
<td>heap_4.c</td>
<td>相邻空闲内存可合并</td>
<td>可解决碎片问题、时间不定</td>
</tr>
<tr>
<td>heap_5.c</td>
<td>在heap_4基础上支持分隔的内存块</td>
<td>可解决碎片问题、时间不定</td>
</tr>
</tbody></table>
<h4 id="heap-1-c"><a href="#heap-1-c" class="headerlink" title="heap_1.c"></a>heap_1.c</h4><ul>
<li><p>实现最简单</p>
</li>
<li><p>没有碎片问题</p>
</li>
<li><p>一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1</p>
</li>
</ul>
<h4 id="heap-2-c-弃用"><a href="#heap-2-c-弃用" class="headerlink" title="heap_2.c 弃用"></a>heap_2.c 弃用</h4><p>Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。</p>
<h4 id="heap-3-c"><a href="#heap-3-c" class="headerlink" title="heap_3.c"></a>heap_3.c</h4><p>Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。</p>
<p>C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。</p>
<h4 id="heap-4-c"><a href="#heap-4-c" class="headerlink" title="heap_4.c"></a>heap_4.c</h4><p>跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。</p>
<p>Heap_4使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p>
<h4 id="heap-5-c"><a href="#heap-5-c" class="headerlink" title="heap_5.c"></a>heap_5.c</h4><p>Heap_5分配内存、释放内存的算法跟Heap_4是一样的。</p>
<p>相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</p>
<p>在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。</p>
<p>既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：</p>
<p>在使用pvPortMalloc之前，必须先指定内存块的信息</p>
<p>使用vPortDefineHeapRegions来指定这些信息</p>
<h3 id="Heap相关的函数"><a href="#Heap相关的函数" class="headerlink" title="Heap相关的函数"></a>Heap相关的函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
</table>
<p>void *pvPortMalloc( size_t xWantedSize ) | 分配内存<br>void vPortFree( void *pv ) | 释放内存<br>size_t xPortGetFreeHeapSize( void ) | 获取剩余内存<br>size_t xPortGetMinimumEverFreeHeapSize( void ) | 获取最小剩余内存</p>
<p>malloc失败的钩子函数</p>
<p>在pvPortMalloc函数内部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pvReturn == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">                vApplicationMallocFailedHook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pvReturn;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，如果想使用这个钩子函数：</p>
<p>在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1</p>
<p>提供vApplicationMallocFailedHook函数</p>
<p>pvPortMalloc失败时，才会调用此函数</p>
<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><p>在FreeRTOS中，任务就是一个函数，原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure>

<p>要注意的是：</p>
<ul>
<li>这个函数不能返回</li>
<li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li>
<li>函数内部，尽量使用局部变量：<ul>
<li>每个任务都有自己的栈</li>
<li>每个任务运行这个函数时<ul>
<li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li>
<li>不同任务的局部变量，有自己的副本</li>
</ul>
</li>
<li>函数使用全局变量、静态变量的话<ul>
<li>只有一个副本：多个任务使用的是同一个副本</li>
<li>要防止冲突(后续会讲)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>创建任务时使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>



<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>函数指针，可以简单地认为任务就是一个C函数。<br />它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td>
</tr>
<tr>
<td>pcName</td>
<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。<br />长度为：configMAX_TASK_NAME_LEN</td>
</tr>
<tr>
<td>usStackDepth</td>
<td>每个任务都有自己的栈，这里指定栈大小。<br />单位是word，比如传入100，表示栈大小为100 word，也就是400字节。<br />最大值为uint16_t的最大值。<br />怎么确定栈的大小，并不容易，很多时候是估计。<br />精确的办法是看反汇编码。</td>
</tr>
<tr>
<td>pvParameters</td>
<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>
</tr>
<tr>
<td>uxPriority</td>
<td>优先级范围：0~(configMAX_PRIORITIES – 1)<br />数值越小优先级越低，<br />如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td>
</tr>
<tr>
<td>pxCreatedTask</td>
<td>用来保存xTaskCreate的输出结果：task handle。<br />以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。<br />如果不想使用该handle，可以传入NULL。</td>
</tr>
<tr>
<td>返回值</td>
<td>成功：pdPASS；<br />失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)<br />注意：文档里都说失败时返回值是pdFAIL，这不对。<br />pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。</td>
</tr>
</tbody></table>
<h3 id="任务的删除"><a href="#任务的删除" class="headerlink" title="任务的删除"></a>任务的删除</h3><p>删除任务时使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。<br />也可传入NULL，这表示删除自己。</td>
</tr>
</tbody></table>
<p>怎么删除任务？举个不好的例子：</p>
<ul>
<li>自杀：<code>vTaskDelete(NULL)</code></li>
<li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是自己的句柄</li>
<li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是别的任务的句柄</li>
</ul>
<h3 id="任务优先级和Tick"><a href="#任务优先级和Tick" class="headerlink" title="任务优先级和Tick"></a>任务优先级和Tick</h3><h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p>在上个示例中我们体验过优先级的使用：高优先级的任务先运行。</p>
<p>优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。</p>
<p>FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。</p>
<ul>
<li>通用方法<br>使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。<br>configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。</li>
<li>架构相关的优化的方法<br>架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。<br>使用这种方法时，configMAX_PRIORITIES的取值不能超过32。<br>configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。</li>
</ul>
<p>在学习调度方法之前，你只要初略地知道：</p>
<ul>
<li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li>
<li>对于相同优先级的、可运行的任务，轮流执行</li>
</ul>
<p>这无需记忆，就像我们举的例子：</p>
<ul>
<li>厨房着火了，当然优先灭火</li>
<li>喂饭、回复信息同样重要，轮流做</li>
</ul>
<h4 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h4><p>对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。</p>
<h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。</p>
<p>对于非运行的状态，还可以继续细分，比如前面的<code>FreeRTOS_04_task_priority</code>中：</p>
<ul>
<li>Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行</li>
<li>Task3运行期间，Task1、Task2也处于非运行状态，但是它们<strong>随时可以运行</strong></li>
<li>这两种”非运行”状态就不一样，可以细分为：<ul>
<li>阻塞状态(Blocked)</li>
<li>暂停状态(Suspended)</li>
<li>就绪状态(Ready)</li>
</ul>
</li>
</ul>
<p><img src="https://img.undf.top/utools/1673868627091_5gu53zc58zp8f24k.png"></p>
<h3 id="Delay函数"><a href="#Delay函数" class="headerlink" title="Delay函数"></a>Delay函数</h3><p>有两个Delay函数：</p>
<ul>
<li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li>
<li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。</li>
</ul>
<h3 id="空闲任务及其钩子函数"><a href="#空闲任务及其钩子函数" class="headerlink" title="空闲任务及其钩子函数"></a>空闲任务及其钩子函数</h3><p>为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用vTaskStartScheduler() 函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p>
<p>空闲任务优先级为0：它不能阻碍用户任务运行</p>
<p>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</p>
<p>空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。</p>
<p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p>
<p>执行一些低优先级的、后台的、需要连续执行的函数</p>
<p>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</p>
<p>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</p>
<p>空闲任务的钩子函数的限制：</p>
<p>不能导致空闲任务进入阻塞状态、暂停状态</p>
<p>如果你会使用vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><table>
<thead>
<tr>
<th>配置项</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody><tr>
<td>configUSE_PREEMPTION</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>configUSE_TIME_SLICING</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>configIDLE_SHOULD_YIELD</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>说明</td>
<td>常用</td>
<td>很少用</td>
<td>很少用</td>
<td>很少用</td>
<td>几乎不用</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li><p>A：可抢占+时间片轮转+空闲任务让步</p>
</li>
<li><p>B：可抢占+时间片轮转+空闲任务不让步</p>
</li>
<li><p>C：可抢占+非时间片轮转+空闲任务让步</p>
</li>
<li><p>D：可抢占+非时间片轮转+空闲任务不让步</p>
</li>
<li><p>E：合作调度</p>
</li>
</ul>
<h2 id="同步互斥与通信"><a href="#同步互斥与通信" class="headerlink" title="同步互斥与通信"></a>同步互斥与通信</h2><p>队列：</p>
<p>里面可以放任意数据，可以放多个数据</p>
<p>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</p>
<p>事件组：</p>
<p>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</p>
<p>可以用来表示事件、事件的组合发生了，不能传递数据</p>
<p>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</p>
<p>信号量：</p>
<p>核心是”计数值”</p>
<p>任务、ISR释放信号量时让计数值加1</p>
<p>任务、ISR获得信号量时，让计数值减1</p>
<p>任务通知：</p>
<p>核心是任务的TCB里的数值</p>
<p>会被覆盖</p>
<p>发通知给谁？必须指定接收任务</p>
<p>只能由接收任务本身获取该通知</p>
<p>互斥量：</p>
<p>数值只有0或1</p>
<p>谁获得互斥量，就必须由谁释放同一个互斥量</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列(queue)可以用于”任务到任务”、”任务到中断”、”中断到任务”直接传输信息。</p>
<ul>
<li><p>队列可以包含若干个数据：队列中有若干项，这被称为”长度”(length)</p>
</li>
<li><p>每个数据大小固定</p>
</li>
<li><p>创建队列时就要指定长度、数据大小</p>
</li>
<li><p>数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读</p>
</li>
<li><p>也可以强制写队列头部：覆盖头部数据</p>
</li>
</ul>
<p><img src="https://img.undf.top/utools/1673876690909_b8vj0bypy78dmygf.png"></p>
<h3 id="队列的特性"><a href="#队列的特性" class="headerlink" title="队列的特性"></a>队列的特性</h3><h4 id="传输数据的两种方法"><a href="#传输数据的两种方法" class="headerlink" title="传输数据的两种方法"></a>传输数据的两种方法</h4><p>FreeRTOS使用拷贝值的方法，这更简单：</p>
<ul>
<li><p>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</p>
</li>
<li><p>无需分配buffer来保存数据，队列中有buffer</p>
</li>
<li><p>局部变量可以马上再次使用</p>
</li>
<li><p>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</p>
</li>
<li><p>如果数据实在太大，你还是可以使用队列传输它的地址</p>
</li>
<li><p>队列的空间有FreeRTOS内核分配，无需任务操心</p>
</li>
<li><p>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</p>
</li>
</ul>
<h4 id="队列阻塞访问"><a href="#队列阻塞访问" class="headerlink" title="队列阻塞访问"></a>队列阻塞访问</h4><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p>
<p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p>
<p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p>
<p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p>
<p>优先级最高的任务</p>
<p>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</p>
<p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p>
<p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p>
<p>优先级最高的任务</p>
<p>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</p>
<h3 id="队列函数"><a href="#队列函数" class="headerlink" title="队列函数"></a>队列函数</h3><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p>
<ul>
<li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li>
</ul>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>uxQueueLength</td>
<td>队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td>uxItemSize</td>
<td>每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td>返回值</td>
<td>非0：成功，返回句柄，以后使用句柄来操作队列<br />NULL：失败，因为内存不足</td>
</tr>
</tbody></table>
<ul>
<li>静态分配内存：xQueueCreateStatic，队列的内存要事先分配好</li>
</ul>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">                           UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                           UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                           <span class="type">uint8_t</span> *pucQueueStorageBuffer,</span></span><br><span class="line"><span class="params">                           StaticQueue_t *pxQueueBuffer</span></span><br><span class="line"><span class="params">                       )</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>uxQueueLength</td>
<td>队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td>uxItemSize</td>
<td>每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td>pucQueueStorageBuffer</td>
<td>如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组，<br />此数组大小至少为”uxQueueLength * uxItemSize”</td>
</tr>
<tr>
<td>pxQueueBuffer</td>
<td>必须执行一个StaticQueue_t结构体，用来保存队列的数据结构</td>
</tr>
<tr>
<td>返回值</td>
<td>非0：成功，返回句柄，以后使用句柄来操作队列<br />NULL：失败，因为pxQueueBuffer为NULL</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> QUEUE_LENGTH 10</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// xQueueBuffer用来保存队列结构体</span></span><br><span class="line"> StaticQueue_t xQueueBuffer;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// ucQueueStorage 用来保存队列的数据</span></span><br><span class="line"> <span class="comment">// 大小为：队列长度 * 数据大小</span></span><br><span class="line"> <span class="type">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span> <span class="title function_">vATask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line"> &#123;</span><br><span class="line">	QueueHandle_t xQueue1;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span></span><br><span class="line">	xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class="line">						  ITEM_SIZE,</span><br><span class="line">						  ucQueueStorage,</span><br><span class="line">						  &amp;xQueueBuffer ); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h4><p>队列刚被创建时，里面没有数据；使用过程中可以调用<code>xQueueReset()</code>把队列恢复为初始状态，此函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pxQueue : 复位哪个队列;</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS(必定成功)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReset</span><span class="params">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除队列的函数为<code>vQueueDelete()</code>，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vQueueDelete</span><span class="params">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="写队列"><a href="#写队列" class="headerlink" title="写队列"></a>写队列</h4><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等同于xQueueSendToBack</span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFrontFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br></pre></td></tr></table></figure>



<p>这些函数用到的参数是类似的，统一说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xQueue</td>
<td>队列句柄，要写哪个队列</td>
</tr>
<tr>
<td>pvItemToQueue</td>
<td>数据指针，这个数据的值会被复制进队列，<br />复制多大的数据？在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态，<br />xTicksToWait表示阻塞的最大时间(Tick Count)。<br />如果被设为0，无法写入数据时函数会立刻返回；<br />如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写</td>
</tr>
<tr>
<td>返回值</td>
<td>pdPASS：数据成功写入了队列<br />errQUEUE_FULL：写入失败，因为队列满了。</td>
</tr>
</tbody></table>
<h4 id="读队列"><a href="#读队列" class="headerlink" title="读队列"></a>读队列</h4><p>使用<code>xQueueReceive()</code>函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                    QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span>             *pvBuffer,</span></span><br><span class="line"><span class="params">                                    BaseType_t       *pxTaskWoken</span></span><br><span class="line"><span class="params">                                )</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xQueue</td>
<td>队列句柄，要读哪个队列</td>
</tr>
<tr>
<td>pvBuffer</td>
<td>bufer指针，队列的数据会被复制到这个buffer<br />复制多大的数据？在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>果队列空则无法读出数据，可以让任务进入阻塞状态，<br />xTicksToWait表示阻塞的最大时间(Tick Count)。<br />如果被设为0，无法读出数据时函数会立刻返回；<br />如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>
</tr>
<tr>
<td>返回值</td>
<td>pdPASS：从队列读出数据入<br />errQUEUE_EMPTY：读取失败，因为队列空了。</td>
</tr>
</tbody></table>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回队列中可用数据的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueMessagesWaiting</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回队列中可用空间的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueSpacesAvailable</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="覆盖-偷看"><a href="#覆盖-偷看" class="headerlink" title="覆盖&#x2F;偷看"></a>覆盖&#x2F;偷看</h4><p>当队列长度为1时，可以使用<code>xQueueOverwrite()</code>或<code>xQueueOverwriteFromISR()</code>来覆盖数据。<br>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。<br>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 覆盖队列</span></span><br><span class="line"><span class="comment"> * xQueue: 写哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">                           QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue</span></span><br><span class="line"><span class="params">                      )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwriteFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                           QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                      )</span>;</span><br></pre></td></tr></table></figure>



<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是<code>xQueuePeek()</code>或<code>xQueuePeekFromISR()</code>。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。<br>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 偷看队列</span></span><br><span class="line"><span class="comment"> * xQueue: 偷看哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(</span></span><br><span class="line"><span class="params">                          QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">                      )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeekFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                 QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> *pvBuffer,</span></span><br><span class="line"><span class="params">                             )</span>;</span><br></pre></td></tr></table></figure>




<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。</p>
<p>有时候我们只需要传递状态，并不需要传递具体的信息，比如：</p>
<p>我的事做完了，通知一下你</p>
<p>卖包子了、卖包子了，做好了1个包子！做好了2个包子！做好了3个包子！</p>
<p>这个停车位我占了，你们只能等着</p>
<p>在这种情况下我们可以使用信号量(semaphore)，它更节省内存。</p>
<p><img src="https://img.undf.top/utools/1673877102733_in4bdyrchoqtnblc.png"></p>
<h3 id="信号量的常规操作"><a href="#信号量的常规操作" class="headerlink" title="信号量的常规操作"></a>信号量的常规操作</h3><h4 id="两种信号量的对比"><a href="#两种信号量的对比" class="headerlink" title="两种信号量的对比"></a>两种信号量的对比</h4><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p>
<p>差别列表如下：</p>
<table>
<thead>
<tr>
<th>二进制信号量</th>
<th>技术型信号量</th>
</tr>
</thead>
<tbody><tr>
<td>被创建时初始值为0</td>
<td>被创建时初始值可以设定</td>
</tr>
<tr>
<td>其他操作是一样的</td>
<td>其他操作是一样的</td>
</tr>
</tbody></table>
<h3 id="信号量函数"><a href="#信号量函数" class="headerlink" title="信号量函数"></a>信号量函数</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。</p>
<p>对于二进制信号量、计数型信号量，它们的创建函数不一样：</p>
<table>
<thead>
<tr>
<th></th>
<th>二进制信号量</th>
<th>计数型信号量</th>
</tr>
</thead>
<tbody><tr>
<td>动态创建</td>
<td>xSemaphoreCreateBinary<br />计数值初始值为0</td>
<td>xSemaphoreCreateCounting</td>
</tr>
<tr>
<td></td>
<td>vSemaphoreCreateBinary(过时了)<br />计数值初始值为1</td>
<td></td>
</tr>
<tr>
<td>静态创建</td>
<td>xSemaphoreCreateBinaryStatic</td>
<td>xSemaphoreCreateCountingStatic</td>
</tr>
</tbody></table>
<p>创建二进制信号量的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>



<p>创建计数型信号量的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">( UBaseType_t uxMaxCount, </span></span><br><span class="line"><span class="params">                                                 UBaseType_t uxInitialCount, </span></span><br><span class="line"><span class="params">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p>
<p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="give-take"><a href="#give-take" class="headerlink" title="give&#x2F;take"></a>give&#x2F;take</h4><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>在任务中使用</th>
<th>在ISR中使用</th>
</tr>
</thead>
<tbody><tr>
<td>give</td>
<td>xSemaphoreGive</td>
<td>xSemaphoreGiveFromISR</td>
</tr>
<tr>
<td>take</td>
<td>xSemaphoreTake</td>
<td>xSemaphoreTakeFromISR</td>
</tr>
</tbody></table>
<p>xSemaphoreGive的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreGive函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，释放哪个信号量</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功,<br />如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；<br />如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>
</tr>
</tbody></table>
<p>pxHigherPriorityTaskWoken的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，释放哪个信号量</td>
</tr>
<tr>
<td>pxHigherPriorityTaskWoken</td>
<td>如果释放信号量导致更高优先级的任务变为了就绪态，<br />则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功,<br />如果二进制信号量的计数值已经是1，再次调用此函数则返回失败；<br />如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>
</tr>
</tbody></table>
<p>xSemaphoreTake的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreTake函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，获取哪个信号量</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>如果无法马上获得信号量，阻塞一会：<br />0：不阻塞，马上返回<br />portMAX_DELAY: 一直阻塞直到成功<br />其他值: 阻塞的Tick个数，可以使用<code>pdMS_TO_TICKS()</code>来指定阻塞时间为若干ms</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功</td>
</tr>
</tbody></table>
<p>xSemaphoreTakeFromISR的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，获取哪个信号量</td>
</tr>
<tr>
<td>pxHigherPriorityTaskWoken</td>
<td>如果获取信号量导致更高优先级的任务变为了就绪态，<br />则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功</td>
</tr>
</tbody></table>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>在多任务系统中，任务A正在使用某个资源，还没用完的情况下任务B也来使用的话，就可能导致问题。</p>
<p>比如对于串口，任务A正使用它来打印，在打印过程中任务B也来打印，客户看到的结果就是A、B的信息混杂在一起。</p>
<p>上述问题的解决方法是：任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。</p>
<p>互斥量也被称为互斥锁，使用过程如下：</p>
<p>互斥量初始值为1</p>
<p>任务A想访问临界资源，先获得并占有互斥量，然后开始访问</p>
<p>任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞</p>
<p>任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源</p>
<p>任务B使用完毕，释放互斥量</p>
<p>正常来说：在任务A占有互斥量的过程中，任务B、任务C等等，都无法释放互斥量。</p>
<p>但是FreeRTOS未实现这点：任务A占有互斥量的情况下，任务B也可释放互斥量。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>互斥量是一种特殊的二进制信号量。</p>
<p>使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。</p>
<p>创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配互斥量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutexStatic</span><span class="params">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure>



<p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES 1</span></span><br></pre></td></tr></table></figure>





<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>要注意的是，互斥量不能在ISR中使用。</p>
<p>各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放(ISR版本) */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                       SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                       BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br><span class="line"><span class="comment">/* 获得(ISR版本) */</span></span><br><span class="line">xSemaphoreGiveFromISR(</span><br><span class="line">                       SemaphoreHandle_t xSemaphore,</span><br><span class="line">                       BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="line">                   );</span><br></pre></td></tr></table></figure>

<h2 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h2><p>事件组可以简单地认为就是一个整数：</p>
<ul>
<li>每一位表示一个事件</li>
<li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li>
<li>这些位，值为1表示事件发生了，值为0表示事件没发生</li>
<li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li>
<li>可以等待某一位、某些位中的任意一个，也可以等待多位</li>
</ul>
<p><img src="https://img.undf.top/utools/1673877501635_dwoab2ksj0cey9be.png"></p>
<p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p>
<ul>
<li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li>
<li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li>
<li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul>
<li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li>
<li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li>
</ul>
</li>
</ul>
<h3 id="事件组的操作"><a href="#事件组的操作" class="headerlink" title="事件组的操作"></a>事件组的操作</h3><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p>
<ul>
<li>唤醒谁？<ul>
<li>队列、信号量：事件发生时，只会唤醒一个任务</li>
<li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li>
</ul>
</li>
<li>是否清除事件？<ul>
<li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li>
<li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li>
</ul>
</li>
</ul>
<p>以上图为列，事件组的常规操作如下：</p>
<ul>
<li><p>先创建事件组</p>
</li>
<li><p>任务C、D等待事件：</p>
<ul>
<li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li>
<li>得到事件时，要不要清除？可选择清除、不清除。</li>
</ul>
</li>
<li><p>任务A、B产生事件：设置事件组里的某一位、某些位</p>
</li>
</ul>
<h3 id="事件组函数"><a href="#事件组函数" class="headerlink" title="事件组函数"></a>事件组函数</h3><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p>
<p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配事件组结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreateStatic</span><span class="params">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p>
<p>vEventGroupDelete可以用来删除事件组，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>



<h4 id="设置事件"><a href="#设置事件" class="headerlink" title="设置事件"></a>设置事件</h4><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p>
<ul>
<li>在任务中使用<code>xEventGroupSetBits()</code></li>
<li>在ISR中使用<code>xEventGroupSetBitsFromISR()</code></li>
</ul>
<p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">									  <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">									  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>



<p>值得注意的是，ISR中的函数，比如队列函数<code>xQueueSendToBackFromISR</code>、信号量函数<code>xSemaphoreGiveFromISR</code>，它们会唤醒某个任务，最多只会唤醒1个任务。</p>
<p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<code>xEventGroupSetBitsFromISR</code>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>
<p>如果后台任务的优先级比当前被中断的任务优先级高，<code>xEventGroupSetBitsFromISR</code>会设置<code>*pxHigherPriorityTaskWoken</code>为pdTRUE。</p>
<p>如果daemon task成功地把队列数据发送给了后台任务，那么<code>xEventGroupSetBitsFromISR</code>的返回值就是pdPASS。</p>
<h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><p>使用<code>xEventGroupWaitBits</code>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>



<p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p>
<p>函数参数说明列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xEventGroup</td>
<td>等待哪个事件组？</td>
</tr>
<tr>
<td>uxBitsToWaitFor</td>
<td>等待哪些位？哪些位要被测试？</td>
</tr>
<tr>
<td>xWaitForAllBits</td>
<td>怎么测试？是”AND”还是”OR”？<br />pdTRUE: 等待的位，全部为1;<br />pdFALSE: 等待的位，某一个为1即可</td>
</tr>
<tr>
<td>xClearOnExit</td>
<td>函数提出前是否要清除事件？<br />pdTRUE: 清除uxBitsToWaitFor指定的位<br />pdFALSE: 不清除</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>如果期待的事件未发生，阻塞多久。<br />可以设置为0：判断后即刻返回；<br />可设置为portMAX_DELAY：一定等到成功才返回；<br />可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>
</tr>
<tr>
<td>返回值</td>
<td>返回的是事件值，<br />如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br />如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody></table>
<p>举例如下：</p>
<table>
<thead>
<tr>
<th>事件组的值</th>
<th>uxBitsToWaitFor</th>
<th>xWaitForAllBits</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0100</td>
<td>0101</td>
<td>pdTRUE</td>
<td>任务期望bit0,bit2都为1，<br />当前值只有bit2满足，任务进入阻塞态；<br />当事件组中bit0,bit2都为1时退出阻塞态</td>
</tr>
<tr>
<td>0100</td>
<td>0110</td>
<td>pdFALSE</td>
<td>任务期望bit0,bit2某一个为1，<br />当前值满足，所以任务成功退出</td>
</tr>
<tr>
<td>0100</td>
<td>0110</td>
<td>pdTRUE</td>
<td>任务期望bit1,bit2都为1，<br />当前值不满足，任务进入阻塞态；<br />当事件组中bit1,bit2都为1时退出阻塞态</td>
</tr>
</tbody></table>
<p>你可以使用<code>xEventGroupWaitBits()</code>等待期望的事件，它发生之后再使用<code>xEventGroupClearBits()</code>来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p>
<p>可以使用设置<code>xClearOnExit</code>为pdTRUE，使得对事件组的测试、清零都在<code>xEventGroupWaitBits()</code>函数内部完成，这是一个原子操作。</p>
<h4 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h4><p>有一个事情需要多个任务协同，比如：</p>
<ul>
<li>任务A：炒菜</li>
<li>任务B：买酒</li>
<li>任务C：摆台</li>
<li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li>
</ul>
<p>使用<code>xEventGroupSync()</code>函数可以同步多个任务：</p>
<ul>
<li>可以设置某位、某些位，表示自己做了什么事</li>
<li>可以等待某位、某些位，表示要等等其他任务</li>
<li>期望的时间发生后，<code>xEventGroupSync()</code>才会成功返回。</li>
<li><code>xEventGroupSync</code>成功返回后，会清除事件</li>
</ul>
<p><code>xEventGroupSync</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupSync</span><span class="params">(    EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>



<p>参数列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xEventGroup</td>
<td>哪个事件组？</td>
</tr>
<tr>
<td>uxBitsToSet</td>
<td>要设置哪些事件？我完成了哪些事件？<br />比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>
</tr>
<tr>
<td>uxBitsToWaitFor</td>
<td>等待那个位、哪些位？<br />比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>如果期待的事件未发生，阻塞多久。<br />可以设置为0：判断后即刻返回；<br />可设置为portMAX_DELAY：一定等到成功才返回；<br />可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>
</tr>
<tr>
<td>返回值</td>
<td>返回的是事件值，<br />如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br />如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody></table>
<h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><p>所谓”任务通知”，你可以反过来读”通知任务”。</p>
<p><img src="https://img.undf.top/utools/1673877706072_dh293c8je2izndds.png"></p>
<p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p>
<h3 id="优势及限制"><a href="#优势及限制" class="headerlink" title="优势及限制"></a>优势及限制</h3><p>任务通知的优势：</p>
<ul>
<li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li>
<li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>
</ul>
<p>任务通知的限制：</p>
<ul>
<li>不能发送数据给ISR：<br>ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li>
<li>数据只能给该任务独享<br>使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。<br>在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li>
<li>无法缓冲数据<br>使用队列时，假设队列深度为N，那么它可以保持N个数据。<br>使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li>
<li>无法广播给多个任务<br>使用事件组可以同时给多个任务发送事件。<br>使用任务通知，只能发个一个任务。</li>
<li>如果发送受阻，发送方无法进入阻塞状态等待<br>假设队列已经满了，使用<code>xQueueSendToBack()</code>给队列发送数据时，任务可以进入阻塞状态等待发送完成。<br>使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li>
</ul>
<h3 id="通知状态和通知值"><a href="#通知状态和通知值" class="headerlink" title="通知状态和通知值"></a>通知状态和通知值</h3><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：</p>
<ul>
<li>一个是uint8_t类型，用来表示通知状态</li>
<li>一个是uint32_t类型，用来表示通知值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    ......</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure>



<p>通知状态有3种取值：</p>
<ul>
<li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li>
<li>taskWAITING_NOTIFICATION：任务在等待通知</li>
<li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class="comment">/* 也是初始状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure>



<p>通知值可以有很多种类型：</p>
<ul>
<li>计数值</li>
<li>位(类似事件组)</li>
<li>任意数值</li>
</ul>
<h3 id="任务通知的使用"><a href="#任务通知的使用" class="headerlink" title="任务通知的使用"></a>任务通知的使用</h3><p>使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p>
<h4 id="两类函数"><a href="#两类函数" class="headerlink" title="两类函数"></a>两类函数</h4><p>任务通知有2套函数，简化版、专业版，列表如下：</p>
<ul>
<li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li>
<li>专业版函数支持很多参数，可以实现很多功能</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>简化版</th>
<th>专业版</th>
</tr>
</thead>
<tbody><tr>
<td>发出通知</td>
<td>xTaskNotifyGive<br />vTaskNotifyGiveFromISR</td>
<td>xTaskNotify<br />xTaskNotifyFromISR</td>
</tr>
<tr>
<td>取出通知</td>
<td>ulTaskNotifyTake</td>
<td>xTaskNotifyWait</td>
</tr>
</tbody></table>
<h4 id="xTaskNotifyGive-ulTaskNotifyTake"><a href="#xTaskNotifyGive-ulTaskNotifyTake" class="headerlink" title="xTaskNotifyGive&#x2F;ulTaskNotifyTake"></a>xTaskNotifyGive&#x2F;ulTaskNotifyTake</h4><p>在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知：</p>
<ul>
<li>使得通知值加一</li>
<li>并使得通知状态变为”pending”，也就是<code>taskNOTIFICATION_RECEIVED</code>，表示有数据了、待处理</li>
</ul>
<p>可以使用ulTaskNotifyTake函数来取出通知值：</p>
<ul>
<li>如果通知值等于0，则阻塞(可以指定超时时间)</li>
<li>当通知值大于0时，任务从阻塞态进入就绪态</li>
<li>在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li>
</ul>
<p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p>
<p>这几个函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>



<p>xTaskNotifyGive函数的参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xTaskToNotify</td>
<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>
</tr>
<tr>
<td>返回值</td>
<td>必定返回pdPASS</td>
</tr>
</tbody></table>
<p>vTaskNotifyGiveFromISR函数的参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xTaskHandle</td>
<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>
</tr>
<tr>
<td>pxHigherPriorityTaskWoken</td>
<td>被通知的任务，可能正处于阻塞状态。<br />此函数发出通知后，会把它从阻塞状态切换为就绪态。<br />如果被唤醒的任务的优先级，高于当前任务的优先级，<br />则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，<br />这表示在中断返回之前要进行任务切换。</td>
</tr>
</tbody></table>
<p>ulTaskNotifyTake函数的参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xClearCountOnExit</td>
<td>函数返回前是否清零：<br />pdTRUE：把通知值清零<br />pdFALSE：如果通知值大于0，则把通知值减一</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>任务进入阻塞态的超时时间，它在等待通知值大于0。<br />0：不等待，即刻返回；<br />portMAX_DELAY：一直等待，直到通知值大于0；<br />其他值：Tick Count，可以用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>
</tr>
<tr>
<td>返回值</td>
<td>函数返回之前，在清零或减一之前的通知值。<br />如果xTicksToWait非0，则返回值有2种情况：<br />1. 大于0：在超时前，通知值被增加了<br />2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td>
</tr>
</tbody></table>
<h4 id="xTaskNotify-xTaskNotifyWait"><a href="#xTaskNotify-xTaskNotifyWait" class="headerlink" title="xTaskNotify&#x2F;xTaskNotifyWait"></a>xTaskNotify&#x2F;xTaskNotifyWait</h4><p><code>xTaskNotify</code> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p>
<ul>
<li>让接收任务的通知值加一：这时<code>xTaskNotify()</code>等同于<code>xTaskNotifyGive()</code></li>
<li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li>
<li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li>
<li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似<code>xQueueOverwrite()</code>函数，这就是轻量级的邮箱。</li>
</ul>
<p><code>xTaskNotify()</code>比<code>xTaskNotifyGive()</code>更灵活、强大，使用上也就更复杂。<code>xTaskNotifyFromISR()</code>是它对应的ISR版本。</p>
<p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p>
<p>使用<code>xTaskNotifyWait()</code>函数！它比<code>ulTaskNotifyTake()</code>更复杂：</p>
<ul>
<li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li>
<li>还可以在函数进入、退出时，清除通知值的指定位</li>
</ul>
<p>这几个函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, <span class="type">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                               eNotifyAction eAction, </span></span><br><span class="line"><span class="params">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> *pulNotificationValue, </span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>



<p>xTaskNotify函数的参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xTaskToNotify</td>
<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>
</tr>
<tr>
<td>ulValue</td>
<td>怎么使用ulValue，由eAction参数决定</td>
</tr>
<tr>
<td>eAction</td>
<td>见下表</td>
</tr>
<tr>
<td>返回值</td>
<td>pdPASS：成功，大部分调用都会成功<br />pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite，<br />                并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td>
</tr>
</tbody></table>
<p>eNotifyAction参数说明：</p>
<table>
<thead>
<tr>
<th>eNotifyAction取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eNoAction</td>
<td>仅仅是更新通知状态为”pending”，未使用ulValue。<br />这个选项相当于轻量级的、更高效的二进制信号量。</td>
</tr>
<tr>
<td>eSetBits</td>
<td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。<br />相当于轻量级的、更高效的事件组。</td>
</tr>
<tr>
<td>eIncrement</td>
<td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。<br />相当于轻量级的、更高效的二进制信号量、计数型信号量。<br />相当于<code>xTaskNotifyGive()</code>函数。</td>
</tr>
<tr>
<td>eSetValueWithoutOverwrite</td>
<td>不覆盖。<br />如果通知状态为”pending”(表示有数据未读)，<br />则此次调用xTaskNotify不做任何事，返回pdFAIL。<br />如果通知状态不是”pending”(表示没有新数据)，<br />则：通知值 &#x3D; ulValue。</td>
</tr>
<tr>
<td>eSetValueWithOverwrite</td>
<td>覆盖。<br />无论如何，不管通知状态是否为”pendng”，<br />通知值 &#x3D; ulValue。</td>
</tr>
</tbody></table>
<p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<code>pxHigherPriorityTaskWoken</code>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p>
<ul>
<li>被通知的任务，可能正处于阻塞状态</li>
<li><code>xTaskNotifyFromISR</code>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li>
<li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li>
</ul>
<p>xTaskNotifyWait函数列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ulBitsToClearOnEntry</td>
<td>在xTaskNotifyWait入口处，要清除通知值的哪些位？<br />通知状态不是”pending”的情况下，才会清除。<br />它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。<br />能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。<br />比如传入0x01，表示清除通知值的bit0；<br />传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>
</tr>
<tr>
<td>ulBitsToClearOnExit</td>
<td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时：<br />通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。<br />在清除某些位之前，通知值先被赋给”*pulNotificationValue”。<br />比如入0x03，表示清除通知值的bit0、bit1；<br />传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>
</tr>
<tr>
<td>pulNotificationValue</td>
<td>用来取出通知值。<br />在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。<br />如果不需要取出通知值，可以设为NULL。</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。<br />0：不等待，即刻返回；<br />portMAX_DELAY：一直等待，直到通知状态变为”pending”；<br />其他值：Tick Count，可以用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>
</tr>
<tr>
<td>返回值</td>
<td>1. pdPASS：成功<br />这表示xTaskNotifyWait成功获得了通知：<br />可能是调用函数之前，通知状态就是”pending”；<br />也可能是在阻塞期间，通知状态变为了”pending”。<br />2. pdFAIL：没有得到通知。</td>
</tr>
</tbody></table>
<h2 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h2><h3 id="软件定时器的特性"><a href="#软件定时器的特性" class="headerlink" title="软件定时器的特性"></a>软件定时器的特性</h3><p>我们在手机上添加闹钟时，需要指定时间、指定类型(一次性的，还是周期性的)、指定做什么事；还有一些过时的、不再使用的闹钟。</p>
<p>使用定时器跟使用手机闹钟是类似的：</p>
<ul>
<li>指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。</li>
<li>指定类型，定时器有两种类型：<ul>
<li>一次性(One-shot timers)：<br>这类定时器启动后，它的回调函数只会被调用一次；<br>可以手工再次启动它，但是不会自动启动它。</li>
<li>自动加载定时器(Auto-reload timers )：<br>这类定时器启动后，时间到之后它会自动启动它；<br>这使得回调函数被周期性地调用。</li>
</ul>
</li>
<li>指定要做什么事，就是指定回调函数</li>
</ul>
<p>实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：</p>
<ul>
<li>运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li>
<li>冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li>
</ul>
<p>定时器运行情况示例如下：</p>
<ul>
<li>Timer1：它是一次性的定时器，在t1启动，周期是6个Tick。经过6个tick后，在t7执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。</li>
<li>Timer2：它是自动加载的定时器，在t1启动，周期是5个Tick。每经过5个tick它的回调函数都被执行，比如在t6、t11、t16都会执行。</li>
</ul>
<p><img src="https://img.undf.top/utools/1673877932075_6txse7co5pok1ngf.png"></p>
<h3 id="软件定时器的上下文"><a href="#软件定时器的上下文" class="headerlink" title="软件定时器的上下文"></a>软件定时器的上下文</h3><h4 id="守护任务"><a href="#守护任务" class="headerlink" title="守护任务"></a>守护任务</h4><p>要理解软件定时器API函数的参数，特别是里面的<code>xTicksToWait</code>，需要知道定时器执行的过程。</p>
<p>FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行。在哪里执行定时器函数？第一印象就是在Tick中断里执行：</p>
<ul>
<li>在Tick中断中判断定时器是否超时</li>
<li>如果超时了，调用它的回调函数</li>
</ul>
<p>FreeRTOS是RTOS，它不允许在内核、在中断中执行不确定的代码：如果定时器函数很耗时，会影响整个系统。</p>
<p>所以，FreeRTOS中，不在Tick中断中执行定时器函数。</p>
<p>在哪里执行？在某个任务里执行，这个任务就是：RTOS Damemon Task，RTOS守护任务。以前被称为”Timer server”，但是这个任务要做并不仅仅是定时器相关，所以改名为：RTOS Damemon Task。</p>
<p>当FreeRTOS的配置项<code>configUSE_TIMERS</code>被设置为1时，在启动调度器时，会自动创建RTOS Damemon Task。</p>
<p>我们自己编写的任务函数要使用定时器时，是通过”定时器命令队列”(timer command queue)和守护任务交互，如下图所示：</p>
<p><img src="/!%5B%5D(https:/img.undf.top/utools/1673878043754_v3w2rdr4b3udx805.png)" alt="image-20210809193524596"></p>
<p>守护任务的优先级为：configTIMER_TASK_PRIORITY；定时器命令队列的长度为configTIMER_QUEUE_LENGTH。</p>
<h4 id="守护任务的调度"><a href="#守护任务的调度" class="headerlink" title="守护任务的调度"></a>守护任务的调度</h4><p>守护任务的调度，跟普通的任务并无差别。当守护任务是当前优先级最高的就绪态任务时，它就可以运行。它的工作有两类：</p>
<ul>
<li>处理命令：从命令队列里取出命令、处理</li>
<li>执行定时器的回调函数</li>
</ul>
<p>能否及时处理定时器的命令、能否及时执行定时器的回调函数，严重依赖于守护任务的优先级。下面使用2个例子来演示。</p>
<p>例子1：守护任务的优先性级较低</p>
<ul>
<li><p>t1：Task1处于运行态，守护任务处于阻塞态。<br>守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。<br>至于守护任务能否马上执行，取决于它的优先级。</p>
</li>
<li><p>t2：Task1调用<code>xTimerStart()</code><br>要注意的是，<code>xTimerStart()</code>只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。<br>在本例中，Task1的优先级高于守护任务，所以守护任务无法抢占Task1。</p>
</li>
<li><p>t3：Task1执行完<code>xTimerStart()</code><br>但是定时器的启动工作由守护任务来实现，所以<code>xTimerStart()</code>返回并不表示定时器已经被启动了。</p>
</li>
<li><p>t4：Task1由于某些原因进入阻塞态，现在轮到守护任务运行。<br>守护任务从队列中取出”start timer”命令，启动定时器。</p>
</li>
<li><p>t5：守护任务处理完队列中所有的命令，再次进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。</p>
</li>
<li><p>注意：假设定时器在后续某个时刻tX超时了，超时时间是”tX-t2”，而非”tX-t4”，从<code>xTimerStart()</code>函数被调用时算起。</p>
</li>
</ul>
<p><img src="https://img.undf.top/utools/1673878068181_kq43blmv75dwe00z.png"></p>
<p>例子2：守护任务的优先性级较高</p>
<ul>
<li><p>t1：Task1处于运行态，守护任务处于阻塞态。<br>守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。<br>至于守护任务能否马上执行，取决于它的优先级。</p>
</li>
<li><p>t2：Task1调用<code>xTimerStart()</code><br>要注意的是，<code>xTimerStart()</code>只是把”start timer”的命令发给”定时器命令队列”，使得守护任务退出阻塞态。<br>在本例中，守护任务的优先级高于Task1，所以守护任务抢占Task1，守护任务开始处理命令队列。<br>Task1在执行<code>xTimerStart()</code>的过程中被抢占，这时它无法完成此函数。</p>
</li>
<li><p>t3：守护任务处理完命令队列中所有的命令，再次进入阻塞态。<br>此时Task1是优先级最高的就绪态任务，它开始执行。</p>
</li>
<li><p>t4：Task1之前被守护任务抢占，对<code>xTimerStart()</code>的调用尚未返回。现在开始继续运行次函数、返回。</p>
</li>
<li><p>t5：Task1由于某些原因进入阻塞态，进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。</p>
</li>
</ul>
<p><img src="/pic/chap10/05_demon_task_priority_higher.png" alt="image-20210809161518141"></p>
<p>注意，定时器的超时时间是基于调用<code>xTimerStart()</code>的时刻tX，而不是基于守护任务处理命令的时刻tY。假设超时时间是10个Tick，超时时间是”tX+10”，而非”tY+10”。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>定时器的回调函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>

<p>定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。</p>
<p>所以，定时器的回调函数不要影响其他人：</p>
<ul>
<li><p>回调函数要尽快实行，不能进入阻塞状态</p>
</li>
<li><p>不要调用会导致阻塞的API函数，比如<code>vTaskDelay()</code></p>
</li>
<li><p>可以调用<code>xQueueReceive()</code>之类的函数，但是超时时间要设为0：即刻返回，不可阻塞</p>
</li>
</ul>
<h3 id="软件定时器的函数"><a href="#软件定时器的函数" class="headerlink" title="软件定时器的函数"></a>软件定时器的函数</h3><p>根据定时器的状态转换图，就可以知道所涉及的函数：</p>
<p><img src="https://img.undf.top/utools/1673878093734_wd0b1lpwo1bkxt5n.png"></p>
<h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><p>要使用定时器，需要先创建它，得到它的句柄。</p>
<p>有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用动态分配内存的方法创建定时器</span></span><br><span class="line"><span class="comment"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class="line"><span class="comment"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class="line"><span class="comment"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment"> * pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName, </span></span><br><span class="line"><span class="params">							<span class="type">const</span> TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">							<span class="type">const</span> UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">							<span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span><br><span class="line"><span class="params">							TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用静态分配内存的方法创建定时器</span></span><br><span class="line"><span class="comment"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class="line"><span class="comment"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class="line"><span class="comment"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment"> * pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment"> * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器</span></span><br><span class="line"><span class="comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreateStatic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                                 TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> * pvTimerID,</span></span><br><span class="line"><span class="params">                                 TimerCallbackFunction_t pxCallbackFunction,</span></span><br><span class="line"><span class="params">                                 StaticTimer_t *pxTimerBuffer )</span>;</span><br></pre></td></tr></table></figure>



<p>回调函数的类型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* TimerCallbackFunction_t)</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><p>动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 要删除哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>定时器的很多API函数，都是通过发送”命令”到命令队列，由守护任务来实现。</p>
<p>如果队列满了，”命令”就无法即刻写入队列。我们可以指定一个超时时间<code>xTicksToWait</code>，等待一会。</p>
<h4 id="启动-停止"><a href="#启动-停止" class="headerlink" title="启动&#x2F;停止"></a>启动&#x2F;停止</h4><p>启动定时器就是设置它的状态为运行态(Running、Active)。</p>
<p>停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。</p>
<p>涉及的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 启动定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStartFromISR</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStopFromISR</span><span class="params">(    TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这些函数的<code>xTicksToWait</code>表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。</p>
<p><code>xTicksToWait</code>不是定时器本身的超时时间，不是定时器本身的”周期”。</p>
<p>创建定时器时，设置了它的周期(period)。<code>xTimerStart()</code>函数是用来启动定时器。假设调用<code>xTimerStart()</code>的时刻是tX，定时器的周期是n，那么在<code>tX+n</code>时刻定时器的回调函数被调用。</p>
<p>如果定时器已经被启动，但是它的函数尚未被执行，再次执行<code>xTimerStart()</code>函数相当于执行<code>xTimerReset()</code>，重新设定它的启动时间。</p>
<h4 id="复位-1"><a href="#复位-1" class="headerlink" title="复位"></a>复位</h4><p>从定时器的状态转换图可以知道，使用<code>xTimerReset()</code>函数可以让定时器的状态从冬眠态转换为运行态，相当于使用<code>xTimerStart()</code>函数。</p>
<p>如果定时器已经处于运行态，使用<code>xTimerReset()</code>函数就相当于重新确定超时时间。假设调用<code>xTimerReset()</code>的时刻是tX，定时器的周期是n，那么<code>tX+n</code>就是重新确定的超时时间。</p>
<p>复位函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 复位定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复位定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerResetFromISR</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="修改周期"><a href="#修改周期" class="headerlink" title="修改周期"></a>修改周期</h4><p>从定时器的状态转换图可以知道，使用<code>xTimerChangePeriod()</code>函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</p>
<p>修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用<code>xTimerChangePeriod()</code>函数的时间tX，新的周期是n，则<code>tX+n</code>就是新的超时时间。</p>
<p>相关函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改定时器的周期</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间, 命令写入队列的超时时间 </span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改定时器的周期</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriodFromISR</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                      TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>



<h4 id="定时器ID"><a href="#定时器ID" class="headerlink" title="定时器ID"></a>定时器ID</h4><p>定时器的结构体如下，里面有一项<code>pvTimerID</code>，它就是定时器ID：</p>
<p><img src="https://img.undf.top/utools/1673878165302_vn9b11k5d1g8o3jb.png"></p>
<p>怎么使用定时器ID，完全由程序来决定：</p>
<ul>
<li>可以用来标记定时器，表示自己是什么定时器</li>
<li>可以用来保存参数，给回调函数使用</li>
</ul>
<p>它的初始值在创建定时器时由<code>xTimerCreate()</code>这类函数传入，后续可以使用这些函数来操作：</p>
<ul>
<li>更新ID：使用<code>vTimerSetTimerID()</code>函数</li>
<li>查询ID：查询<code>pvTimerGetTimerID()</code>函数</li>
</ul>
<p>这两个函数不涉及命令队列，它们是直接操作定时器结构体。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获得定时器的ID</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * 返回值: 定时器的ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置定时器的ID</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pvNewID: 新ID</span></span><br><span class="line"><span class="comment"> * 返回值: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTimerSetTimerID</span><span class="params">( TimerHandle_t xTimer, <span class="type">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure>

<h2 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h2><h3 id="两套API函数"><a href="#两套API函数" class="headerlink" title="两套API函数"></a>两套API函数</h3><h4 id="为什么需要两套API"><a href="#为什么需要两套API" class="headerlink" title="为什么需要两套API"></a>为什么需要两套API</h4><p>在任务函数中，我们可以调用各类API函数，比如队列操作函数：xQueueSendToBack。但是在ISR中使用这个函数会导致问题，应该使用另一个函数：xQueueSendToBackFromISR，它的函数名含有后缀”FromISR”，表示”从ISR中给队列发送数据”。</p>
<p>FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名含有”FromISR”后缀。</p>
<p>为什么要引入两套API函数？</p>
<ul>
<li>很多API函数会导致任务计入阻塞状态：<ul>
<li>运行这个函数的<strong>任务</strong>进入阻塞状态</li>
<li>比如写队列时，如果队列已满，可以进入阻塞状态等待一会</li>
</ul>
</li>
<li>ISR调用API函数时，ISR不是”任务”，ISR不能进入阻塞状态</li>
<li>所以，在任务中、在ISR中，这些函数的功能是有差别的</li>
</ul>
<p>为什么不使用同一套函数，比如在函数里面分辨当前调用者是任务还是ISR呢？示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_in_isr())</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">/* 把数据放入队列 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 不管是否成功都直接返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 在任务中 */</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">/* 把数据放入队列 */</span></span><br><span class="line">        <span class="comment">/* 不成功就等待一会再重试 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FreeRTOS使用两套函数，而不是使用一套函数，是因为有如下好处：</p>
<ul>
<li><p>使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，是的函数更长、更复杂、难以测试</p>
</li>
<li><p>在任务、ISR中调用时，需要的参数不一样，比如：</p>
<ul>
<li>在任务中调用：需要指定超时时间，表示如果不成功就阻塞一会</li>
<li>在ISR中调用：不需要指定超时时间，无论是否成功都要即刻返回</li>
<li>如果强行把两套函数揉在一起，会导致参数臃肿、无效</li>
</ul>
</li>
<li><p>移植FreeRTOS时，还需要提供监测上下文的函数，比如<code>is_in_isr()</code></p>
</li>
<li><p>有些处理器架构没有办法轻易分辨当前是处于任务中，还是处于ISR中，就需要额外添加更多、更复杂的代码</p>
</li>
</ul>
<p>使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR总调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。这个问题可以解决：</p>
<ul>
<li>把中断的处理推迟到任务中进行(Defer interrupt  processing)，在任务中调用库函数</li>
<li>尝试在库函数中使用”FromISR”函数：<ul>
<li>在任务中、在ISR中都可以调用”FromISR”函数</li>
<li>反过来就不行，非FromISR函数无法在ISR中使用</li>
</ul>
</li>
<li>第三方库函数也许会提供OS抽象层，自行判断当前环境是在任务还是在ISR中，分别调用不同的函数</li>
</ul>
<h4 id="两套API函数列表"><a href="#两套API函数列表" class="headerlink" title="两套API函数列表"></a>两套API函数列表</h4><table>
<thead>
<tr>
<th>类型</th>
<th>在任务中</th>
<th>在ISR中</th>
</tr>
</thead>
<tbody><tr>
<td>队列(queue)</td>
<td>xQueueSendToBack</td>
<td>xQueueSendToBackFromISR</td>
</tr>
<tr>
<td></td>
<td>xQueueSendToFront</td>
<td>xQueueSendToFrontFromISR</td>
</tr>
<tr>
<td></td>
<td>xQueueReceive</td>
<td>xQueueReceiveFromISR</td>
</tr>
<tr>
<td></td>
<td>xQueueOverwrite</td>
<td>xQueueOverwriteFromISR</td>
</tr>
<tr>
<td></td>
<td>xQueuePeek</td>
<td>xQueuePeekFromISR</td>
</tr>
<tr>
<td>信号量(semaphore)</td>
<td>xSemaphoreGive</td>
<td>xSemaphoreGiveFromISR</td>
</tr>
<tr>
<td></td>
<td>xSemaphoreTake</td>
<td>xSemaphoreTakeFromISR</td>
</tr>
<tr>
<td>事件组(event group)</td>
<td>xEventGroupSetBits</td>
<td>xEventGroupSetBitsFromISR</td>
</tr>
<tr>
<td></td>
<td>xEventGroupGetBits</td>
<td>xEventGroupGetBitsFromISR</td>
</tr>
<tr>
<td>任务通知(task notification)</td>
<td>xTaskNotifyGive</td>
<td>vTaskNotifyGiveFromISR</td>
</tr>
<tr>
<td></td>
<td>xTaskNotify</td>
<td>xTaskNotifyFromISR</td>
</tr>
<tr>
<td>软件定时器(software timer)</td>
<td>xTimerStart</td>
<td>xTimerStartFromISR</td>
</tr>
<tr>
<td></td>
<td>xTimerStop</td>
<td>xTimerStopFromISR</td>
</tr>
<tr>
<td></td>
<td>xTimerReset</td>
<td>xTimerResetFromISR</td>
</tr>
<tr>
<td></td>
<td>xTimerChangePeriod</td>
<td>xTimerChangePeriodFromISR</td>
</tr>
</tbody></table>
<h4 id="xHigherPriorityTaskWoken参数"><a href="#xHigherPriorityTaskWoken参数" class="headerlink" title="xHigherPriorityTaskWoken参数"></a>xHigherPriorityTaskWoken参数</h4><p>xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。</p>
<p>还是以写队列为例。</p>
<p>任务A调用<code>xQueueSendToBack()</code>写队列，有几种情况发生：</p>
<ul>
<li>队列满了，任务A阻塞等待，另一个任务B运行</li>
<li>队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行</li>
<li>队列没满，任务A成功写入队列，即刻返回</li>
</ul>
<p>可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做”context switch”，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。</p>
<p><code>xQueueSendToBackFromISR()</code>函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法示例 */</span></span><br><span class="line"></span><br><span class="line">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">xQueueSendToBackFromISR(xQueue, pvItemToQueue, &amp;xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 任务切换 */</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换</p>
<ul>
<li>*pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换</li>
<li>*pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要</li>
</ul>
<p>为什么不在”FromISR”函数内部进行任务切换，而只是标记一下而已呢？为了效率！示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(...); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISR中有可能多次调用”FromISR”函数，如果在”FromISR”内部进行任务切换，会浪费时间。解决方法是：</p>
<ul>
<li>在”FromISR”中标记是否需要切换</li>
<li>在ISR返回之前再进行任务切换</li>
<li>示例代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(..  &amp;xHigherPriorityTaskWoken); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 最后再决定是否进行任务切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">/* 任务切换 */</span>    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。</p>
<p>在ISR中调用API时不进行任务切换，而只是在”xHigherPriorityTaskWoken”中标记一下，除了效率，还有多种好处：</p>
<ul>
<li>效率高：避免不必要的任务切换</li>
<li>让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂</li>
<li>可移植性</li>
<li>在Tick中断中，调用<code>vApplicationTickHook()</code>：它运行与ISR，只能使用”FromISR”的函数</li>
</ul>
<p>使用”FromISR”函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。</p>
<h4 id="怎么切换任务"><a href="#怎么切换任务" class="headerlink" title="怎么切换任务"></a>怎么切换任务</h4><p>FreeRTOS的ISR函数中，使用两个宏进行任务切换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">或</span><br><span class="line">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br></pre></td></tr></table></figure>

<p>这两个宏做的事情是完全一样的，在老版本的FreeRTOS中，</p>
<ul>
<li><code>portEND_SWITCHING_ISR</code>使用汇编实现</li>
<li><code>portYIELD_FROM_ISR</code>使用C语言实现</li>
</ul>
<p>新版本都统一使用<code>portYIELD_FROM_ISR</code>。</p>
<p>使用示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(..  &amp;xHigherPriorityTaskWoken); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 最后再决定是否进行任务切换 </span></span><br><span class="line"><span class="comment">     * xHigherPriorityTaskWoken为pdTRUE时才切换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中断的延迟处理"><a href="#中断的延迟处理" class="headerlink" title="中断的延迟处理"></a>中断的延迟处理</h3><p>前面讲过，ISR要尽量快，否则：</p>
<ul>
<li>其他低优先级的中断无法被处理：实时性无法保证</li>
<li>用户任务无法被执行：系统显得很卡顿 </li>
<li>如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套</li>
</ul>
<p>如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：</p>
<ul>
<li>ISR：尽快做些清理、记录工作，然后触发某个任务</li>
<li>任务：更复杂的事情放在任务中处理</li>
</ul>
<p>这种处理方式叫”中断的延迟处理”(Deferring interrupt processing)，处理流程如下图所示：</p>
<ul>
<li>t1：任务1运行，任务2阻塞</li>
<li>t2：发生中断，<ul>
<li>该中断的ISR函数被执行，任务1被打断</li>
<li>ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2</li>
</ul>
</li>
<li>t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为”deferred processing task”，中断的延迟处理任务。</li>
<li>t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行</li>
</ul>
<p><img src="https://img.undf.top/utools/1673878428670_9qjlufv5a7dozv2z.png"></p>
<h3 id="中断与任务间的通信"><a href="#中断与任务间的通信" class="headerlink" title="中断与任务间的通信"></a>中断与任务间的通信</h3><p>前面讲解过的队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。</p>
<p>要注意的是，在ISR中使用的函数要有”FromISR”后缀。</p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h3><p>屏蔽中断有两套宏：任务中使用、ISR中使用：</p>
<ul>
<li>任务中使用：<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code></li>
<li>ISR中使用：<code>taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code></li>
</ul>
<h4 id="在任务中屏蔽中断"><a href="#在任务中屏蔽中断" class="headerlink" title="在任务中屏蔽中断"></a>在任务中屏蔽中断</h4><p>在任务中屏蔽中断的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在任务中，当前时刻中断是使能的</span></span><br><span class="line"><span class="comment"> * 执行这句代码后，屏蔽中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新使能中断 */</span></span><br><span class="line">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure>

<p>在<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>之间：</p>
<ul>
<li>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></li>
<li>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code><ul>
<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>
</ul>
</li>
<li>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</li>
</ul>
<p>这套<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用<code>taskEXIT_CRITICAL()</code>才会重新使能中断。</p>
<p>使用<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code>来访问临界资源是很粗鲁的方法：</p>
<ul>
<li>中断无法正常运行</li>
<li>任务调度无法进行</li>
<li>所以，之间的代码要尽可能快速地执行</li>
</ul>
<h4 id="在ISR中屏蔽中断"><a href="#在ISR中屏蔽中断" class="headerlink" title="在ISR中屏蔽中断"></a>在ISR中屏蔽中断</h4><p>要使用含有”FROM_ISR”后缀的宏，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAnInterruptServiceRoutine</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  ## 用来记录当前中断是否使能 */</span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line">    </span><br><span class="line">  ## 在ISR中，当前时刻中断可能是使能的，也可能是禁止的</span><br><span class="line">## * 所以要记录当前状态, 后面要恢复为原先的状态</span><br><span class="line">## * 执行这句代码后，屏蔽中断</span><br><span class="line">## */</span><br><span class="line">    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line">    </span><br><span class="line">  ## 访问临界资源 */</span><br><span class="line"></span><br><span class="line">  ## 恢复中断状态 */</span><br><span class="line">    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line">  ## 现在，当前ISR可以被更高优先级的中断打断了 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>taskENTER_CRITICA_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code>之间：</p>
<ul>
<li>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></li>
<li>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code><ul>
<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>
</ul>
</li>
<li>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</li>
</ul>
<h1 id="暂停调度器"><a href="#暂停调度器" class="headerlink" title="暂停调度器"></a>暂停调度器</h1><p>如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。</p>
<p>如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。</p>
<p>使用这2个函数来暂停、恢复调度器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 暂停调度器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复调度器</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了</span></span><br><span class="line"><span class="comment"> *##    可以不理会这个返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>



<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vTaskSuspendScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">xTaskResumeScheduler();</span><br></pre></td></tr></table></figure>



<p>这套<code>vTaskSuspendScheduler()/xTaskResumeScheduler()</code>宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用<code>taskEXIT_CRITICAL()</code>才会重新使能中断。</p>
<p><a target="_blank" rel="noopener" href="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/index.html">参考原文地址</a></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://c.undf.top/posts/1rvt88k/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://c.undf.top/posts/1rvt88k/&title=FreeRTOS - 沐印小站&pics=https://img.undf.top/image/FreeRTOS/2022-04-28-21-14-24.png&summary=
大部分内容都为摘抄其实已经看过很多遍，但一直没用过。

内存管理task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存..."><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=FreeRTOS - 沐印小站&amp;body=https://c.undf.top/posts/1rvt88k/"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://c.undf.top/posts/1rvt88k/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/posts/2llqu4i/">ROS2自定义消息使用记录</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/posts/6679f469/">2022照片故事分享</a></div></section></div>

<div class="related-wrap" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="/posts/a583/" title="AHK脚本"><span class="title">AHK脚本</span><span class="excerpt">⌨️AHK 键盘脚本</span></a></div></section></div>


  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body twikoo'>
      

<div id="twikoo_container"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>
    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">@wxy</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
<div class="main-mask" onclick="sidebar.toggle()"></div></div></div><div class="scripts">
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.26.1';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.undf.top/js/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.undf.top/js/marked.min.js");
  // optional plugins
  if ('false' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":false,"js":"https://cdn.undf.top/js/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://cdn.undf.top/js/swiper-bundle.min.css","js":"https://cdn.undf.top/js/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.undf.top/js/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","flying_pages":"https://cdn.undf.top/js/flying-pages.min.js","instant_page":"https://cdn.undf.top/js/instant_page.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://cdn.undf.top/js/fancybox.umd.js","css":"https://cdn.undf.top/js/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://cdn.undf.top/js/heti.min.css","js":"https://cdn.undf.top/js/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.26.8" async></script>

<!-- optional -->

  <script>
    function load_twikoo() {
        if (!document.querySelectorAll("#twikoo_container")[0]) return;
        stellar.loadScript('https://cdn.undf.top/js/twikoo.min.js', {defer: true}).then(function () {
            const el = document.getElementById("twikoo_container");
            var path = el.getAttribute('comment_id');
            if (!path) {
                path = decodeURI(window.location.pathname);
            }
            twikoo.init(Object.assign({"js":"https://cdn.undf.top/js/twikoo.min.js","envId":"https://twikoo.undf.top"}, {
                el: '#twikoo_container',
                path: path,
            }));
        });
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        load_twikoo();
    });
</script>






<!-- inject -->
<script src="https://c.undf.top/cdn/haoke/haoke.min.js"></script>
</div></body></html>
