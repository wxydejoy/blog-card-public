<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/icon/favicon.ico">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/icon/favicon-16x16.png">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/icon/favicon-32x32.png">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/icon/apple-touch-icon-180x180.png">
    
    
        <link rel="mask-icon" href="/icon/apple-touch-icon-180x180.png">
    


    <!-- meta -->


<title>I2C接口及其应用 | 快乐星球</title>





    <!-- OpenGraph -->


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/dark.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.4.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">Welcome</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/friends/" class="navbar-menu button">友链</a>
                
                    <a target="_blank" rel="noopener" href="https://bf.wxydejoy.top/" class="navbar-menu button">分站</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/friends/" class="dropdown-menu button">友链</a>
                
                    <a target="_blank" rel="noopener" href="https://bf.wxydejoy.top/" class="dropdown-menu button">分站</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        I2C接口及其应用
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2021/08/" class="post-meta__date button">2021-08-04</a>
        
    <span class="separate-dot"></span><a href="/categories/%F0%9F%93%9A%EF%B8%8F-Study/" class="button">📚️ Study</a>

 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-I2C%E9%80%9A%E8%AE%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">5.1 I2C通讯接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-I2C%E4%B8%BB%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">5.2 I2C主机模式</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-I2C%E9%80%9A%E8%AE%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">5.1 I2C通讯接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-I2C%E4%B8%BB%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">5.2 I2C主机模式</span></a></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header">
    <div class="post__expire" id="post-expired-notify">
        <p>
            本文最后更新于 &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; 天前，文中部分描述可能已经过时。
        </p>
    </div>
    <script>
        (() => {
            var update = Date.parse("2021-10-05"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script>
</div>
    <div class="post__content">
        <h1 id="I2C接口及其应用"><a href="#I2C接口及其应用" class="headerlink" title="I2C接口及其应用"></a>I2C接口及其应用</h1><p>总线(Bus)是计算机世界的关键概念，数据总线、地址总线、控制总线(统称三总线)等用于MCU片内的CPU、存储器和I/O功能单元之间互联，我们熟悉的USB、Ethernet等通讯总线常用于系统间通讯(将在第9章了解这些总线)，</p>
<p>还有一些我们不熟悉但用来连接嵌入式系统内部组件的重要总线，过去我们通常把MCU片上的三总线延伸到片外用于连接系统内组件，这种伪共享型并行总线不仅占用很多I/O引脚，</p>
<p>还使得MCU的片外功能组件占用很大的PCB面积，除了高带宽和大数据量的视觉传感器、大屏幕高分辨率的点阵显示器等组件仍在使用此类总线外，<br>现今的大多数嵌入式系统内组件都使用少信号线的通讯总线。</p>
<p>嵌入式系统内部(组件之间)的数字通讯总线接口主要包括1-Wire(单总线)、2-Wire(即I2C)、SPI(3-/4-Wire)、I2S(IC之间音频总线)和TTL异步串口等。除了I2S和异步串口之外，其他通讯接口所使用的信号线个数如其名称。I2S与I2C一样都由Philips电子部门提出，I2S专门用于PCM(脉冲编码调制)等音频数据传输，一般使用3或4根信号线即可传输单声道或立体声音频数据。</p>
<p>异步串口不仅用于嵌入式系统内部的组件之间也用于嵌入式系统之间通讯，譬如我们使用该接口实现BlueFi与电脑之间传输数据，双工的异步串口使用独立的数据发送和接收信号线，单工通讯则只需要其中一根信号线即可，我们将在第7章详细了解该接口。SPI接口是一种多组件伪共享的总线，但每个从组件必须有额外独立的片选(Chip Select)，第6章将会详细探讨该接口。I2C(集成电路互联接口)和单总线都是真正的多组件共享总线，分别使用2根和1根信号线即可连接上百个嵌入式系统组件。</p>
<p>本章将详细了解I2C主从设备的接口单元结构组成和工作原理、通讯时序和协议、主/从模式的工作流程和编程控制，并以BlueFi板载的温湿度、加速度和陀螺仪等传感器为例掌握I2C类组件的接口应用和编程。</p>
<p> 通讯接口相关的基础概念：</p>
<ol>
<li><strong>双工</strong>，允许通讯双方之间互相传输数据。按通讯收发机制又分为全双工和半双工</li>
<li><strong>全双工</strong>，允许通讯双方同时互相发送和接收数据，这意味着通讯接口拥有2各独立的信息收发通道</li>
<li><strong>半双工</strong>，允许通讯双方互相传输数据，但任意时刻仅允许一个发送者(另一个则为接收者)</li>
<li><strong>单工</strong>，只允许单方向传输数据，通讯双发的角色是固定的：一个发送者，一个接收者</li>
<li><strong>并行通讯</strong>，传统的三总线是典型的并行通讯，每一个时钟周期能够传输半字节/整字节/多字节(由数据总线宽度决定)信息</li>
<li><strong>串行通讯</strong>，每一个时钟周期只能传输单个二进制位，将待传输的数据按MSB(最高位)到LSB(最低位)或反之的顺序逐位传输</li>
<li><strong>同步串行通讯</strong>，使用独立的数据线和同步时钟线的串行通讯接口，每一个数据位时钟与一个时钟对齐</li>
<li><strong>异步串行通讯</strong>，无同步时钟线，仅用一根数据线的串行通讯接口，仅使用一个或若干个特殊同步位来对齐字节数据</li>
</ol>
<h2 id="5-1-I2C通讯接口"><a href="#5-1-I2C通讯接口" class="headerlink" title="5.1 I2C通讯接口"></a>5.1 I2C通讯接口</h2><p>I2C是一种典型的同步串行通讯接口，单个接口支持单主多从、多主多从(但任何时刻仅有一个主机)等模态的多组件间半双工通讯。虽然I2C协议支持多主多从的模态，<br>但实际应用中绝大多数几乎都是单主多从模态，本章仅限这种常见的I2C模态。</p>
<p>上世纪80年代Philips电子部门定义I2C(Inter-Integrated Circuit的缩写)通讯总线的主要目的是用于连接计算机周边的音频和视频等低速设备，<br>最初定义的通讯时钟速度是100KHz(那个时候的音视频数据流极地)，I2C发展到今天已经支持100KHz、400KHz、1MHz、3.4MHz和5MHz等多种时钟速度。<br>现存很多种派生型I2C接口，最著名的是Intel提出的SMBus(系统管理总线)，目前仍用于计算机周边设备接口的配置等领域，<br>譬如现在所开发的音视频设备、视觉传感器和点阵图形显示器接口中常用I2C或SMBus作为这些设备的参数配置通讯接口。</p>
<p>随着嵌入式计算机系统和物联网的飞速发展，I2C逐步成为系统内各功能组件之间最常见的互联总线之一，仅占用MCU的2个I/O引脚就可以将系统内的最高达128个组件连接起来。<br>I2C是真正的多组件共享总线，不仅占用极少的MCU资源，嵌入式系统PCB板的布局和走线也非常简单。图5.1是BlueFi开源板上的4种传感器与主控制器之间的连接示意图。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-19-55-44.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-19-55-44.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-19-55-44"></p>
<p>图5.1  BlueFi开源板上4种传感器的接口电路</p>
<p>理论上，单个I2C接口能够连接高达128个组件。这需要每一个组件拥有一个惟一的7位地址码，称之为I2C从地址，图5.1中的每种I2C接口传感器拥有惟一的从地址。<br>这意味着，同一个型号的I2C接口组件不能同时连接到单个I2C接口上，除非他的I2C从地址是可配置的。譬如，NXP的16通道PWM控制器——PCA9685采用I2C接口且具有3个从地址配置输入引脚，<br>意味着他可以配置为8种不同从地址，单个I2C接口总线上允许最多连接8个PCA9685器件(其基地址为0x40，可配置的从地址为0x40~0x47)。也有很多I2C器件的从地址是不可配置的，<br>譬如抗疫期间常用的一种24x32阵列红外温度传感器(IR array thermal sensors)——Melexis的MLX90640，其惟一的从地址为0x33，单个I2C接口上只能连接一个这种传感器，<br>如果想要在一个热成像系统内同时使用多个这种阵列传感器以成倍地提升成像的像素数，如何设计传感器接口才能满足需求呢？本章的学习将会帮助我们实现这一目标。</p>
<p>I2C接口的两个信号分别称作SCL和SDA，SCL是主设备输出的同步时钟信号，SDA是双向的串行数据信号。虽然SCL是单方向的信号，只能从主设备输出，<br>但为支持多主多从模态，实际的I2C接口单元的SCL信号仍被定义成双向的。I2C能够实现真正的多组件共享总线应归功于独特的“线与(wire-AND)”接口设计，<br>如图5.1所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-19-56-34.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-19-56-34.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-19-56-34"></p>
<p>图5.2  共享总线的“线与”接口电路</p>
<p>上图中两个“线与”接口信号的外部上拉电阻是必须的，上拉电阻的阻值选择与该接口的互联设备数量、传输线长度、分布电容和通讯速度等有关，一般在2K~47K欧之间。图中使用MOS仅是原理性示意的目的，<br>实际I2C接口组件的硬件实现又多种选择，譬如使用三态门电路。当主机发送-从机接收数据位流时，数据位流的“1”/“0”被转换为“高”/“低”电平随着同步时钟信号SCL而顺序地出现在SDA上，<br>SCL和SDA两个信号都由I2C主机驱动，I2C从机根据SCL信号同步地逐位锁存数据位流信号并形成字节数据。当从机发送-主机接收数据位流时，<br>I2C主机输出同步时钟信号SCL给工作中的从机，I2C从机根据SCL信号同步地将待传输的数据位流逐位地发送到SDA上，同时I2C主机同步地接收数据位流。</p>
<p>虽然同步发送和接收数据位流的描述有点拗口，但具体的实现却非常简单，如果你能记起数字电路课程所掌握的“移位寄存器”的概念。I2C接口的移位寄存器仅有8位宽度，<br>这是因为I2C接口采用单字节的数据帧格式。I2C支持多字节连续读或写操作，但始终保持单字节帧，相邻的字节帧之间必须有一个接收者的应答位(ACK)。按通讯领域的规则，<br>这个接收者的ACK位是帧同步的目的。</p>
<p>为了更好地理解通讯协议中的“同步”，需要对I2C接口传输数据帧(字节)的时序稍作了解，如图5.3所示，(a)给出单帧/单字节的数据传输时序，(b)给出2(或更多)帧/字节的数据传输时序。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-19-56-56.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-19-56-56.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-19-56-56"></p>
<p>图5.3  I2C接口传输数据的时序(/协议)</p>
<p>对于I2C通讯接口的数据帧传输，不必刻意区分时序和通讯协议，虽然时序仅规定总线上信号之间时空关系，通讯协议却是更宽泛的概念。<br>I2C接口的每一次数据传输必须以“START”时序开始并以“STOP”时序终止，由于I2C接口仅支持单字节的数据帧，每帧/字节数据必须以数据接收者的“ACK”为结束。<br>“START”、“STOP”、“ACK”的作用都是为了“同步”目的，对比单字节和两字节传输时序时会发现“ACK”尤为重要，完全可以把“ACK”理解为字节同步位。<br>正是这些特殊的同步状态才让I2C通讯接口更加可靠、稳定。</p>
<p>值得注意的是，I2C通讯接口传输数据位的顺序按最高位(MSB)先发送、最低位(LSB)最后发送。这在上图中已明确标示。</p>
<p>I2C通讯接口的连续读/写操作是指，从I2C从机上读取某些连续地址的寄存器内容时，或者向I2C从机上某些连续地址的寄存器顺序地写入内容时，I2C主机首先传输给从机一个待读/待写的寄存器起始地址(仍可以是8/16/32位地址信息)，<br>然后读取/写入第一个字节，接收者给出“ACK”，接着继续读取/写入下一个字节，接收者给出“ACK”，如此重复直到连续读/写操作完毕，期间不必再指定读取/写入的寄存器地址，<br>因为每读/写一个字节之后，下一个寄存器地址默认是前一个操作的地址自增1。</p>
<p>高效率的批量读/写操作的支持，源于I2C通讯接口组件的RAM型寄存器映射机制。从图5.3可以看出，单字节或连续多字节的数据传输期间，要求主机和从机都是“Ready”状态，<br>不允许任何“Wating”状态迫使暂停传输，这就要求主机读操作期间从机上的待读数据是全部“Ready”状态，主机写操作期间从机上的待写入寄存器也全部“Ready”状态。<br>显然，这就要求主机和从机上所有的I2C通讯接口的寄存器具有RAM的操作特性。现今的半导体技术，满足这一要求是非常容易的。对于I2C通讯接口单元的硬件实现，<br>目前普遍采用有限状态机(FSM)和RAM型寄存器的组合，这样设计不仅将传输控制和数据流分离(更容易实现)，允许I2C接口的功能组件内部单元也采用存储器映射机制(在第2章已探讨过)。<br>譬如，一个I2C接口的数字湿度传感器，湿度信号转换(成电信号)、采集(ADC)和滤波等过程由湿度采样控制的状态机按照设定的采样周期自治地工作，并将每次采样结果自动保存在特定地址的寄存器内，<br>当I2C主机需要读取湿度信息时，湿度传感器直接输出最新更新的湿度值，I2C主机无需启动再等待数百毫秒后读取湿度结果。</p>
<p>如图5.4，I2C通讯接口的主机，通常可以理解为MCU的片上I2C接口功能单元；I2C通讯接口从机的片内功能单元的配置、数据/状态等都被映射到寄存器区；<br>主机通过读/写寄存器实现对从机的控制和数据/状态的获取。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-19-57-19.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-19-57-19.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-19-57-19"></p>
<p>图5.4  I2C通讯接口的主机和从机的结构组成</p>
<p>现在我们可以来回答“I2C从地址为什么是7位？” 当主机需要访问某个从机的某个/某些寄存器时，首先发出7位从地址和1位“R/W”组成的“读/写指定从地址”的指令帧，<br>当“R/W=1”时为读，反之为写。与从地址匹配的从机被选择，即被选中的从机的传输控制状态机被激活。</p>
<p>接着主机发出寄存器地址信息帧，根据从机上寄存器资源(和从机的功能)的多少，或许超过1个字节就需要使用批量传输模式，被选中的从机将会把接收到的地址信息传入地址译码器，<br>于是对应地址的寄存器被选择。现在我们的I2C接口主机已经选择指定的从机及其内部的寄存器。</p>
<p>最后，主机和从机的传输控制状态机将会根据第一帧的“R/W”位信息完成进一步操作。如果“R/W=1”，主机驱动SCL输出同步时钟信号，从机上被选择的寄存器内容自动填入输出移位寄存器，<br>并随着SCL同步时钟逐位顺序地输出到SDA线上，主机驱动SCL的同时会在SCL下降沿出采样SDA线并移入输出移位寄存器。如果“R/W=0”，主机驱动SCL输出同步时钟信号，<br>同时在SCL低电平期间将输出移位寄存器的内容逐位顺序地输出到SDA线上，同时从机随着SCL同步时钟信号采样SDA线并移入输入移位寄存器，一个字节传输完毕后，<br>将输入移位寄存器的字节内容保存到被选择寄存器中。</p>
<p>简而言之，一次I2C通讯接口操作包括三步，主机使用7位从机地址和读/写控制位选中I2C总线上的从机，然后指定从机的寄存器(起始)地址，最后读/写从机的寄存器。<br>使用从机惟一地址编码的寻址方法，与传统三总线接口、SPI接口等伪共享总线相比，I2C接口没有专用的从机选择信号线，既节约MCU的I/O引脚又能简化PCB布板。<br>当我们认识到真正的共享总线型I2C通讯接口带来的方便时，或许也会遇到另外一些困难(好坏总是相伴而来)，譬如一个系统内I2C组件的电平电压、时钟速度等不一致。</p>
<p>遇到接口两端的电平电压不一致时，通常会想到使用电平转换逻辑门(Level shifter)来解决，但在I2C通讯接口的总线上使用的电平转换必须支持双向传输!<br>一种简易的支持双向传输的电平转换接口可用于I2C总线 [2]_ ，如图5.5所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-19-57-32.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-19-57-32.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-19-57-32"></p>
<p>图5.5  使用电平转换电路让I2C通讯接口支持不同电平电压</p>
<p>如果设计系统时遇到多个从机的时钟速度不一致的问题，留给你来解决。<br>前面我们已经初步了解I2C通讯接口的硬件和时序，包括总线架构、线与和移位寄存器结构、时序/协议、RAM型存储器映射及访问、电平匹配等。<br>I2C通讯接口软件如何实现呢？尤其面对一个系统或单个I2C接口上连接着很多个I2C接口的功能组件时，合理封装接口软件是非常重要的。<br>我们仍然使用分层抽象的思想来封装I2C接口软件，如图5.6所示。<br><img src="https://image.wxydejoy.top/img/I2C2021-08-04-19-57-41.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-19-57-41.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-19-57-41"></p>
<p>图5.6  I2C通讯接口软件分层封装</p>
<p>I2C接口的硬件层，除了硬件电路设计前需查阅具体的MCU那些I/O引脚可用于I2C接口，以及系统所用的I2C组件的电平电压是否一致外，其他工作几乎都是软件接口设计，<br>根据MCU片上功能单元的存储器映射机制，可以想象这些软件的工作就是访问存储器单元配置I2C接口(包括时钟速度、引脚、数据发送和接收中断等)、<br>使能和禁止I2C接口，以及中断服务程序等底层操作。凡涉及存储器访问的操作都是很繁琐的，而且几乎都是没有可移植性代码。幸运的是，<br>我们无须编写这些代码，源文件都由半导体厂商提供。</p>
<p>I2C接口的硬件抽象层具有承上启下的作用，封装合理的I2C接口硬件抽象层是系统内所有I2C功能组件的共享代码。向下访问MCU硬件层接口(那些具体的MCU的存储器资源访问)实现I2C接口的基本协议，<br>包括启动时序“beginTransmission”、停止时序“endTransmission”、字节帧批量输出“write()”、输入“requestFrom()”和“read()”等，以及数据接收中断“onReceive()”(仅从机模式)、<br>主机请求中断“onRequest()”(仅从机模式)等中断服务程序。向上提供I2C通讯协议的实现接口。</p>
<p>对于任意的I2C组件的操作，我们只需要访问其寄存器即可实现目标功能，譬如读数字湿度传感器的湿度寄存器到变量(根据湿度的分辨率或许需要连续地读多个寄存器)。<br>一个系统内使用的每一种I2C组件的从地址、寄存器列表等都是固定的(常量)，调用硬件抽象层的接口访问寄存器实现I2C组件的功能封装，这部分工作属于BSP的一部分。<br>我们已经在前一章中多次实施BSP代码，本章后续内容将会实施I2C组件的BSP。I2C接口软件的BSP部分的基本实施规则就是，隐藏寄存器及其访问操作，<br>按照I2C组件的功能封装参数配置和功能操作接口，譬如设置温湿度传感器分辨率、获取当前的环境湿度或当前温度、配置加速度传感器的量程、读取当加速度的3分量等。</p>
<p>用户层调用特定开源板的BSP接口实现传感器应用，如环境温度或湿度测量及处理(滤波、显示、存储到本地或云端)、根据加速度和陀螺仪的分量值估算姿态、<br>根据当前姿态角调整飞控系统驱动马达转速等。</p>
<p>以BlueFi开源板和兼容Arduino的nrf52开源软件包为例，硬件层源码位于“../Hardware/nrf52/版本号/cores/nordic/hal/”文件夹，<br>硬件抽象层源码位于“../Hardware/nrf52/版本号/libraries/Wire/”，I2C通讯接口的BSP与其他接口的BSP都在一个文件夹中，<br>下一节开始实施I2C接口部分的BSP编码。</p>
<hr>
<p>I2C接口协议的规范和实现方法 [3]_ 并不复杂，接口硬件方面仅仅是数字电路领域的基础知识(线与、同步时钟和锁存、移位寄存器等)，<br>接口协议方面只涉及通讯领域的字节同步基本概念，接口软件方面我们仍采用分层抽象的思想来封装。</p>
<p>下一节将以主机的角色深入了解MCU片上的I2C功能单元的结构和数据传输操作流程，硬件层和硬件抽象层的接口，以及BSP层软件封装。<br>如何使用I2C通讯接口连接两个MCU实现双向通讯，这是再下一节的核心内容。</p>
<hr>
<p>参考文献：<br>::</p>
<p>  [1] <a target="_blank" rel="noopener" href="https://learn.adafruit.com/i2c-addresses/the-list">https://learn.adafruit.com/i2c-addresses/the-list</a><br>  [2] <a target="_blank" rel="noopener" href="https://www.nxp.com/docs/en/application-note/AN10441.pdf">https://www.nxp.com/docs/en/application-note/AN10441.pdf</a><br>  [3] <a target="_blank" rel="noopener" href="http://www.i2c-bus.org/">http://www.i2c-bus.org/</a></p>
<h2 id="5-2-I2C主机模式"><a href="#5-2-I2C主机模式" class="headerlink" title="5.2 I2C主机模式"></a>5.2 I2C主机模式</h2><p>主机(Master)模式是MCU片上I2C功能单元的缺省工作模式，MCU仅使用2个I/O引脚就可以通过从机（Slave)寻址方式与上百个I2C从机通讯(或称作会话)。<br>按照I2C协议规范，SCL信号由主机驱动(主机输出的同步时钟信号)，SDA信号是双向驱动的。主机与任一从机之间的通讯都必须以“Start时序”作为开始，<br>然后主机发送的第一帧数据必须是由“(7位从地址&lt;&lt;1) | R/W位”组成的寻址帧，被寻址的从机被选中并给向主机发送“ACK时序”确认，<br>后续两者之间的通讯始终以主机发出的同步时钟信号为节拍，并以8位数据和1位接收者“ACK时序”为一个数据帧，当主机发出“Stop时序”后结束本次通讯，<br>主机和从机双方都暂时释放I2C总线。很显然，I2C总线的主从机之间的每次会话都以“Start时序”和“Stop时序”为界定，即使与同一个从机之间的多次会话也都遵循这一原则。</p>
<p>当MCU片上I2C功能单元工作在主机模式时，I2C接口的存储器(譬如小容量EEPROM非易失性数据存储器)、传感器、执行器和显示器等功能组件为从机，<br>我们编程控制MCU片上I2C功能单元访问这些片外I2C组件上的寄存器以实现他们的功能，前一节我们已经给出分层的I2C通讯接口软件的框架，参见图5.6。<br>绝大多数嵌入式系统软件开发平台都包含有硬件层和硬件抽象层的接口库，硬件层是通过访问I2C功能单元映射的存储器实现I2C通讯接口的硬件控制，<br>硬件抽象层是I2C协议的实现。在Arduino开源平台上，这两个层次的接口库都是以源码形式提供给系统开发者，其中硬件层由半导体厂商提供，<br>软件抽象层则是由开源社区的贡献者按照Arduino开源平台的“Wire”库的接口规范所编写的特定系列MCU的I2C接口的兼容库，Arduino标准的“Wire”库共有10种接口(包含主机模式的和从机模式的接口)，<br>详见页面 [1]_ ，对应的源代码见“../Hardware/nrf52/版本号/libraries/Wire/Wire.h”文件，使用该I2C通讯接口前必须用“#include &lt;Wire.h&gt;”语句来引用这些接口。</p>
<p>值得注意的是，Arduino的I2C通讯接口的硬件抽象层不仅支持主机模式，同时还支持从机模式。关于MCU片上I2C工作在从机模式的情形，将在下一节探讨。</p>
<p>.. Note::  I2C硬件抽象层接口(仅主机模式的接口)</p>
<ol>
<li>**begin()**，将I2C通讯接口配置为主机模式，并配置SCL和SDA的I/O引脚、SCL时钟速度(使用默认的设置)、中断等。注意，只能在初始化时调用一次</li>
<li>**setClock(clockFrequency)**，重置I2C通讯接口的SCL时钟速度，参数clockFrequency以Hz为单位，譬如400,000</li>
<li>**beginTransmission(slave_addr)**，产生“Start时序”，并将后续会话的从地址参数配置为slave_addr(7位地址!!)，直到“endTransmission()”执行后</li>
<li>**endTransmission(stop)**，(如果发送缓冲区不为空)将发送缓冲区中的数据传送给指定的从机；参数“stop”的有效值是“true”或“false”，该参数指定本次传输结束时是否产生“Stop时序”释放I2C总线</li>
<li>**write(val)/**，向从机写数据，必须在“beginTransmission(slave_addr)”和“endTransmission()”之间调用该接口。这个接口还有另外两种形式：write(val[], len)和write(string)</li>
<li>**requestFrom(slave_addr, quantity, stop)**，向指定地址(slave_addr)的从机请求(读取)指定个数(quantity)的数据，然后使用“available()”和“read()”检查并读取数据；”stop”参数的有效值是”true”或”false”，用于指定本次请求操作结束时是否发送STOP时序</li>
<li>**available()**，返回接收缓冲区中有效的/可读取的字节数据个数，在调用“requestFrom(slave_addr, quantity)”后使用该接口检查请求回来的有效数据</li>
<li>**read()**，从接收缓冲区读取请求到的有效数据</li>
</ol>
<p>基于这些I2C通讯协议的实现(即I2C硬件抽象层)接口，对于给定的嵌入式系统的I2C硬件层，我们可以就可以定义系统内I2C接口的功能组件的BSP接口。<br>按照图5.6所示的软件架构，每一个I2C功能组件的BSP层有4个基本接口：begin(i2cBus)、readRegister(regAddr)、readRegisters(regAddr, rBuf[], num)、<br>writeRegisters(regAddr, wBuf[], num)。其中“begin(i2cBus)”是IC通讯接口初始化，另外3个接口的功能与名称一致。<br>使用这些基本接口，我们就可以直接访问I2C功能组件上的寄存器实现其特设的功能，譬如获取温湿度或加速度值、配置采样率等。</p>
<p>此外，每一个I2C功能组件的BSP层接口最好的封装形式是类(class)的形式，这样就可以把该组件的从地址、寄存器列表及其4个基本接口等定义为私有的变量和(内部)接口以避免与其他I2C功能组件的接口混淆。</p>
<hr>
<p>现在我们以BlueFi开源板上的6DoF惯性测量单元(IMU)——LSM6DS33为例，使用Arduino开源平台的(nRF52)I2C硬件层和硬件抽象层接口实现加速度传感器的用户接口，<br>即BlueFi开源板的BSP层的加速度传感器的代码实现。具体的实现代码由以下两个文件组成：</p>
<p>(BlueFi_LSM6DS3.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BLUEFI_LSM6DS3_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BLUEFI_LSM6DS3_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DefaultSlaveAddress_LSM6DS3 0x6A</span></span><br><span class="line"><span class="comment">//#define DefaultSlaveAddress_LSM6DS3 0x6B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_WHO_AM_I_REG       0X0F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_CTRL1_XL           0X10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_CTRL2_G            0X11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_CTRL6_C            0X15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_CTRL7_G            0X16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_CTRL8_XL           0X17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_STATUS_REG         0X1E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTX_L_G           0X22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTX_H_G           0X23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTY_L_G           0X24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTY_H_G           0X25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTZ_L_G           0X26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTZ_H_G           0X27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTX_L_XL          0X28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTX_H_XL          0X29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTY_L_XL          0X2A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTY_H_XL          0X2B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTZ_L_XL          0X2C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSM6DS3_OUTZ_H_XL          0X2D</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSM6DS3</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LSM6DS3(TwoWire&amp; wire, <span class="keyword">uint8_t</span> slaveAddress=DefaultSlaveAddress_LSM6DS3);</span><br><span class="line">    <span class="keyword">virtual</span> ~LSM6DS3()&#123; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">begin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Accelerometer</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">readAcceleration</span><span class="params">(<span class="keyword">float</span>&amp; x, <span class="keyword">float</span>&amp; y, <span class="keyword">float</span>&amp; z)</span></span>; <span class="comment">// Results are in G (earth gravity).</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">accelerationSampleRate</span><span class="params">()</span></span>; <span class="comment">// Sampling rate of the sensor.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">accelerationAvailable</span><span class="params">()</span></span>; <span class="comment">// Check for available data from accerometer</span></span><br><span class="line">    <span class="comment">// Gyroscope</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">readGyroscope</span><span class="params">(<span class="keyword">float</span>&amp; x, <span class="keyword">float</span>&amp; y, <span class="keyword">float</span>&amp; z)</span></span>; <span class="comment">// Results are in degrees/second.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">gyroscopeSampleRate</span><span class="params">()</span></span>; <span class="comment">// Sampling rate of the sensor.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">gyroscopeAvailable</span><span class="params">()</span></span>; <span class="comment">// Check for available data from gyroscopeAvailable</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readRegister</span><span class="params">(<span class="keyword">uint8_t</span> address)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readRegisters</span><span class="params">(<span class="keyword">uint8_t</span> address, <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeRegister</span><span class="params">(<span class="keyword">uint8_t</span> address, <span class="keyword">uint8_t</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeRegisters</span><span class="params">(<span class="keyword">uint8_t</span> regAddr, <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">    TwoWire* __wire;</span><br><span class="line">    <span class="keyword">uint8_t</span> __Address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __BLUEFI_LSM6DS3_H_</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这个版本仅是I2C通讯接口的示例目的，并不是完整的IMU功能接口。所有外部接口都在LSM6DS3类的“public”域，私有的/内部的接口在“private”域。<br>读单个/多个寄存器、写单个/多个寄存器等操作是每一种I2C功能组件的最基本的4种内部接口实现。此外，连接该组件所用的硬件抽象层的I2C类接口，<br>使用指针型的内部私有变量“__wire”来保存。</p>
<p>(BlueFi_LSM6DS3.cpp)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BlueFi_LSM6DS3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LSM6DS3::LSM6DS3(TwoWire&amp; wire, <span class="keyword">uint8_t</span> slaveAddress) :</span><br><span class="line">  __wire(&amp;wire),</span><br><span class="line">  __Address(slaveAddress) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LSM6DS3::begin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    __wire-&gt;begin();</span><br><span class="line">  <span class="keyword">if</span> (readRegister(LSM6DS3_WHO_AM_I_REG) != <span class="number">0x69</span>) &#123;</span><br><span class="line">    end();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//set the gyroscope control register to work at 104 Hz, 2000 dps and in bypass mode</span></span><br><span class="line">  writeRegister(LSM6DS3_CTRL2_G, <span class="number">0x4C</span>);</span><br><span class="line">  <span class="comment">// Set the Accelerometer control register to work at 104 Hz, 4G,and in bypass mode and enable ODR/4</span></span><br><span class="line">  <span class="comment">// low pass filter(check figure9 of LSM6DS3&#x27;s datasheet)</span></span><br><span class="line">  writeRegister(LSM6DS3_CTRL1_XL, <span class="number">0x4A</span>);</span><br><span class="line">  <span class="comment">// set gyroscope power mode to high performance and bandwidth to 16 MHz</span></span><br><span class="line">  writeRegister(LSM6DS3_CTRL7_G, <span class="number">0x00</span>);</span><br><span class="line">  <span class="comment">// Set the ODR config register to ODR/4</span></span><br><span class="line">  writeRegister(LSM6DS3_CTRL8_XL, <span class="number">0x09</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LSM6DS3::end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    writeRegister(LSM6DS3_CTRL2_G, <span class="number">0x00</span>);</span><br><span class="line">    writeRegister(LSM6DS3_CTRL1_XL, <span class="number">0x00</span>);</span><br><span class="line">    __wire-&gt;end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LSM6DS3::readAcceleration</span><span class="params">(<span class="keyword">float</span>&amp; x, <span class="keyword">float</span>&amp; y, <span class="keyword">float</span>&amp; z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int16_t</span> data[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">if</span> (!readRegisters(LSM6DS3_OUTX_L_XL, (<span class="keyword">uint8_t</span>*)data, <span class="keyword">sizeof</span>(data))) &#123;</span><br><span class="line">    x = NAN, y = NAN, z = NAN;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x = data[<span class="number">0</span>] * <span class="number">4.0</span> / <span class="number">32768.0</span>;</span><br><span class="line">  y = data[<span class="number">1</span>] * <span class="number">4.0</span> / <span class="number">32768.0</span>;</span><br><span class="line">  z = data[<span class="number">2</span>] * <span class="number">4.0</span> / <span class="number">32768.0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LSM6DS3::accelerationAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (readRegister(LSM6DS3_STATUS_REG) &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">LSM6DS3::accelerationSampleRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">104.0F</span>; <span class="comment">// 104Hz</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LSM6DS3::readGyroscope</span><span class="params">(<span class="keyword">float</span>&amp; x, <span class="keyword">float</span>&amp; y, <span class="keyword">float</span>&amp; z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int16_t</span> data[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">if</span> (!readRegisters(LSM6DS3_OUTX_L_G, (<span class="keyword">uint8_t</span>*)data, <span class="keyword">sizeof</span>(data))) &#123;</span><br><span class="line">    x = NAN, y = NAN, z = NAN;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x = data[<span class="number">0</span>] * <span class="number">2000.0</span> / <span class="number">32768.0</span>;</span><br><span class="line">  y = data[<span class="number">1</span>] * <span class="number">2000.0</span> / <span class="number">32768.0</span>;</span><br><span class="line">  z = data[<span class="number">2</span>] * <span class="number">2000.0</span> / <span class="number">32768.0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LSM6DS3::gyroscopeAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (readRegister(LSM6DS3_STATUS_REG) &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">LSM6DS3::gyroscopeSampleRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">104.0F</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSM6DS3::readRegister</span><span class="params">(<span class="keyword">uint8_t</span> regAddr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> value;</span><br><span class="line">  <span class="keyword">if</span> (readRegisters(regAddr, &amp;value, <span class="keyword">sizeof</span>(value)) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSM6DS3::readRegisters</span><span class="params">(<span class="keyword">uint8_t</span> regAddr, <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __wire-&gt;beginTransmission(__Address);</span><br><span class="line">  __wire-&gt;write(regAddr);</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;endTransmission(<span class="literal">false</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;requestFrom(__Address, length) != length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">    *data++ = __wire-&gt;read();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSM6DS3::writeRegister</span><span class="params">(<span class="keyword">uint8_t</span> regAddr, <span class="keyword">uint8_t</span> value)</span> </span>&#123;</span><br><span class="line">  __wire-&gt;beginTransmission(__Address);</span><br><span class="line">  __wire-&gt;write(regAddr);</span><br><span class="line">  __wire-&gt;write(value);</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;endTransmission() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSM6DS3::writeRegisters</span><span class="params">(<span class="keyword">uint8_t</span> regAddr, <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  __wire-&gt;beginTransmission(__Address);</span><br><span class="line">  __wire-&gt;write(regAddr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">    __wire-&gt;write(*data++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;endTransmission() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的LSM6DS3类接口主要包括，初始化(begin)、读取3-DoF加速度(/陀螺仪)的三坐标分量值、检查LSM6DS3内部状态寄存器(LSM6DS3_STATUS_REG)确定是否有数据可读等。<br>完成这个LSM6DS3类接口的代码编写后，将两个源文件(BlueFi_LSM6DS3.h和BlueFi_LSM6DS3.cpp)保存到“../Documents/Arduino/libraries/BlueFi/src/utility/”文件夹，<br>然后打开“../Documents/Arduino/libraries/BlueFi/src/”文件夹中的BlueFi.h文件，并在BlueFi类的“public”域增加“LSM6DS3 imu = LSM6DS3(Wire1, 0x6A);”语句，<br>定义一个名叫“imu”的LSM6DS3类接口；打开该文件夹中的“BlueFi.cpp”文件，为begin()接口函数增加“imu.begin();”语句，当BlueFi开源板初始化时调用LSM6DS3类接口——begin()对“imu”对象初始化。<br>现在，我们的BlueFi开源板的BSP已具有读取加速度/陀螺仪原始数据的接口。注意，初始化LSM6DS3类对象“imu”时，将加速度/陀螺仪的采样率设置为104Hz。</p>
<p>为了更好地了解LSM6DS3的用法，详见 [2]_ 。</p>
<p>下面的简单示例代码可能演示LSM6DS3类接口的用法：</p>
<p>(LSM6DS3_accelerometer_simplest.ino)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// show float data on the console, or draw ployline on the plotter (baudrate=115200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BlueFi.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bluefi.begin(); <span class="comment">// 初始化BlueFi开源板(含imu初始化)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> x=<span class="number">0.0F</span>, y=<span class="number">0.0F</span>, z=<span class="number">0.0F</span>; </span><br><span class="line">  <span class="keyword">if</span> (bluefi.imu.accelerationAvailable()) &#123; <span class="comment">// 检查加速度原始数据的可读性</span></span><br><span class="line">    bluefi.imu.readAcceleration(x, y, z); <span class="comment">// 读取加速度传感器的三分量</span></span><br><span class="line">    Serial.print(x); Serial.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Serial.print(y); Serial.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Serial.println(z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以使用Arduino IDE编译并下载上面这个简单示例，当程序下载到BlueFi开源板上之后，打开串口监视器(或串口绘图器)就可以看到加速度传感器三分量的原始数据(或三色折线图)，<br>保持USB数据线完好连接到电脑，再通过摇晃、移动、旋转BlueFi开源板，观察加速度三分量的值与你的操作之间存在什么样的关联关系。在这个示例代码运行期间，<br>我们使用Arduino IDE的串口绘图器绘制的加速度三分量的折线图，参考图5.7所示。</p>
<p><img src="https://image.wxydejoy.top/img/202108/04/200536%20i2c_lsm6ds3_plotter.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/202108/04/200536%20i2c_lsm6ds3_plotter.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="i2c_lsm6ds3_plotter"></p>
<p>图5.7  使用加速度传感器原始数据绘制的图形</p>
<p>将上面示例代码稍作修改就可以使用LSM6DS3类接口读取3DoF陀螺仪三分量的原始数据，示例代码如下：</p>
<p>(LSM6DS3_gyroscope_simplest.ino)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// show float data on the console, or draw ployline on the plotter (baudrate=115200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BlueFi.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bluefi.begin();  <span class="comment">// 初始化BlueFi开源板(含imu初始化)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> x=<span class="number">0.0F</span>, y=<span class="number">0.0F</span>, z=<span class="number">0.0F</span>; </span><br><span class="line">  <span class="keyword">if</span> (bluefi.imu.gyroscopeAvailable()) &#123; <span class="comment">// 检查陀螺仪原始数据的可读性</span></span><br><span class="line">    bluefi.imu.readGyroscope(x, y, z); <span class="comment">// 读取陀螺仪的三分量</span></span><br><span class="line">    Serial.print(x); Serial.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Serial.print(y); Serial.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Serial.println(z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>IMU用于运动物体的姿态和位置估算，譬如飞行器和汽车等姿态稳定和导航定位(无GPS信号期间的短距离定位)。加速度、陀螺仪和地磁传感器(电子罗盘)是IMU的基本测量传感器，<br>基于这些传感器的原始数据(9个分量)并使用姿态和位置估算算法即可确定飞行器和汽车等运动物体的当前姿态和位置。我们将在后续的内容中给出完整的IMU接口及其算法，<br>本节仅仅是作为I2C通讯接口的示例使用。</p>
<hr>
<p>接着，我们以BlueFi开源板上的数字环境温湿度传感器——SHT30-DIS为例，使用Arduino开源平台的(nRF52)I2C硬件层和硬件抽象层接口实现温湿度传感器的用户接口，<br>即BlueFi开源板的BSP层的温湿度传感器的代码实现。具体的实现代码由以下两个文件组成：</p>
<p>(BlueFi_SHT30.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BLUEFI_SHT30_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BLUEFI_SHT30_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DefaultSlaveAddress_SHT30 0x44</span></span><br><span class="line"><span class="comment">//#define DefaultSlaveAddress_SHT30 0x45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_MEAS_HIGHREP_STRETCH  0x2C06 <span class="comment">/**&lt; Measurement High Repeatability with Clock Stretch Enabled */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_MEAS_MEDREP_STRETCH   0x2C0D <span class="comment">/**&lt; Measurement Medium Repeatability with Clock Stretch Enabled */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_MEAS_LOWREP_STRETCH   0x2C10 <span class="comment">/**&lt; Measurement Low Repeatability with Clock Stretch Enabled*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_MEAS_HIGHREP    0x2400 <span class="comment">/**&lt; Measurement High Repeatability with Clock Stretch Disabled */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_MEAS_MEDREP     0x240B <span class="comment">/**&lt; Measurement Medium Repeatability with Clock Stretch Disabled */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_MEAS_LOWREP     0x2416 <span class="comment">/**&lt; Measurement Low Repeatability with Clock Stretch Disabled */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_READSTATUS      0xF32D   <span class="comment">/**&lt; Read Out of Status Register */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_CLEARSTATUS     0x3041  <span class="comment">/**&lt; Clear Status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_SOFTRESET       0x30A2    <span class="comment">/**&lt; Soft Reset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_HEATEREN        0x306D     <span class="comment">/**&lt; Heater Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_HEATERDIS       0x3066    <span class="comment">/**&lt; Heater Disable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT31_REG_HEATER_BIT  0x0d <span class="comment">/**&lt; Status Register Heater Bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> msONGOING  50  <span class="comment">/* &gt;=20ms */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SHT30</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SHT30(TwoWire&amp; wire, <span class="keyword">uint8_t</span> slaveAddress=DefaultSlaveAddress_SHT30);</span><br><span class="line">    <span class="keyword">virtual</span> ~SHT30()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">begin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">uint16_t</span> <span class="title">readStatus</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heater</span><span class="params">(<span class="keyword">bool</span> on)</span></span>; <span class="comment">// true: on, false: off</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHeaterEnabled</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RHT_FSM</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> isReady;</span><br><span class="line">    <span class="keyword">float</span> temperature, humidity;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">writeCommand</span><span class="params">(<span class="keyword">uint16_t</span> command)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">readRegisters</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">writeRegisters</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">  </span><br><span class="line">    TwoWire* __wire;</span><br><span class="line">    <span class="keyword">uint8_t</span> __Address;</span><br><span class="line">    <span class="keyword">uint32_t</span> __startMillis;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">rht_FSM</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      IDLE = <span class="number">0</span>,</span><br><span class="line">      ONGOING,</span><br><span class="line">      READY</span><br><span class="line">    &#125; __rht_FSM;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __BLUEFI_SHT30_H_</span></span></span><br></pre></td></tr></table></figure>
<p>这个SHT30类温湿度传感器接口主要包括，初始化(begin)和温湿度测量和数据处理的状态机(RHT_FSM)，以及3个成员变量：状态机的温湿度结果是否可用(isReady)、<br>当前温度(temperature，摄氏度为单位)、当前相对湿度(humidity)。此外，SHT30类还有一些辅助功能接口，包括传感器状态读回(readStatus)、<br>传感器复位(reset)、传感器内部加热器的控制(heater)和状态查询(isHeaterEnabled)。SHT30类的内部/私有接口包括写命令字(writeCommand)、<br>读多个寄存器(readRegisters)和写多个寄存器(writeRegisters)，私有成员变量包括硬件抽象层的I2C类接口指针、从机地址等。</p>
<p>(BlueFi_SHT30.cpp)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BlueFi_SHT30.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SHT30::SHT30(TwoWire&amp; wire, <span class="keyword">uint8_t</span> slaveAddress):</span><br><span class="line">  __wire(&amp;wire),</span><br><span class="line">  __Address(slaveAddress) &#123;</span><br><span class="line">  humidity = NAN;</span><br><span class="line">  temperature = NAN;</span><br><span class="line">  isReady = <span class="literal">false</span>;</span><br><span class="line">  __rht_FSM = IDLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SHT30::begin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  __wire-&gt;begin();</span><br><span class="line">  reset();</span><br><span class="line">  <span class="keyword">return</span> readStatus() != <span class="number">0xFFFF</span>; <span class="comment">// check read-back operation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">crc8</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * CRC-8 formula from page 14 of SHT3x spec pdf</span></span><br><span class="line"><span class="comment">  * Test data 0xBE, 0xEF should yield 0x92</span></span><br><span class="line"><span class="comment">  * Initialization data 0xFF</span></span><br><span class="line"><span class="comment">  * Polynomial 0x31 (x8 + x5 +x4 +1)</span></span><br><span class="line"><span class="comment">  * Final XOR 0x00</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span>  <span class="title">POLYNOMIAL</span><span class="params">(<span class="number">0x31</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">uint8_t</span> <span class="title">crc</span><span class="params">(<span class="number">0xFF</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=len; j; --j) &#123;</span><br><span class="line">    crc ^= *data++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>; i; --i)</span><br><span class="line">      crc = (crc&amp;<span class="number">0x80</span>) ? (crc&lt;&lt;<span class="number">1</span>)^POLYNOMIAL : (crc&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">SHT30::readStatus</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> data[<span class="number">3</span>];</span><br><span class="line">  writeCommand(SHT31_READSTATUS);</span><br><span class="line">  readRegisters(data, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">uint16_t</span> stat = data[<span class="number">0</span>];</span><br><span class="line">  stat &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">  stat |= data[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> stat; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SHT30::reset</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  writeCommand(SHT31_SOFTRESET);</span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SHT30::heater</span><span class="params">(<span class="keyword">bool</span> on)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (on)</span><br><span class="line">    writeCommand(SHT31_HEATEREN);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    writeCommand(SHT31_HEATERDIS);</span><br><span class="line">  delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SHT30::isHeaterEnabled</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> regValue = readStatus();</span><br><span class="line">  <span class="keyword">return</span> (regValue&amp;SHT31_REG_HEATER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  the Finite State Machine for starting measure and readout data</span></span><br><span class="line"><span class="comment">*                    |---------------------------------|</span></span><br><span class="line"><span class="comment">*  initialize  --&gt;  IDLE  --&gt;  ONGOING  --&gt;  READY  ---&gt;</span></span><br><span class="line"><span class="comment">*                    --&gt;  start   --&gt;   delay  --&gt;  readout -&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SHT30::RHT_FSM</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> _readbuffer[<span class="number">6</span>]; <span class="comment">// TTCHHC</span></span><br><span class="line">  <span class="keyword">int32_t</span> _stemp;</span><br><span class="line">  <span class="keyword">uint32_t</span> _shum;</span><br><span class="line">  <span class="keyword">switch</span> (__rht_FSM) &#123;</span><br><span class="line">    <span class="keyword">case</span> IDLE:</span><br><span class="line">      writeCommand(SHT31_MEAS_HIGHREP); <span class="comment">// start</span></span><br><span class="line">      __startMillis = millis();</span><br><span class="line">      __rht_FSM = ONGOING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ONGOING:</span><br><span class="line">      <span class="keyword">if</span> ( (millis()-__startMillis) &gt;= msONGOING )&#123;  <span class="comment">// check delay</span></span><br><span class="line">        __rht_FSM = READY;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READY:</span><br><span class="line">      readRegisters(_readbuffer, <span class="keyword">sizeof</span>(_readbuffer));</span><br><span class="line">      <span class="keyword">if</span> ( (_readbuffer[<span class="number">2</span>]==crc8(_readbuffer, <span class="number">2</span>)) &amp;&amp; (_readbuffer[<span class="number">5</span>] == crc8(_readbuffer + <span class="number">3</span>, <span class="number">2</span>)) ) &#123;</span><br><span class="line">        _stemp = (<span class="keyword">int32_t</span>)(((<span class="keyword">uint32_t</span>)_readbuffer[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | _readbuffer[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// simplified (65536 instead of 65535) integer version of:</span></span><br><span class="line">        <span class="comment">// temperature = (_stemp * 175.0f) / 65535.0f - 45.0f;</span></span><br><span class="line">        _stemp = ((<span class="number">4375</span> * _stemp) &gt;&gt; <span class="number">14</span>) - <span class="number">4500</span>;</span><br><span class="line">        temperature = (<span class="keyword">float</span>)_stemp / <span class="number">100.0f</span>;</span><br><span class="line">        _shum = ((<span class="keyword">uint32_t</span>)_readbuffer[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | _readbuffer[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// simplified (65536 instead of 65535) integer version of:</span></span><br><span class="line">        <span class="comment">// humidity = (_shum * 100.0f) / 65535.0f;</span></span><br><span class="line">        _shum = (<span class="number">625</span> * _shum) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">        humidity = (<span class="keyword">float</span>)_shum / <span class="number">100.0f</span>;        </span><br><span class="line">      &#125;</span><br><span class="line">      isReady = <span class="literal">true</span>;</span><br><span class="line">      __rht_FSM = IDLE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __rht_FSM = IDLE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SHT30::writeCommand</span><span class="params">(<span class="keyword">uint16_t</span> command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> cmd[<span class="number">2</span>];</span><br><span class="line">  cmd[<span class="number">0</span>] = command &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  cmd[<span class="number">1</span>] = command &amp; <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> writeRegisters(cmd, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SHT30::readRegisters</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;requestFrom(__Address, len) != len)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    buf[i] = __wire-&gt;read();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SHT30::writeRegisters</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  __wire-&gt;beginTransmission(__Address);</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;write(buf, len) != len) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__wire-&gt;endTransmission() != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以从以下几个方面对比LSM6DS3和SHT30-DIS两种I2C传感器的接口：</p>
<ul>
<li>接口封装的结构</li>
<li>寄存器的读写</li>
</ul>
<p>两种传感器接口的封装都是采用C/C++的类结构。“public”域是外部接口，“private”域是内部接口。接口类型不仅有类成员函数，也有成员变量。<br>因此，C/C++的类相关的概念和用法在这里完全通用。</p>
<p>两种传感器的寄存器读写接口虽然都是私有的，但区别较大。这是因为，LSM6DS3内部功能单元采用RAM型存储器映射的模式，但SHT30-DIS采用写入不同命令字来控制内部功能单元。<br>SHT30-DIS没有存储器映射机制，对传感器内部功能单元的每一次操作都必须先写入命令字(16位无符号型)，譬如启动温湿度测量、启动/停止内部加热器等，<br>然后再执行多字节读操作获取传感器的测量结果、查询内部状态等。此外，从SHT30-DIS读回的数据(温湿度和状态)也都是固定3字节格式：2字节数据和1字节CRC(循环冗余校验)。<br>SHT30-DIS使用8位CRC算法，算法所使用的多项式、初始值都在其数据页 [3]_ 第14页给出描述。</p>
<p>我们用一个示例来演示如何使用SHT30类温湿度传感器接口。本示例首先初始化BlueFi开源板上所以资源(含温湿度传感器及其接口)，在主循环中调用bluefi.rht.RHT_FSM()<br>执行温湿度测量的状态机更新温湿度数据到变量bluefi.rht.temperature和bluefi.rht.humidity，当状态机完成一次温湿度数据更新时bluefi.rht.isReady被置位为true，<br>主循环测试该状态并将当前温湿度结果打印到串口控制台。示例代码如下：</p>
<p>(SHT30_simplest.ino)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The simplest operation using SHT3x sensor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BlueFi.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  bluefi.begin(); <span class="comment">// initialize all resource on the BlueFi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bluefi.rht.RHT_FSM(); <span class="comment">// run the Finite State Machine to update RHT</span></span><br><span class="line">  <span class="keyword">if</span> (bluefi.rht.isReady) &#123;</span><br><span class="line">    bluefi.rht.isReady = <span class="literal">false</span>;</span><br><span class="line">    Serial.print(<span class="string">&quot;Temperature: &quot;</span>);</span><br><span class="line">    Serial.print(bluefi.rht.temperature); </span><br><span class="line">    Serial.write(<span class="string">&quot;\xC2\xB0&quot;</span>); <span class="comment">//The Degree symbol</span></span><br><span class="line">    Serial.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;Humidity: &quot;</span>);</span><br><span class="line">    Serial.print(bluefi.rht.humidity);</span><br><span class="line">    Serial.println(<span class="string">&quot;%&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">249</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面示例代码复制-粘贴到Arduino IDE并编译-下载到BlueFi开源板上，当BlueFi执行示例程序期间，打开Arduin IDE的串口监视器，<br>我们将会看到主循环程序输出到串口控制台(print)的文本格式的当前温湿度信息，参考图5.8所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-09-21.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-09-21.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-09-21"></p>
<p>图5.8  使用SHT30类接口读取当前温湿度并输出到字符控制台的效果</p>
<p>现在你可以使用SHT30类接口来监测本地的环境温湿度，确定本地区最舒适的温湿度是什么季节？对应的具体环境温湿度是多少呢？<br>标定是正确使用传感器的基本要求。如何标定温湿度传感器呢？</p>
<hr>
<p>在Python解释器环境如何使用I2C通讯接口的主机模式进行编程呢？请参考第4.1节末尾的步骤，下载BlueFi的Python解释器固件，并双击BlueFi的复位按钮，<br>并将固件拖放到BLUEFIBOOT磁盘，将BlueFi恢复到执行Python解释器模式，我们的电脑资源管理器中将会出现名为“CIRCUITPY”磁盘。</p>
<p>.. Note:: Python解释器的安全模式</p>
<ul>
<li>单击BlueFi的复位按钮，当第1颗彩灯(靠近复位按钮)显示黄色状态时，再次按下复位按钮，迫使BlueFi终止执行用户脚本程序，并进入安全模式，此时第一颗彩灯呈黄色呼吸灯效果</li>
<li>当Python解释器在执行某些脚本程序时，可能会导致不出现“CIRCUITPY”磁盘，可以通过强制进入Python解释器的安全模式来终止脚本执行</li>
<li>在Python解释器的安全模式，仍可以修改“CIRCUITPY”磁盘上任一文件，但Python解释器不会立即执行更新后的code.py程序</li>
<li>只能通过按复位按钮才能退出Python解释器的安全模式</li>
</ul>
<p>“CIRCUITPY/hiibot_bluefi/sensors.py”是BlueFi板上所有传感器的Python接口库模块，在我们的Python脚本程序中直接导入(import)这个模块就可以访问BlueFi的传感器。<br>将下面的示例代码保存到“/CIRCUITPY/code.py”文件，在BlueFi执行程序期间，我们可以使用任意串口字符控制台(MU编辑器的串口、Arduino IDE的串口监视器等)查看输出，<br>Python解释器的所有字符输出也都会同步地显示在BlueFi的LCD显示屏上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> hiibot_bluefi.sensors <span class="keyword">import</span> Sensors</span><br><span class="line">sensor = Sensors()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;T: &#123;&#125;°C, RH: &#123;&#125;%&quot;</span>.<span class="built_in">format</span>(sensor.temperature, sensor.humidity))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这个示例输出的文本字符的参考效果，如“T: 30.9388Â°C, RH: 52.6817%”，这显然由第5行“print()”函数中的“format”的作用。<br>示例程序的第2行脚本语句的执行效果是，从“CIRCUITPY/hiibot_bluefi/sensors.py”文件中导入“Sensors类”模块。第3行将“Sensors类”实例化一个名叫“sensor”的对象，<br>并在第5行将该对象的temperature和humidity属性值按指定的字符格式输出到字符控制台。</p>
<p>加速度和陀螺仪传感器——LSM6DS3也有相似的用法，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> hiibot_bluefi.sensors <span class="keyword">import</span> Sensors</span><br><span class="line">sensor = Sensors()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ax, ay, az = sensor.acceleration</span><br><span class="line">    gx, gy, gz = sensor.gyro</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Acce X:&#123;:.2f&#125;, Y:&#123;:.2f&#125;, Z:&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(ax, ay, az))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Gyro X:&#123;:.2f&#125;, Y:&#123;:.2f&#125;, Z:&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(gx, gy, gz))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p>这个示例代码的初始化部分与前一个示例完全相同。主循环程序中，首先将加速度和陀螺仪的三分量分别赋给6个变量，然后使用“format”转换成指定格式的字符串输出到字符控制台。<br>其中“{:.2f}”.format(var)是将变量var以浮点数输出且只保留小数点后两位。</p>
<p>事实上，BlueFi开源板上共有4种I2C接口的传感器组件，即温湿度传感器(SHT30-DIS)、加速度和陀螺仪(LSM6DS3)、地磁传感器(LIS3MDL)和集成光学传感器(APDS-9960，含颜色感知、接近感知、手势感知和光强度感知等)。<br>其中加速度、陀螺仪和地磁传感器能组合实现9-DoF惯性测量单元的传感器。这些传感器的Python库模块在“CIRCUITPY/hiibot_bluefi/sensors.py”文件中，<br>你可以直接打开这个Python脚本源文件了解具体的Python接口。</p>
<hr>
<p>为了便于测试，请先删除“../Documents/Arduino/libraries/BlueFi”文件夹中的全部文件，然后下载下面的压缩文件包，<br>并解压到“../Documents/Arduino/libraries/BlueFi”文件夹中，</p>
<p>. :download:<code>本节内容所用到的BlueFi的BSP源文件 &lt;../_static/dl_files/bluefi_ch5_2/BlueFi_bsp_ch5_2.zip&gt;</code></p>
<p>本节所增加的加速度和陀螺仪传感器、温湿度传感器的接口代码实现和示例程序都已在这个压缩包中。解压到指定文件夹后，直接用Arduino IDE打开对应示例程序即可编译-下载到BlueFi开源板。</p>
<p>在I2C总线上，每一从机都有惟一的7位地址，主机通过寻址从机实现一对一的半双工通讯，包括读写从机上的寄存器或者控制/查询从机上的功能单元。<br>本节以MCU片上功能单元工作在主机模式时，如何通过编程访问各种从机，譬如加速度和陀螺仪传感器、温湿度传感器等。为了能够掌握I2C主机端软件的设计和实现思路，<br>我们采用分层抽象的思想将I2C功能组件相关的接口分层封装，并以加速度和陀螺仪、温湿度传感器为例分别给出软件的实现，方便我们通过对比和总结。<br>虽然我们仅仅是C/C++类封装为例，Python语言的类封装和接口设计并无本质区别，查看“CIRCUITPY/hiibot_bluefi/sensors.py”文件并与上面的C/C++语言的类封装进行对比，<br>有利于理解I2C主机接口的编程和实现。</p>
<hr>
<p>参考文献：<br>::</p>
<p>  [1] <a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/Wire">https://www.arduino.cc/en/Reference/Wire</a><br>  [2] <a target="_blank" rel="noopener" href="https://www.st.com/resource/en/datasheet/lsm6ds33.pdf">https://www.st.com/resource/en/datasheet/lsm6ds33.pdf</a><br>  [3] <a target="_blank" rel="noopener" href="https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/2_Humidity_Sensors/Datasheets/Sensirion_Humidity_Sensors_SHT3x_Datasheet_digital.pdf">https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/2_Humidity_Sensors/Datasheets/Sensirion_Humidity_Sensors_SHT3x_Datasheet_digital.pdf</a></p>
<p>===========================<br>5.3 I2C从机模式<br>===========================</p>
<p>绝大多数情况，嵌入式系统的MCU都是系统的主控制器，MCU片上I2C功能单元都工作在主机模式与系统内的I2C接口的传感器、执行器或显示器等外设互联。<br>但也有少数情况MCU片上I2C功能单元工作在从机模式，譬如通过I2C接口升级MCU固件，或者通过I2C接口协同工作的两个MCU组成的系统中一个MCU做主机另一个做从机。<br>本节主要了解MCU片上I2C功能单元工作在从机模式下的编程控制。注意，并不是所有MCU片上I2C功能单元都支持主机模式和从机模式，有些MCU仅支持主机模式的I2C接口。</p>
<p>当我们把MCU片上I2C功能单元配置为从机模式时，其内部结构组成如图5.7所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-10-38.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-10-38.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-10-38"><br>图5.7  从机模式的MCU片上I2C功能单元的结构组成</p>
<p>在从机模式下，MCU的I2C接口所使用的I/O引脚中，连接SCL信号的是输入引脚，SDA信号的是双向引脚。根据I2C通讯接口的要求，任一从机都必须有惟一的从机地址，<br>当我们将MCU片上I2C功能单元配置为从机模式时，必须指定本机的7位惟一地址。相对于主机，从机始终是被动的，主机何时寻址本机、读或写操作均有主机发起。<br>因此，从机模式需要配置一定RAM空间用于缓存接收数据，并开启中断，当从模式的I2C接口识别到本机被寻址，并接收到主机的数据时，向CPU发起中断请求并响应主机请求。</p>
<p>Arduino的I2C通讯接口的硬件抽象层不仅支持主机模式，也支持从机模式。从机模式的I2C硬件抽象层接口共有7各，具体接口如下：</p>
<p>.. Note::  I2C硬件抽象层接口(仅从机模式的接口)</p>
<ol>
<li>**begin(slave_addr)**，将I2C通讯接口配置为从机模式，并配置惟一的7位从机地址、SCL和SDA的I/O引脚、SCL时钟速度(使用默认的设置)、中断等。注意，只能在初始化时调用一次</li>
<li>**onReceive(cb_rev)**，注册“onReceive”事件的回调函数，当“onReceive”事件发生后需要执行的代码，譬如调用“available()”检查可读数据个数、调用“read()”读取接收缓冲区的数据并处理</li>
<li>**onRequest(cb_req)**，注册“OnRequest”事件的回调函数，当“OnRequest”事件发生后需要执行的代码，譬如调用“write()”发送数据给主机</li>
<li>**write(val)/**，向主机写/发送数据(当主机请求数据时，即“OnRequest”事件发生后)。这个接口还有另外两种形式：write(val[], len)和write(string)</li>
<li>**available()**，返回接收缓冲区中有效的/可读取的字节数据个数，即“onReceive”事件发生后使用该接口检查接收缓冲区的有效数据字节数</li>
<li>**read()**，从接收缓冲区读取有效数据</li>
</ol>
<p>注意，Arduino平台的I2C硬件抽象层的主机模式和从机模式的接口都被封装在“TwoWire类”中，详见页面 [1]_ ，从机模式的接口仅有这6种(具体种类还与Arduino内核的版本有关)，<br>主机模式共8种接口(见前一节)，其中部分接口是主机模式和从机模式共用的，如“write()”、“read()”、“available()”等，部分接口是各自专用的，<br>譬如注册事件的回调函数是从机模式专用的接口，而“beginTransmission()”、“endTransmission()”和“setClock()”是主机模式专用的接口。</p>
<p>使用I2C硬件抽象层的主机模式接口和从机模式接口，两个MCU之间的通讯流程参见图5.8所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-13-35.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-13-35.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-13-35"></p>
<p>图5.8  两个MCU之间使用I2C通讯的工作流程(使用硬件抽象层接口)</p>
<p>图中的实线框内的操作是软件部分，实线框外的操作由I2C功能单元的硬件自动完成。除了图中的“主机写-从机读”和“主机读(请求)-从机写”的I2C接口数据传输流程外，<br>还有“主机写-从机读-主机请求-从机写”(简单理解为“主机写后读”)的数据传输流程，这个流程要求主机“write(val)”后调用“endTransmission(false)”执行数据发送且发送完毕后不发起“STOP时序”，<br>即不释放I2C总线，继续向从机请求数据，当从机数据发送完毕后，主机才发起“STOP时序”释放I2C总线。请参照图5.8的流程自行设计“主机写后读”的操作流程。</p>
<p>下面我们找来两个BlueFi，并使用一根型号为“SH1.0mm-4P”双头同向的信号线将他们连接起来。BlueFi开源板带有一个专用的4脚I2C扩展插座，在复位按钮旁边，<br>该插座的4各信号分别为3.3V、GND、SDA、SCL，并顺序排列。使用I2C接口连接两个BlueFi的方法如图5.9所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-13-48.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-13-48.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-13-48"></p>
<p>图5.9  使用I2C接口连接两个BlueFi的方法</p>
<p>请注意4芯连接线的型号、脚间距，并确保引脚是同向一一对应的，即两个BlueFi开源板的i2C专用插座的4个脚分别一一对应连接。</p>
<p>现在我们可以参考图5.8所示的流程，分别编写“主机写”和“从机接收”的程序对儿，并分别编译下载到一个BlueFi上执行，使用USB数据线将工作在从机模式的BlueFi连接到电脑，<br>打开Arduino IDE串口监视器可以看到主机写给从机的数据。程序代码如下：</p>
<p>(<strong>master_write.ino文件</strong>，编译并下载到一个BlueFi开源板，他是I2C接口的Master设备)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line">TwoWire* __wire;  <span class="comment">// define a pointer &quot;__wire&quot; to TwoWire type</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  delay(<span class="number">500</span>);</span><br><span class="line">  __wire = &amp;Wire;  <span class="comment">// the pointer __wire point to Wire</span></span><br><span class="line">  __wire-&gt;begin(); <span class="comment">// join i2c bus (address optional for master)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint8_t</span> x=<span class="number">0</span>;</span><br><span class="line">  __wire-&gt;beginTransmission(<span class="number">0x72</span>); <span class="comment">// transmit to device #114</span></span><br><span class="line">  __wire-&gt;write(<span class="string">&quot;x is &quot;</span>);       <span class="comment">// sends five bytes</span></span><br><span class="line">  __wire-&gt;write(x);             <span class="comment">// sends one byte  </span></span><br><span class="line">  __wire-&gt;endTransmission();    <span class="comment">// stop transmitting</span></span><br><span class="line">  x++;</span><br><span class="line">  delay(<span class="number">998</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个“主机写”的程序中，首先声明一个TwoWire型指针“__wire”，并在初始化时将这个指针指向BlueFi的I2C接口0，即“Wire”，并使用指针访问这个I2C接口，<br>在初始化阶段将这个I2C接口初始化为主机模式(使用无参数的“begin()”初始化接口)。在主循环中每隔1秒从这个I2C接口写出写字符串“x is 12”，其中字符串中的数值是可变的，<br>根据“static uint8_t x=0;”语句，以及每写出一次后执行“x++;”语句，这个字符串的变化规律是怎么样的呢？</p>
<p>(<strong>slaver_receive.ino文件</strong>，编译并下载到一个BlueFi开源板，他是I2C接口的Slave设备)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line">TwoWire* __wire;  <span class="comment">// define a pointer &quot;__wire&quot; to TwoWire type</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  __wire = &amp;Wire;            <span class="comment">// the pointer __wire point to Wire</span></span><br><span class="line">  __wire-&gt;begin(<span class="number">0x72</span>);       <span class="comment">// join i2c bus with address #114</span></span><br><span class="line">  __wire-&gt;onReceive(cb_rev); <span class="comment">// register a callback function on Receive event </span></span><br><span class="line">  Serial.begin(<span class="number">115200</span>);      <span class="comment">// start serial for output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//delay(500);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback function that executes whenever data is received from master</span></span><br><span class="line"><span class="comment">// this function is registered as an event, see setup()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_rev</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>( <span class="number">1</span> &lt; __wire-&gt;available() ) &#123; <span class="comment">// loop through all but the last</span></span><br><span class="line">    <span class="keyword">char</span> c = __wire-&gt;read();         <span class="comment">// receive byte as a character</span></span><br><span class="line">    Serial.print(c);                 <span class="comment">// print the character</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint8_t</span> x = __wire-&gt;read(); <span class="comment">// the last received byte as an integer</span></span><br><span class="line">  Serial.println(x);          <span class="comment">// print the integer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“从机接收”程序中，同样使用指针“__wire”指向I2C接口0，即Wire。初始化时使用“__wire-&gt;begin(0x72)”将I2C接口0配置为从机模式，且从地址为114，<br>并使用“__wire-&gt;onReceive(cb_rev);”语句注册“当接收到主机发送的数据”事件的回调函数——“cb_rev(int num)”。定义这个回调函数时，监测I2C接口0是否有数据可读，<br>如果有效数据个数大于1个则读出1个数据并打印到串口字符控制台，最后一个数据作为整数打印到控制台。</p>
<p>注意，从机的程序中使用的回调函数“void cb_rev(int num)”带有的输入参数“int num”是“onReceive”接口指定的，用于传递发生“onReceive”事件时接收缓冲区内有效的数据个数，<br>此示例中未使用这个参数。</p>
<p>最后，根据图5.8的流程，实现“主机请求读”和“从机写”的程序对儿。示例代码如下：</p>
<p>(<strong>master_request.ino文件</strong>，编译并下载到一个BlueFi开源板，他是I2C接口的Master设备)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line">TwoWire* __wire;  <span class="comment">// define a pointer &quot;__wire&quot; to TwoWire type</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  __wire = &amp;Wire;       <span class="comment">// the pointer __wire point to Wire</span></span><br><span class="line">  __wire-&gt;begin();      <span class="comment">// join i2c bus (address optional for master)</span></span><br><span class="line">  Serial.begin(<span class="number">115200</span>); <span class="comment">// start serial for output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __wire-&gt;requestFrom(<span class="number">0x72</span>, <span class="number">6</span>);<span class="comment">// request 6 bytes from slave device #114</span></span><br><span class="line">  <span class="keyword">while</span>(__wire-&gt;available()) &#123; <span class="comment">// slave may send less than requested</span></span><br><span class="line">    <span class="keyword">char</span> c = __wire-&gt;read();   <span class="comment">// receive a byte as character</span></span><br><span class="line">    Serial.print(c);           <span class="comment">// print the character</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">998</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个主机程序中，初始化部分与前一个“主机写”程序完全一样，但是主循环中的程序完全不同。主主循环程序中，每秒从I2C接口0向地址为114的从机请求6字节数据，<br>然后监测接收缓冲区是否有数据可读，如果有则逐个读出并打印到串口字符控制台。</p>
<p>(<strong>slaver_send.ino文件</strong>，编译并下载到一个BlueFi开源板，他是I2C接口的Slave设备)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wire.h&gt;</span></span></span><br><span class="line">TwoWire* __wire;  <span class="comment">// define a pointer &quot;__wire&quot; to TwoWire type</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  __wire = &amp;Wire;            <span class="comment">// the pointer __wire point to Wire</span></span><br><span class="line">  __wire-&gt;begin(<span class="number">0x72</span>);       <span class="comment">// join i2c bus with address #114</span></span><br><span class="line">  __wire-&gt;onRequest(cb_req); <span class="comment">// register the callback function of OnRequest event</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback function that executes whenever data is requested by master</span></span><br><span class="line"><span class="comment">// this function is registered as an event, see setup()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_req</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  __wire-&gt;write(<span class="string">&quot;hello &quot;</span>); <span class="comment">// respond with message of 6 bytes as expected by master</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个“从机写”的程序中，首先初始化I2C接口0，并注册“当主机请求读数据”事件的回调函数“cb_req”。在回调函数“cb_req”中仅发生6个字符给主机。</p>
<hr>
<p>上面的两对示例程序中，我们仅仅使用I2C硬件抽象层的接口实现两个BlueFi之间通讯，虽然表面上看两对程序各自实现的数据传输都是单工的，<br>即“主机写”和“从机读”、“主机请求”和“从机发送”，实际的输出协议都是双向的。</p>
<p>两个MCU如何使用I2C接口实现双向数据通讯呢？我们可以采用“存储器映射”方案。从机端的数据信息按特定的数据结构(如数组)顺序地存储，<br>主机端首先向从机“写”数据的顺序号来指定数据单元，然后通过请求读取该数据单元，该方法的主机和从机的具体流程参见图5.10所示。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-11-47.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-11-47.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-11-47"></p>
<p>图5.10  使用I2C接口实现两个MCU双向通讯的主机和从机流程(存储器映射)</p>
<p>请根据上图的流程并参考前面的示例程序，分别编写对应的主机端和从机端的程序对儿，并使用两个BlueFi测试程序是否达到目标。</p>
<p>当然，图5.10中的主机流程仅仅是请求从机端指定的静态数据项，因为从机端并没有改变任何数据项。事实上，如果我们允许从机端程序改变图5.10中的数据项，<br>这种改变必须十分的谨慎，因为正在修改数据项时或许会发生回调函数正好读取该数据项，这将引起“竞争”。避免这种竞争的方法之一就是使用“锁(lock)”，<br>数据项操作方在操作前首先检查“锁”的状态，如果被上锁则等待解锁后方可操作，如果未被上锁则先上锁再操作数据项。</p>
<hr>
<p>本节探讨如何使用I2C硬件抽象层的接口实现两个MCU之间通讯，对于主机端的软件操作和实现方法，与前一节所用的方法并无区别。由于I2C从机始终处于被动状态，<br>I2C硬件抽象层为从机端提供专用的接口，包括“OnReceive”和“OnRequest”两种事件的回调函数，使用回调函数确保从机实时地响应主机的写和请求读操作，<br>当然MCU片上I2C接口功能单元的硬件自动处理主机的寻址，以及事件触发，无需从机端软件干预。</p>
<hr>
<p>参考文献：<br>::</p>
<p>  [1] <a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/Wire">https://www.arduino.cc/en/Reference/Wire</a></p>
<p>===========================<br>5.4 I2C接口应用设计<br>===========================</p>
<p>I2C通讯接口作为一种真正的多个外设共享的总线，且只需要2根信号线(SCL和SDA)即可实现上百种外设连接，本节进一步探讨如何使用I2C总线拓展嵌入式系统的功能。<br>图5.11是知名开源硬件供应商——SparkFun推出的Qwiic类开源硬件产品应用示例图 [1]_ ，该产品的主控制器带有I2C通讯接口且工作在主机模式，<br>所有扩展功能模块都采用统一的Qwiic接口，并支持顺序串联联或菊花链等多种连接拓扑。目前SparkFun已推出数百种Qwiic接口的主控制器、传感器、显示器、<br>执行器、I/O扩展等模块，几乎可以满足大多数产品原型开发阶段的功能验证和软件开发测试。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-11-58.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-11-58.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-11-58"><br>图5.11  Qwiic接口产品应用示例(SprakFun)</p>
<p>Qwiic采用4根连接线和4脚的1.0mm间距的连接器，推荐使用的连接器内部带有键槽以防插错，4根连接线的信号分别为SCL、SDA、Vcc和GND，即2根电源线和2根I2C接口信号线。<br>本质上，Qwiic接口就是带有电源线的I2C通讯接口。Qwiic接口与传统的4线USB、PS2等接口相似，不仅具有数据接口信号线还具有电源线，使用这样的接口时从机无需额外供电。</p>
<p>此外，另一家知名开源硬件供应商——Adafruit推出的STEMMA QT接口 [2]_ 与Qwiic几乎完全相同，两种接口的所用连接器的机械标准和电气标准完全兼容。这种接口为什么备受欢迎呢？<br>主要原因是I2C接口的共享总线方便嵌入式系统扩展更多种(上百种)功能，以及扩展功能单元的模块化等。图5.12是Qwiic接口或STEMMA QT接口的电路模型。<br><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-12-16.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-12-16.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-12-16"></p>
<p>图5.12  Qwiic/STEMMA QT接口的电路模型</p>
<p>上图中，我们给出4种典型的I2C接口的功能扩展模块的电路模型，左侧两种扩展单元都具有标准I2C通讯接口(从机)，右侧两种都是采用MCU(I2C从机模式)转换为标准I2C通讯接口。</p>
<p>许多集成型I2C接口的传感器，譬如SHT30-DIS、LSM6DS3、VL53L0X(TOF型激光测距传感器)等，以及显示器和RTC，譬如OLED点阵屏等，除了I2C接口和供电之外无需额外的元件和接口，<br>这类传感器和显示器的I2C接口模块非常适合采用Qwiic/STEMMA QT接口，4芯连线就可以将这些模块串联起来并与主控制器的MCU连接起来。还有一些I2C接口的传感器、ADC和DAC，<br>如MPR121(12通道人体触摸感知)、MCP9600(热电偶传感器)、ADS1115(8路ADC)、MCP4728(4路DAC)等，以及I2C接口的电机驱动和I/O扩展单元，譬如PCA9685、<br>MCP23017等，除了I2C接口和供电之外还需要一些特殊连接器与目标传感器、电机等连接。</p>
<p>基于I2C通讯接口也可以实现分布式系统，这样的分布式系统不仅容易开发和维护，而且采用连接子系统的总线拓扑也十分灵活。仅有UART接口的GPS(全球定位系统)/BDS(北斗系统)等模块，<br>可以使用MCU单独设计“I2C-UART”桥接单元将非I2C接口的功能单元连接到I2C总线。</p>
<p>下面用两种具体的设计示例来帮助我们了解上述的电路模型。第一个示例是Adafruit的TOF(Time-Of-Flight)激光测距模块 [3]_ ，该模块的采用ST公司的集成型TOF传感器VL53L0X，<br>具体的电路原理图、PCB和实物参见图5.13。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-12-25.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-12-25.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-12-25"></p>
<p>图5.13  采用Qwiic/STEMMA QT接口的TOF激光测距传感器模块(Adafruit)</p>
<p>这个I2C接口的激光测距模块的有效量程和编程控制API请参阅页面 [4]_ ，该传感器非常适合于机器人避障、抗疫自动测温控制等应用场景。</p>
<p>第二个示例来自SparkFun [5]_ ，这是一种步进电机(或双直流电机)控制模块。该模块使用一颗小型ARM Cortex-M0系列MCU——CY8C4245控制一个步进电机驱动器，<br>并使用I2C从机模式接入I2C总线。</p>
<p><img src="https://image.wxydejoy.top/img/I2C2021-08-04-20-12-42.jpg" class="lazy" data-srcset="https://image.wxydejoy.top/img/I2C2021-08-04-20-12-42.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="I2C2021-08-04-20-12-42"></p>
<p>图5.14  采用Qwiic/STEMMA QT接口的步进电机驱动模块(SparkFun)</p>
<p>很显然，上述两种示例都采用Qwiic/STEMMA QT接口，主控制器端用于控制这两种扩展模块的软件几乎相同，主控制器的I2C接口工作在主机模式，两种扩展模块都是I2C从机，<br>他们都具有相同内惟一的I2C从机地址，主机使用惟一的从机地址分别寻址其中某个扩展模块并实现测控功能。请参考第5.2节编写这些扩展功能单元的软件实现，此处不在赘述。</p>
<hr>
<p>本节使用知名开源硬件供应商推出的Qwiic/STEMMA QT接口类产品为例，详细地探讨基于I2C通讯接口的嵌入式系统原型设计方法和硬件模型。</p>
<p>在前几节的内容中我们已经了解MCU片上I2C功能单元的主机模式和从机模式及其接口和编程控制，现在你可以花一些时间完善BlueFi开源板上I2C接口传感器的BSP，<br>完成这些工作需要参考第5.2节的温湿度传感器(SHT30-DIS)、加速度和陀螺仪传感器(LSM6DS33)的BSP实现，并查阅LSM3MDL和APDS-9960两种传感器的手册，<br>以及github等开源代码库中搜索相关开源代码。</p>
<hr>
<p>参考文献：<br>::</p>
<p>  [1] <a target="_blank" rel="noopener" href="https://www.sparkfun.com/qwiic">https://www.sparkfun.com/qwiic</a><br>  [2] <a target="_blank" rel="noopener" href="https://learn.adafruit.com/introducing-adafruit-stemma-qt?view=all">https://learn.adafruit.com/introducing-adafruit-stemma-qt?view=all</a><br>  [3] <a target="_blank" rel="noopener" href="https://learn.adafruit.com/adafruit-vl53l0x-micro-lidar-distance-sensor-breakout?view=all">https://learn.adafruit.com/adafruit-vl53l0x-micro-lidar-distance-sensor-breakout?view=all</a><br>  [4] <a target="_blank" rel="noopener" href="https://www.st.com/resource/en/datasheet/vl53l0x.pdf">https://www.st.com/resource/en/datasheet/vl53l0x.pdf</a><br>  [5] <a target="_blank" rel="noopener" href="https://www.sparkfun.com/products/15451">https://www.sparkfun.com/products/15451</a></p>
<p>===========================<br>5.5 本章总结<br>===========================</p>
<p>I2C是一种同步通讯接口，通讯数据信号SDA和同步时钟信号SCL始终保持同步，两者之间的时空关系是I2C接口时序。</p>
<p>I2C是嵌入式系统中的一种真正的共享总线，仅使用2种信号即可实现上百种传感器、执行器、显示器等外设扩展。I2C总线的这种性能得益于I2C接口所采用的“线与”电路结构，<br>以及I2C接口时序和数据传输协议。I2C通讯接口采用主从模式，支持一主多从和多主多从的灵活结构。一主多从的系统结构中，要求每一个从机都有惟一的7位从机地址，<br>主机通过寻址某个指定的从机以实现一对一半双工通讯。多主多从的系统结构中，为实现多个主机同时抢占I2C总线需要每一个I2C主机单元都支持总线仲裁，<br>发起抢占总线的主机根据总线仲裁结果确定是否抢占成功或失败，抢占失败的主机将进入等待，所以多主多从的系统结构的通讯接口操作存在不确定性和非实时性。<br>本章内容中仅涉及最常用的一主多从结构。当单个I2C通讯总线上挂接多种从机时，逻辑电平的电压匹配非常重要，适合于I2C通讯接口电平匹配必须是双向的，<br>我们在本章提供一种简易型电平转换电路(Level Shifter)单元，也可以采用专用的电平转换单元，专用的电平转换单元具有通讯速度高、漏电流小等特点。</p>
<p>嵌入式系统MCU的片上I2C通讯接口具有两种工作模式：主机模式和从机模式。主机模式的I2C接口可用于扩展系统内的各种I2C接口显示器、传感器、执行器等，<br>从机模式下的I2C接口允许MCU作为另一个主控制器的子系统，两个MCU之间可以使用I2C总线实现半双工通讯。</p>
<p>本章中，我们分别以主机和从机两种模式讨论I2C通讯接口的软件封装，仍采用分层抽象的方法，将I2C通讯的软件接口分割为硬件层、硬件抽象层、中间层和用户层。<br>其中，硬件层的接口软件由半导体厂商实现，主要是访问MCU片上I2C功能单元相关的寄存器；硬件抽象层是基于硬件层的软件接口为中间层分别提供I2C主机和从机两种模式的I2C协议实现的软件接口；<br>中间层是针对特定的嵌入式系统内I2C总线上各个I2C功能组件的软件接口，基于硬件抽象层的I2C通讯协议接口访问I2C功能组件上的寄存器等；<br>特定嵌入式系统的用户层直接调用BSP中的相关I2C功能组件接口，无需了解I2C协议和I2C功能组件内寄存器等细节即可使用I2C功能组件。</p>
<p>基于I2C总线的原型系统是较为流行的一种模块化的、快速的原型搭建系统，“如何将各种功能单元设计成具有标准的I2C接口的模块”是此类系统的设计关键，<br>本章给出I2C接口应用设计的电路模型，以及主机和从机模式的软件实现。</p>
<p>通过本章学习，我们了解I2C通讯接口的原理、协议、软硬件应用的设计方法等。I2C通讯接口是现代MCU标配的片上功能单元，也是最常用的嵌入式系统内各组件之间的互联总线。<br>本章内容属于嵌入式系统应用和开发的基础之一。</p>
<hr>
<p>本章总结如下：</p>
<ol>
<li>数字通讯相关的基础概念</li>
<li>I2C通讯接口的“线与”电路、时序、协议、寻址方法、通讯流程、电平转换方法等</li>
<li>MCU片上I2C功能单元工作在主机模式时，I2C接口软件的封装和实现</li>
<li>MCU片上I2C功能单元工作在从机模式时，I2C接口的通讯流程和软件实现</li>
<li>I2C总线的原型系统的模型和设计示例</li>
</ol>
<p>===========================<br> 思考题<br>===========================</p>
<ol>
<li>查阅“双向三态门”电路及其逻辑，并根据图5.2的“线与”接口电路，请试着使用双向三态门单元改进I2C接口单元的硬件接口电路，并分别描述主机发送-从机接收、从机发送-主机接收的两种工作模式的控制信号状态。</li>
<li>根据图5.5所示的双向电平电压转换电路，请简要分析其工作过程。</li>
<li>当你设计一个嵌入式系统时所用到的I2C功能组件通讯接口速度不一致，请给出合理的解决方案。</li>
<li>单主-多从结构的I2C通讯接口中仅使用7位宽从机地址即可连接上百个I2C功能组件，请说明7位从机地址的作用，并简述主机访问某个从机的过程。</li>
<li>当MCU片上I2C功能单元工作在主机模式时，以读取某I2C接口的传感器数据为例，简述SCL和SDA信号的输出方向和两者关系。</li>
<li>以I2C通讯接口软件的分层抽象为例，简述硬件层、硬件抽象层、BSP(或中间层)、用户层等各层的功能和作用，并总结分层抽象软件结构的优缺点。</li>
<li>在Arduino平台的I2C硬件抽象层中，为什么“beginTransmission()”、“endTransmission()”和“setClock()”是主机模式专用的接口？</li>
<li>参照图5.8的流程，设计I2C接口的“主机写后读”的操作流程，即“主机写-从机读-(无STOP时序)-主机请求-从机写”的操作流程。</li>
</ol>

    </div>
    
    <div class="post__license">
        <p>
            <strong>本文作者：</strong>wxy
        </p>
        <p>
            <strong>
                本文链接：
            </strong>
            <a href="https://wxydejoy.top/posts/218/">https://wxydejoy.top/posts/218/</a>
        </p>
        
            <strong>
                <p>文章默认使用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议进行许可，使用时请注意遵守协议。</p>

            </strong>
        
    </div>
 
    <div class="post-footer__meta"><p>文章写于2021-10-05</p></div> 
    <div class="post-entry__tags"></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/posts/48c8/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            SPI接口及其应用 精简版
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/posts/aacb/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            SPI接口及其应用
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2021&nbsp;-&nbsp;2021 <a href="/">快乐星球</a>
        </p>
    
    
        
            <p><img src="https://cdn.jsdelivr.net/gh/wxydejoy/image@master/img/202107/15/181743%20%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png"style="margin-inline:5px"><a style="margin-inline:5px" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602011871">浙公网安备 33010602011871号</a> <a style="margin-inline:5px" target="_blank" href="http://beian.miit.gov.cn/">浙ICP备2021022005号</a></p>
        
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 

 



 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 


    <script src='https://cdn.jsdelivr.net/npm/mermaid@8.10.2/dist/mermaid.min.js'></script>
    <script>
            mermaid.initialize(JSON.stringify(''));
    </script>
 

 




    </body>
</html>
